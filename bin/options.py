## @package property handling
#
# (c) copyright 2009-2011 Ralf Habacker <ralf.habacker@freenet.de>
#
#
# properties from classes in this package could be set
#
# - by package scripts,
# - by setting the 'Options' environment variable or
# - by command line
#
# for example:
#
# in blueprints/subdir/package/file.py
#   ...
#   self.subinfo.options.cmake.openIDE=1
#
# or
#
# craft "--options=cmake.openIDE=1" --make kdewin-installer
#
# or
#
# set Options=cmake.openIDE=1
# craft --make kdewin-installer
#
# The parser in this package is able to set all attributes
#
# for example:
#
#  craft "--options=unpack.unpackIntoBuildDir=1 useBuildType=1" --make <package>
#
import utils
from CraftConfig import *
from CraftCore import CraftCore
from Blueprints.CraftPackageObject import CraftPackageObject

import configparser
import atexit
import copy

class UserOptions(object):
    # TODO: port to singleton to clear in unit test
    _settings = None
    _path = None
    _commandlineOptions = {}
    _packageOptions = {}
    _options = {}
    _registeredOptions = {}

    __cachedOptions = {}
    __member = {"settings", "package", "registerOption"}
    __coreCategory = "#Core"
    __reserved = {"version", "ignored"}
    __header = """\
# The content of this file is partly autogenerated
# You can modify values and add settings for your blueprints
# Common settings available for all blueprints are:
#     ignored: [True|False]
#     version: some version
#     args: arguments passed to the configure step
#
# Example:
##     [libs]
##     ignored = True
##
##     [lib/qt5]
##     version = 5.9.3
##     ignored = False
##     withMySQL = True
##
##     [kde/pim/akonadi]
##     args = -DAKONADI_BUILD_QSQLITE=On
##
#
# Settings are inherited, so you can set them for a whole sub branch or a single blueprint.
# While blueprint from [libs] are all ignored blueprint from [libs/qt5] are not.
#
"""


    @staticmethod
    def instance():
        if not UserOptions._settings:
            UserOptions._path = CraftCore.settings.get("Blueprints", "Settings", os.path.join(CraftCore.standardDirs.etcDir(), "BlueprintSettings.ini"))
            UserOptions._settings = configparser.ConfigParser(allow_no_value=True)
            UserOptions._settings.optionxform = str
            if os.path.isfile(UserOptions._path):
                UserOptions.instance().read(UserOptions._path)
            if not UserOptions.instance().has_section(UserOptions.__coreCategory):
                UserOptions.instance().add_section(UserOptions.__coreCategory)
            UserOptions._options = Options(package=None)
            settings = UserOptions.instance()[UserOptions.__coreCategory]
            UserOptions._init_vars(settings, UserOptions._options)
        return UserOptions._settings

    @staticmethod
    def _init_vars(settings, opt, prefix="") -> None:
        for var in vars(opt):
            if var.startswith("_"):
                continue
            attr = getattr(opt, var)
            if isinstance(attr, (bool, str, int, type(None))):
                key = f"{prefix}{var}"
                if key not in settings:
                    if not attr is None:
                        settings[key] = str(attr)
                    else:
                        settings[key] = None
                else:
                    val = settings[key]
                    if isinstance(attr, bool):
                        val = UserOptions._settings._convert_to_boolean(val)
                    setattr(opt, var, val)
            else:
                UserOptions._init_vars(settings, attr, prefix=f"{prefix}{var}.")

    def __init__(self, package):
        settings = UserOptions.instance()
        self.package = package
        self.settings = settings[package.path] if settings.has_section(package.path) else None

    @staticmethod
    def setOptions(optionsIn):
        options = {}
        packageOptions = {}
        for o in optionsIn:
            key, value = o.split("=", 1)
            if "." in key:
                package, key = key.split(".", 1)
                if package == "dynamic":
                    CraftCore.log.warning(f"Detected a deprecated setting \"{package}.{key} = {value}\", use the BlueprintsSettings.ini")
                    options[key] = value
                else:
                    # make sure it is a blueprint related setting
                    if CraftPackageObject.get(package):
                        if package not in packageOptions:
                            packageOptions[package] = {}
                        packageOptions[package][key] = value
                    else:
                        options[f"{package}.{key}"] = value
        UserOptions._commandlineOptions = options
        UserOptions._packageOptions = packageOptions


    @staticmethod
    def addPackageOption(package : CraftPackageObject, key : str, value : str) -> None:
        if package.path not in UserOptions._packageOptions:
            UserOptions._packageOptions[package.path] = {}
        UserOptions._packageOptions[package.path][key] = value

    @staticmethod
    @atexit.register
    def __dump():
        if UserOptions._settings:
            with open(UserOptions._path, 'wt+') as configfile:
                print(UserOptions.__header, file=configfile)
                UserOptions.instance().write(configfile)

    def __setattr__(self, key, value):
        if key in UserOptions.__member:
            super().__setattr__(key, value)
            return
        settings = self.settings
        if not settings:
            settings = UserOptions.__init(self)
        settings[key] = str(value)

    @staticmethod
    def __init(self, key=None, default=None):
        if not UserOptions.instance().has_section(self.package.path):
            UserOptions.instance().add_section(self.package.path)
        settings = self.settings = UserOptions.instance()[self.package.path]
        if key and key not in settings:
            settings[key] = default
        return settings

    def __getattribute__(self, name):
        if name in UserOptions.__member:
            return super().__getattribute__(name)
        packagePath = self.package.path

        if packagePath not in UserOptions.__cachedOptions:
            UserOptions.__cachedOptions[packagePath] = {}
        cache = UserOptions.__cachedOptions[packagePath]
        if name in cache:
            return cache[name]

        settings = self.settings
        out = None

        if name not in UserOptions.__reserved:
            # this blueprint has special options, make them public
            settings = UserOptions.__init(self, name)

        if name in UserOptions._commandlineOptions:
            # those values are temporary and must not be saved
            out = UserOptions._commandlineOptions[name]
        elif packagePath in UserOptions._packageOptions and name in UserOptions._packageOptions[packagePath]:
            # those values are temporary and must not be saved
            out = UserOptions._packageOptions[packagePath][name]
        elif settings and name in settings:
            if name == "ignored":
                out = UserOptions.instance()._convert_to_boolean(settings["ignored"])
            else:
                out = settings[name]

        parent = self.package.parent
        while parent:
            out = getattr(UserOptions(parent), name)
            if out:
                break
            parent = parent.parent

        # no value found
        if name == "args":
            out = ""

        _type = type(UserOptions._registeredOptions[packagePath].get(name)
                    if packagePath in UserOptions._registeredOptions else None)
        def convert(x):
            out = x
            if _type is bool:
                out = UserOptions.instance()._convert_to_boolean(x)
            elif _type is not type(None):
                out = _type(x)
            return out
        out = convert(out)

        cache[name] = out
        return out

    def registerOption(self, key : str, default) -> None:
        package = self.package
        if package.path not in UserOptions._registeredOptions:
            UserOptions._registeredOptions[package.path] = {}
        UserOptions._registeredOptions[package.path][key] = default
        UserOptions.__init(self, key, default)



class OptionsBase(object):
    def __init__(self):
        pass

## options for enabling or disabling features of KDE
## in the future, a certain set of features make up a 'profile' together
class OptionsFeatures(OptionsBase):
    def __init__(self):
        class PhononBackend(OptionsBase):
            def __init__(self):
                ## options for the phonon backend
                self.vlc = True
                self.ds9 = False

        self.phononBackend = PhononBackend()

        ## option whether to build nepomuk
        self.nepomuk = True

        ## enable python support in several packages.
        self.pythonSupport = False

        ## stick to the gcc 4.4.7 version
        self.legacyGCC = False

        ## enable or disable the dependency to plasma
        self.fullplasma = False

        ## enable plugins of kdevelop
        self.fullkdevelop = False


## options for the fetch action
class OptionsFetch(OptionsBase):
    def __init__(self):
        ## option comment
        self.option = None
        self.ignoreExternals = False
        ## enable submodule support in git single branch mode
        self.checkoutSubmodules = False


## options for the unpack action
class OptionsUnpack(OptionsBase):
    def __init__(self):
        ## By default archives are unpackaged into the workdir.
        #  Use this option to unpack archives into recent build directory
        self.unpackIntoBuildDir = False
        #  Use this option to run 3rd party installers
        self.runInstaller = False


## options for the configure action
class OptionsConfigure(OptionsBase):
    def __init__(self):
        ## with this option additional arguments could be added to the configure commmand line
        self.args = None
        ## with this option additional arguments could be added to the configure commmand line (for static builds)
        self.staticArgs = None
        ## set source subdirectory as source root for the configuration tool.
        # Sometimes it is required to take a subdirectory from the source tree as source root
        # directory for the configure tool, which could be enabled by this option. The value of
        # this option is added to sourceDir() and the result is used as source root directory.
        self.configurePath = None
        # add build target to be included into build. This feature is cmake only and requires the
        # usage of the 'macro_optional_add_subdirectory' macro. The value is a string.
        self.onlyBuildTargets = None

        # add the cmake defines that are needed to build tests here
        self.testDefine = None

        ## run autogen in autotools
        self.bootstrap = False

        # do not use default include path
        self.noDefaultInclude = False

        ## do not use default lib path
        self.noDefaultLib = False

        ## set this attribute in case a non standard configuration
        # tool is required (supported currently by QMakeBuildSystem only)
        self.tool = False

        # do not add --prefix on msys
        self.noDefaultOptions = False

        # cflags currently only used for autotools
        self.cflags = ""

        # cxxflags currently only used for autotools
        self.cxxflags = ""

        # ldflags currently only used for autotools
        self.ldflags = ""

        # the project file, this is either a .pro for qmake or a sln for msbuild
        self.projectFile = None


## options for the make action
class OptionsMake(OptionsBase):
    def __init__(self):
        ## ignore make error
        self.ignoreErrors = None
        ## options for the make tool
        self.makeOptions = None
        ## define the basename of the .sln file in case cmake.useIDE = True
        self.slnBaseName = None
        self.supportsMultijob = True


## options for the install action
class OptionsInstall(OptionsBase):
    def __init__(self):
        ## use either make tool for installing or
        # run cmake directly for installing
        self.useMakeToolForInstall = True
        ## add DESTDIR=xxx support for autotools build system
        self.useDestDir = True


## options for the merge action
class OptionsMerge(OptionsBase):
    def __init__(self):
        ## subdir based on installDir() used as merge source directory
        self.sourcePath = None


## options for the package action
class OptionsPackage(OptionsBase):
    def __init__(self):
        ## defines the package name
        self.packageName = None
        ## defines the package version
        self.version = None
        ## use compiler in package name
        self.withCompiler = True
        ## use special packaging mode  (only for qt)
        self.specialMode = False
        ## pack also sources
        self.packSources = True
        ## pack from subdir of imageDir()
        # currently supported by SevenZipPackager
        self.packageFromSubDir = None
        ## use architecture in package name
        # currently supported by SevenZipPackager
        self.withArchitecture = False
        ## add file digests to the package located in the manifest sub dir
        # currently supported by SevenZipPackager
        self.withDigests = True
        ##disable stripping of binary files
        # needed for mysql, striping make the library unusable
        self.disableStriping = False

        ##disable the binary cache for this package
        self.disableBinaryCache = False

        ## wheter to move the plugins to bin
        self.movePluginsToBin = utils.OsUtils.isWin()


class OptionsCMake(OptionsBase):
    def __init__(self):
        ## use IDE for msvc2008 projects
        self.useIDE = False
        ## use IDE for configuring msvc2008 projects, open IDE in make action instead of running command line orientated make
        self.openIDE = False
        ## use CTest instead of the make utility
        self.useCTest = CraftCore.settings.getboolean("General", "EMERGE_USECTEST", False)


class OptionsGit(OptionsBase):
    def __init__(self):
        ## enable support for applying patches in 'format-patch' style with 'git am' (experimental support)
        self.enableFormattedPatch = False


## main option class
class Options(object):
    def __init__(self, package=None):
        if package:
            #init
            UserOptions.instance()
            self.__dict__ = copy.deepcopy(UserOptions._options.__dict__)
            self.dynamic = UserOptions(package)
            return

        ## options for the dependency generation
        self.features = OptionsFeatures()
        ## options of the fetch action
        self.fetch = OptionsFetch()
        ## options of the unpack action
        self.unpack = OptionsUnpack()
        ## options of the configure action
        self.configure = OptionsConfigure()
        ## options of the configure action
        self.make = OptionsMake()
        ## options of the install action
        self.install = OptionsInstall()
        ## options of the package action
        self.package = OptionsPackage()
        ## options of the merge action
        self.merge = OptionsMerge()
        ## options of the cmake buildSystem
        self.cmake = OptionsCMake()
        ## options of the git module
        self.git = OptionsGit()

        ## add the date to the target
        self.dailyUpdate = False

        ## has an issue with a too long path
        self.needsShortPath = False

        ## this option controls if the build type is used when creating build and install directories.
        # The following example shows the difference:
        # \code
        #                True                                False
        # work/msvc2008-RelWithDebInfo-svnHEAD     work/msvc2008-svnHEAD
        # image-msvc2008-RelWithDebInfo-svnHEAD    image-msvc2008-svnHEAD
        # \endcode
        #
        self.useBuildType = True

        ## skip the related package from debug builds
        self.disableDebugBuild = False
        ## skip the related package from release builds
        self.disableReleaseBuild = False
        ## exit if system command returns errors
        self.exitOnErrors = True

        ## there is a special option available already
        self.buildTools = False
        self.buildStatic = CraftCore.settings.getboolean("Compile", "Static")

        self.useShadowBuild = True

    def isActive(self, package):
        if isinstance(package, str):
            package = CraftPackageObject.get(package)
        return not package.isIgnored()
