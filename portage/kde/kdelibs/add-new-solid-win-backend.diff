diff -Nru -x '*~' kdelibs-4.10.2.orig/CMakeLists.txt kdelibs-4.10.2/CMakeLists.txt
--- kdelibs-4.10.2.orig/CMakeLists.txt	2013-03-29 09:30:09.355321000 +0100
+++ kdelibs-4.10.2/CMakeLists.txt	2013-06-01 14:28:09.601842800 +0200
@@ -41,6 +41,9 @@
 ############### Give the user the option to build the udisks2 solid backend instead of the udisks backend ###############
 option(WITH_SOLID_UDISKS2 "Enable the udisks2 solid backend instead")
 
+############### Give the user the option to build the deprecated WMI solid backend instead of the new win backend ###############
+option(WITH_SOLID_WMI "Enables the deprecated WMI backend on Windows")
+
 ############### Load the CTest options ###############
 # CTestCustom.cmake has to be in the CTEST_BINARY_DIR.
 # in the KDE build system, this is the same as CMAKE_BINARY_DIR.
diff -Nru -x '*~' kdelibs-4.10.2.orig/kjs/wtf/AlwaysInline.h kdelibs-4.10.2/kjs/wtf/AlwaysInline.h
--- kdelibs-4.10.2.orig/kjs/wtf/AlwaysInline.h	2013-03-01 07:26:14.347776000 +0100
+++ kdelibs-4.10.2/kjs/wtf/AlwaysInline.h	2013-06-01 14:28:09.604843000 +0200
@@ -22,7 +22,7 @@
 
 
 #ifndef ALWAYS_INLINE
-#if COMPILER(GCC) && defined(NDEBUG) &&  __GNUC__ > 3
+#if !defined(_WIN32) && COMPILER(GCC) && defined(NDEBUG) &&  __GNUC__ > 3
 #define ALWAYS_INLINE inline __attribute__ ((__always_inline__))
 #elif COMPILER(MSVC) && defined(NDEBUG)
 #define ALWAYS_INLINE __forceinline
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winacadapter.cpp kdelibs-4.10.2/solid/solid/backends/win/winacadapter.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winacadapter.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winacadapter.cpp	2013-06-01 14:28:09.608843200 +0200
@@ -0,0 +1,56 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "winacadapter.h"
+
+using namespace Solid::Backends::Win;
+
+WinAcadapter::WinAcadapter(WinDevice *device) :
+    WinInterface(device)
+{
+    powerChanged();
+    connect(WinDeviceManager::instance(),SIGNAL(powerChanged()),this,SLOT(powerChanged()));
+}
+
+bool WinAcadapter::isPlugged() const
+{
+    return m_pluggedIn == 1;
+}
+
+QSet<QString> WinAcadapter::getUdis()
+{
+    QSet<QString> out;
+    out << QLatin1String("/org/kde/solid/win/power/acadapter");
+    return out;
+}
+
+void WinAcadapter::powerChanged()
+{
+    SYSTEM_POWER_STATUS status;
+    ZeroMemory(&status,sizeof(SYSTEM_POWER_STATUS));
+    GetSystemPowerStatus(&status);
+    if(status.ACLineStatus != m_pluggedIn)
+    {
+        emit plugStateChanged(status.ACLineStatus == 1,m_device->udi());
+    }
+    m_pluggedIn = status.ACLineStatus;
+
+}
+
+#include "winacadapter.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winacadapter.h kdelibs-4.10.2/solid/solid/backends/win/winacadapter.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winacadapter.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winacadapter.h	2013-06-01 14:28:09.611843400 +0200
@@ -0,0 +1,58 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifndef WINACADAPTER_H
+#define WINACADAPTER_H
+
+#include <solid/ifaces/acadapter.h>
+#include "wininterface.h"
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+class WinAcadapter : public WinInterface, virtual public Solid::Ifaces::AcAdapter
+{
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::AcAdapter)
+public:
+    WinAcadapter(WinDevice *device);
+
+    virtual bool isPlugged() const;
+
+    static QSet<QString> getUdis();
+
+
+signals:
+    void plugStateChanged(bool newState, const QString &udi);
+
+private slots:
+    void powerChanged();
+
+private:
+    int m_pluggedIn;
+
+};
+
+}
+}
+}
+#endif // WINACADAPTER_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winbattery.cpp kdelibs-4.10.2/solid/solid/backends/win/winbattery.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winbattery.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winbattery.cpp	2013-06-01 14:28:09.614843500 +0200
@@ -0,0 +1,180 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "winbattery.h"
+
+#include <setupapi.h>
+#include <batclass.h>
+#include <devguid.h>
+
+using namespace Solid::Backends::Win;
+
+QMap<QString,WinBattery::Battery> WinBattery::m_udiToGDI = QMap<QString,WinBattery::Battery>();
+
+WinBattery::WinBattery(WinDevice *device) :
+    WinInterface(device),
+    m_state(Solid::Battery::NoCharge)
+{
+    powerChanged();
+    connect(WinDeviceManager::instance(),SIGNAL(powerChanged()),this,SLOT(powerChanged()));
+}
+
+bool WinBattery::isPlugged() const
+{
+    return m_pluggedIn;
+}
+
+Solid::Battery::BatteryType WinBattery::type() const
+{
+    return m_type;
+}
+
+int WinBattery::chargePercent() const
+{
+    return m_charge;
+}
+
+bool WinBattery::isRechargeable() const
+{
+    return m_rechargabel;
+}
+
+Solid::Battery::ChargeState WinBattery::chargeState() const
+{
+    return m_state;
+}
+
+QSet<QString> WinBattery::getUdis()
+{
+    QSet<QString> udis;
+    HDEVINFO hdev =
+            SetupDiGetClassDevs(&GUID_DEVCLASS_BATTERY,
+                                0,
+                                0,
+                                DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
+
+    if (INVALID_HANDLE_VALUE != hdev)
+    {
+        // Limit search to 100 batteries max
+        for (int idev = 0; idev < 100; idev++)
+        {
+            SP_DEVICE_INTERFACE_DATA did;
+            ZeroMemory(&did,sizeof(did));
+            did.cbSize = sizeof(did);
+
+            if (SetupDiEnumDeviceInterfaces(hdev,
+                                            0,
+                                            &GUID_DEVCLASS_BATTERY,
+                                            idev,
+                                            &did))
+            {
+                DWORD cbRequired = 0;
+
+                SetupDiGetDeviceInterfaceDetailW(hdev,
+                                                &did,
+                                                0,
+                                                0,
+                                                &cbRequired,
+                                                0);
+                if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
+                {
+                    char *buffer = new char[cbRequired];
+                    SP_DEVICE_INTERFACE_DETAIL_DATA *pdidd = (SP_DEVICE_INTERFACE_DETAIL_DATA*)buffer;
+                    ZeroMemory(pdidd,cbRequired);
+                    pdidd->cbSize = sizeof(*pdidd);
+                    if (SetupDiGetDeviceInterfaceDetail(hdev,
+                                                        &did,
+                                                        pdidd,
+                                                        cbRequired,
+                                                        &cbRequired,
+                                                        0))
+                    {
+                        QString path = QString::fromWCharArray(pdidd->DevicePath);
+                        ulong tag = WinDeviceManager::getDeviceInfo<ulong>(path,IOCTL_BATTERY_QUERY_TAG);
+                        QString udi = QLatin1String("/org/kde/solid/win/power.battery/battery#") + QString::number(tag);
+                        udis << udi;
+                        m_udiToGDI[udi] = Battery(path,tag);
+                    }
+                    delete [] buffer;
+
+                }
+            }
+        }
+
+        SetupDiDestroyDeviceInfoList(hdev);
+    }
+    return udis;
+}
+
+const WinBattery::Battery WinBattery::batteryInfoFromUdi(const QString &udi)
+{
+    return m_udiToGDI[udi];
+}
+
+void WinBattery::powerChanged()
+{
+
+    BATTERY_WAIT_STATUS query;
+    ZeroMemory(&query,sizeof(query));
+    Battery b =  m_udiToGDI[m_device->udi()];
+    query.BatteryTag = b.second;
+    BATTERY_STATUS status = WinDeviceManager::getDeviceInfo<BATTERY_STATUS,BATTERY_WAIT_STATUS>(b.first,IOCTL_BATTERY_QUERY_STATUS,&query);
+
+    BATTERY_QUERY_INFORMATION query2;
+    ZeroMemory(&query2,sizeof(query2));
+    query2.BatteryTag = b.second;
+    query2.InformationLevel = BatteryInformation;
+    BATTERY_INFORMATION info = WinDeviceManager::getDeviceInfo<BATTERY_INFORMATION,BATTERY_QUERY_INFORMATION>(b.first,IOCTL_BATTERY_QUERY_INFORMATION,&query2);
+
+    m_pluggedIn = status.PowerState & BATTERY_POWER_ON_LINE;
+    if(info.FullChargedCapacity!=0)
+    {
+        m_charge = (float)status.Capacity/info.FullChargedCapacity*100.0;
+    }
+
+    if(status.PowerState == 0)
+    {
+        m_state = Solid::Battery::NoCharge;
+    }
+    else if(status.PowerState & BATTERY_CHARGING)
+    {
+        m_state = Solid::Battery::Charging;
+    }
+    else if(status.PowerState & BATTERY_DISCHARGING)
+    {
+        m_state = Solid::Battery::Discharging;
+    }
+    //    else if(info.PowerState & 0x00000008)//critical
+    //    {
+
+    //    }
+
+
+    if(info.Capabilities & BATTERY_SYSTEM_BATTERY)
+    {
+        m_type = Solid::Battery::PrimaryBattery;
+    }
+    else{
+        m_type = Solid::Battery::UnknownBattery;
+    }
+
+    m_rechargabel = info.Technology == 1;
+}
+
+#include "winbattery.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winbattery.h kdelibs-4.10.2/solid/solid/backends/win/winbattery.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winbattery.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winbattery.h	2013-06-01 14:28:09.618843800 +0200
@@ -0,0 +1,80 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef WINBATTERY_H
+#define WINBATTERY_H
+
+
+#include <solid/ifaces/battery.h>
+
+#include "wininterface.h"
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+class WinBattery : public WinInterface, virtual public Solid::Ifaces::Battery
+{    
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::Battery)
+
+public:
+    typedef QPair<QString,ulong> Battery;
+
+    WinBattery(WinDevice *device);
+
+    virtual bool isPlugged() const;
+
+    virtual Solid::Battery::BatteryType type() const;
+
+    virtual int chargePercent() const;
+
+    virtual bool isRechargeable() const;
+
+    virtual Solid::Battery::ChargeState chargeState() const;
+
+    static QSet<QString> getUdis();
+
+    static const Battery batteryInfoFromUdi(const QString &udi);
+
+signals:
+    void chargePercentChanged(int value, const QString &udi) ;
+    void chargeStateChanged(int newState, const QString &udi);
+    void plugStateChanged(bool newState, const QString &udi);
+
+private slots:
+    void powerChanged();
+
+private:
+
+    static QMap<QString,Battery> m_udiToGDI;
+    bool m_pluggedIn;
+    Solid::Battery::BatteryType m_type;
+    int m_charge;
+    bool m_rechargabel;
+    Solid::Battery::ChargeState m_state;
+};
+}
+}
+}
+
+#endif // WINBATTERY_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winblock.cpp kdelibs-4.10.2/solid/solid/backends/win/winblock.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winblock.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winblock.cpp	2013-06-01 14:28:09.656845900 +0200
@@ -0,0 +1,224 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "winblock.h"
+
+#include <QSettings>
+#include <QDebug>
+
+using namespace Solid::Backends::Win;
+
+#ifdef HEAVE_DRIVER_KIT
+#include <ntddcdrm.h>
+#include <ntddmmc.h>
+#endif
+
+QMap<QString,QString> WinBlock::m_driveLetters = QMap<QString,QString>();
+QMap<QString,QSet<QString> > WinBlock::m_driveUDIS = QMap<QString,QSet<QString> >();
+QMap<QString,QString> WinBlock::m_virtualDrives = QMap<QString,QString>();
+
+WinBlock::WinBlock(WinDevice *device):
+    WinInterface(device),
+    m_major(-1),
+    m_minor(-1)
+{
+    if(m_device->type() == Solid::DeviceInterface::StorageVolume)
+    {
+        STORAGE_DEVICE_NUMBER info = WinDeviceManager::getDeviceInfo<STORAGE_DEVICE_NUMBER>(driveLetterFromUdi(m_device->udi()),IOCTL_STORAGE_GET_DEVICE_NUMBER);
+        m_major = info.DeviceNumber;
+        m_minor = info.PartitionNumber;
+    }
+    else if(m_device->type() == Solid::DeviceInterface::StorageDrive ||
+            m_device->type() == Solid::DeviceInterface::OpticalDrive ||
+            m_device->type() == Solid::DeviceInterface::OpticalDisc)
+    {
+        m_major = m_device->udi().mid(m_device->udi().length()-1).toInt();
+    }
+    else
+    {
+        qFatal("Not implemented device type %i",m_device->type());
+    }
+
+}
+
+WinBlock::~WinBlock()
+{
+}
+
+int WinBlock::deviceMajor() const
+{
+    Q_ASSERT(m_major != -1);
+    return m_major;
+}
+
+int WinBlock::deviceMinor() const
+{
+    return m_minor;
+}
+
+QString WinBlock::device() const
+{
+    return driveLetterFromUdi(m_device->udi());
+}
+
+QStringList WinBlock::drivesFromMask(const DWORD unitmask)
+{
+    QStringList result;
+    DWORD localUnitmask(unitmask);
+    for (int i = 0; i <= 25; ++i)
+    {
+        if (0x01 == (localUnitmask & 0x1))
+        {
+            result<<QString("%1:").arg((char)(i+'A'));
+        }
+        localUnitmask >>= 1;
+    }
+    return result;
+}
+
+QSet<QString> WinBlock::getUdis()
+{
+    return updateUdiFromBitMask(GetLogicalDrives());
+}
+
+QString WinBlock::driveLetterFromUdi(const QString &udi)
+{
+    if(!m_driveLetters.contains(udi))
+        qWarning()<<udi<<"is not connected to a drive";
+    return m_driveLetters[udi];
+}
+
+QString WinBlock::udiFromDriveLetter(const QString &drive)
+{
+    QString out;
+    for(QMap<QString,QString>::const_iterator it = m_driveLetters.begin();it != m_driveLetters.end();++it)
+    {
+        if(it.value() == drive)
+        {
+            out = it.key();
+            break;
+        }
+    }
+    return out;
+}
+
+QString WinBlock::resolveVirtualDrive(const QString &drive)
+{
+    return m_virtualDrives[drive];
+}
+
+QSet<QString> WinBlock::updateUdiFromBitMask(const DWORD unitmask)
+{
+    QStringList drives = drivesFromMask(unitmask);
+    QSet<QString> list;
+    wchar_t driveWCHAR[MAX_PATH];
+    wchar_t bufferOut[MAX_PATH];
+    QString dosPath;
+    foreach(const QString &drive,drives)
+    {
+        QSet<QString> udis;
+        driveWCHAR[drive.toWCharArray(driveWCHAR)] = 0;
+        if(GetDriveType(driveWCHAR) == DRIVE_REMOTE)//network drive
+        {
+            QSettings settings(QLatin1String("HKEY_CURRENT_USER\\Network\\") + drive.at(0),QSettings::NativeFormat);
+            QString path = settings.value("RemotePath").toString();
+            if(!path.isEmpty())
+            {
+                QString key = QLatin1String("/org/kde/solid/win/volume.virtual/") + drive.at(0);
+                m_virtualDrives[key] = path;
+                udis << key;
+            }
+
+        }
+        else
+        {
+            QueryDosDeviceW(driveWCHAR,bufferOut,MAX_PATH);
+            dosPath = QString::fromWCharArray(bufferOut);
+            if(dosPath.startsWith("\\??\\"))//subst junction
+            {
+                dosPath = dosPath.mid(4);
+                QString key = QLatin1String("/org/kde/solid/win/volume.virtual/") + drive.at(0);
+                m_virtualDrives[key] = dosPath;
+                udis << key;
+            }
+            else
+            {
+                STORAGE_DEVICE_NUMBER info = WinDeviceManager::getDeviceInfo<STORAGE_DEVICE_NUMBER>(drive,IOCTL_STORAGE_GET_DEVICE_NUMBER);
+
+                switch(info.DeviceType)
+                {
+                case FILE_DEVICE_DISK:
+                {
+                    udis << QString("/org/kde/solid/win/volume/disk#%1,partition#%2").arg(info.DeviceNumber).arg(info.PartitionNumber);
+                    udis << QString("/org/kde/solid/win/storage/disk#%1").arg(info.DeviceNumber);
+
+                }
+                    break;
+                case FILE_DEVICE_CD_ROM:
+                case FILE_DEVICE_DVD:
+                {
+                    udis << QString("/org/kde/solid/win/storage.cdrom/disk#%1").arg(info.DeviceNumber);
+#ifdef HEAVE_DRIVER_KIT
+                    DISK_GEOMETRY_EX out = WinDeviceManager::getDeviceInfo<DISK_GEOMETRY_EX>(drive,IOCTL_DISK_GET_DRIVE_GEOMETRY_EX);
+                    if(out.DiskSize.QuadPart != 0)
+                    {
+                        udis << QString("/org/kde/solid/win/volume.cdrom/disk#%1").arg(info.DeviceNumber);
+                    }
+#else
+                    udis << QString("/org/kde/solid/win/volume.cdrom/disk#%1").arg(info.DeviceNumber);
+#endif
+                }
+                    break;
+                default:
+                    qDebug() << "unknown device" << drive << info.DeviceType << info.DeviceNumber << info.PartitionNumber;
+                }
+            }
+        }
+        m_driveUDIS[drive] = udis;
+        foreach(const QString&s,udis)
+        {
+            m_driveLetters[s] = drive;
+        }
+        list += udis;
+    }
+    return list;
+}
+
+QSet<QString> WinBlock::getFromBitMask(const DWORD unitmask)
+{
+    QSet<QString> list;
+    QStringList drives = drivesFromMask(unitmask);
+    foreach(const QString &drive,drives)
+    {
+        if(m_driveUDIS.contains(drive))
+        {
+            list += m_driveUDIS[drive];
+        }
+        else
+        {
+            //we have to update the cache
+            return updateUdiFromBitMask(unitmask);
+        }
+
+    }
+    return list;
+}
+
+#include "winblock.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winblock.h kdelibs-4.10.2/solid/solid/backends/win/winblock.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winblock.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winblock.h	2013-06-01 14:28:10.288882100 +0200
@@ -0,0 +1,70 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef WINBLOCK_H
+#define WINBLOCK_H
+
+#include <solid/ifaces/block.h>
+#include "wininterface.h"
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+
+class WinBlock : public WinInterface, virtual public Solid::Ifaces::Block
+{
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::Block)
+public:
+    WinBlock(WinDevice *device);
+    ~WinBlock();
+
+    virtual int deviceMajor() const;
+
+    virtual int deviceMinor() const;
+
+    virtual QString device() const;
+
+    static QSet<QString> getUdis();
+
+    static QString driveLetterFromUdi(const QString &udi);
+    static QString udiFromDriveLetter(const QString &drive);
+    static QString resolveVirtualDrive(const QString &drive);
+    static QSet<QString> updateUdiFromBitMask(const DWORD unitmask);
+    static QSet<QString> getFromBitMask(const DWORD unitmask);
+private:
+    static QMap<QString,QString> m_driveLetters;
+    static QMap<QString,QSet<QString> > m_driveUDIS;
+    static QMap<QString,QString> m_virtualDrives;
+
+    int m_major;
+    int m_minor;
+
+    static QStringList drivesFromMask(const DWORD unitmask);
+};
+
+}
+}
+}
+
+#endif // WINBLOCK_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/windevice.cpp kdelibs-4.10.2/solid/solid/backends/win/windevice.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/windevice.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/windevice.cpp	2013-06-01 14:28:10.292882300 +0200
@@ -0,0 +1,433 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "windevice.h"
+#include <solid/deviceinterface.h>
+
+#include "wingenericinterface.h"
+#include "winstoragevolume.h"
+#include "winblock.h"
+#include "winstorageaccess.h"
+#include "winstoragedrive.h"
+#include "winopticaldrive.h"
+#include "winopticaldisc.h"
+#include "windevice.h"
+#include "winprocessor.h"
+#include "winbattery.h"
+#include "winacadapter.h"
+
+#include <batclass.h>
+
+#if defined(__MINGW32__) && !defined(IOCTL_STORAGE_QUERY_PROPERTY)
+#include <winioctl_backport.h>
+#endif
+
+using namespace Solid::Backends::Win;
+
+WinDevice::WinDevice(const QString &udi) :
+    Device(),
+    m_udi(udi),
+    m_type(Solid::DeviceInterface::Unknown)
+{
+    /*
+     /org/kde/solid/win/volume/disk #%1, partition #%2
+     /org/kde/solid/win/storage.cdrom/disk #%0
+    */
+    QStringList data = udi.split("/");
+    QString parentName = data[6].split(",")[0].trimmed();
+    QString type = data[5];
+
+    if(type == "storage")
+        m_type = Solid::DeviceInterface::StorageDrive;
+    else if(type == "volume")
+        m_type = Solid::DeviceInterface::StorageVolume;
+    else if (type == "storage.cdrom")
+        m_type = Solid::DeviceInterface::OpticalDrive;
+    else if (type == "volume.cdrom")
+        m_type = Solid::DeviceInterface::OpticalDisc;
+    else if (type == "cpu")
+        m_type = Solid::DeviceInterface::Processor;
+    else if (type == "power.battery")
+        m_type = Solid::DeviceInterface::Battery;
+    else if(type == "power")
+        m_type = Solid::DeviceInterface::AcAdapter;
+    else if(type == "volume.virtual")
+    {
+        m_type = Solid::DeviceInterface::StorageAccess;
+    }
+
+
+
+    switch(m_type)
+    {
+    case Solid::DeviceInterface::StorageVolume:
+    {
+        m_parentUdi = QLatin1String("/org/kde/solid/win/storage/") + parentName;
+    }
+        break;
+    case Solid::DeviceInterface::OpticalDisc:
+    {
+        m_parentUdi = QLatin1String("/org/kde/solid/win/storage.cdrom/") + parentName;
+    }
+        break;
+    case Solid::DeviceInterface::StorageAccess:
+    {
+        m_parentUdi = WinBlock::udiFromDriveLetter( WinBlock::resolveVirtualDrive(udi).mid(0,2));
+        if(m_parentUdi.isEmpty())
+        {
+            m_parentUdi = QLatin1String("/org/kde/solid/win/")+ type;
+        }
+    }
+        break;
+    default:
+        m_parentUdi = QLatin1String("/org/kde/solid/win/")+ type;
+    }
+
+
+
+    switch(m_type)
+    {
+    case Solid::DeviceInterface::Processor:
+        initCpuDevice();
+        break;
+    case Solid::DeviceInterface::Battery:
+        initBatteryDevice();
+        break;
+    case Solid::DeviceInterface::AcAdapter:
+        m_description = QObject::tr("A/C Adapter");
+        break;
+    default:
+        if(queryDeviceInterface(Solid::DeviceInterface::StorageAccess) || queryDeviceInterface(Solid::DeviceInterface::StorageDrive))
+        {
+            initStorageDevice();
+        }
+        else
+        {
+            qWarning()<<"Unknown device"<<udi;
+        }
+    }
+
+
+}
+
+void WinDevice::initStorageDevice()
+{
+    QString dev;
+    switch(m_type)
+    {
+    case Solid::DeviceInterface::StorageAccess:
+        dev = WinBlock::driveLetterFromUdi(udi());
+        m_product = QString("Virtual drive %1").arg(dev);
+        m_description = QString("%1 (%2)").arg(dev, WinBlock::resolveVirtualDrive(udi()));
+        return;
+    case  Solid::DeviceInterface::OpticalDrive:
+        dev = WinBlock::driveLetterFromUdi(udi());
+        break;
+    case Solid::DeviceInterface::StorageDrive:
+        dev = QString("PhysicalDrive%1").arg(WinBlock(this).deviceMajor());
+        break;
+    default:
+        dev = WinBlock::driveLetterFromUdi(udi());
+        m_description = QString("%1 (%2)").arg(dev, WinStorageVolume(this).label());
+    }
+
+    STORAGE_PROPERTY_QUERY query;
+    ZeroMemory(&query,sizeof(STORAGE_PROPERTY_QUERY));
+    query.PropertyId = StorageDeviceProperty;
+    query.QueryType =  PropertyStandardQuery;
+
+    char buff[1024];
+    WinDeviceManager::getDeviceInfo<char,STORAGE_PROPERTY_QUERY>(dev,IOCTL_STORAGE_QUERY_PROPERTY,buff,1024,&query);
+    STORAGE_DEVICE_DESCRIPTOR *info = ((STORAGE_DEVICE_DESCRIPTOR*)buff);
+    if(info->VendorIdOffset != 0)
+    {
+        m_vendor = QString((char*)buff+ info->VendorIdOffset).trimmed();
+        if(info->ProductIdOffset != 0)
+        {
+            m_product = QString((char*)buff+ info->ProductIdOffset).trimmed();
+        }
+    }
+    else if(info->ProductIdOffset != 0)//fallback doesnt work for all devices
+    {
+        QStringList tmp = QString((char*)buff+ info->ProductIdOffset).trimmed().split(" ");
+        m_vendor = tmp.takeFirst();
+        m_product = tmp.join(" ");
+    }
+}
+
+void WinDevice::initBatteryDevice()
+{
+    WinBattery::Battery battery = WinBattery::batteryInfoFromUdi(m_udi);
+    BATTERY_QUERY_INFORMATION query;
+    ZeroMemory(&query,sizeof(query));
+    query.BatteryTag = battery.second;
+
+
+    size_t size = 1024;
+    wchar_t buff[1024];
+
+    query.InformationLevel = BatteryDeviceName;
+    WinDeviceManager::getDeviceInfo<wchar_t,BATTERY_QUERY_INFORMATION>(battery.first,IOCTL_BATTERY_QUERY_INFORMATION,buff,size,&query);
+    m_product = QString::fromWCharArray(buff);
+
+    query.InformationLevel = BatteryManufactureName;
+    WinDeviceManager::getDeviceInfo<wchar_t,BATTERY_QUERY_INFORMATION>(battery.first,IOCTL_BATTERY_QUERY_INFORMATION,buff,size,&query);
+    m_vendor = QString::fromWCharArray(buff);
+
+    query.InformationLevel = BatteryInformation;
+    BATTERY_INFORMATION info = WinDeviceManager::getDeviceInfo<BATTERY_INFORMATION,BATTERY_QUERY_INFORMATION>(battery.first,IOCTL_BATTERY_QUERY_INFORMATION,&query);
+
+    if(info.Chemistry != 0)
+    {
+        QString tech = QString::fromUtf8((const char*)info.Chemistry,4);
+
+        m_description = QObject::tr("%1 Battery", "%1 is battery technology").arg(batteryTechnology(tech.toUpper()));
+    }
+}
+
+void WinDevice::initCpuDevice()
+{
+    WinProcessor cpu(this);
+    WinProcessor::ProcessorInfo info = WinProcessor::updateCache()[cpu.number()];
+    m_vendor = info.vendor;
+    m_product = info.produuct;
+    m_description = info.name;
+}
+
+QString WinDevice::udi() const
+{
+    return m_udi;
+}
+
+QString WinDevice::parentUdi() const
+{
+    return m_parentUdi;
+}
+
+QString WinDevice::vendor() const
+{
+    return m_vendor;
+}
+
+QString WinDevice::product() const
+{
+    return m_product;
+}
+
+QString WinDevice::description() const
+{
+    return m_description.isEmpty()?m_product:m_description;
+}
+
+QString WinDevice::icon() const
+{
+    if (parentUdi().isEmpty()) {
+        return QLatin1String("computer");
+    }
+
+    QString icon;
+    switch(type()){
+    case Solid::DeviceInterface::OpticalDrive:
+        icon =  QLatin1String("drive-optical");
+        break;
+    case Solid::DeviceInterface::OpticalDisc:
+    {
+        WinOpticalDisc disk(const_cast<WinDevice*>(this));
+        if(disk.availableContent() & Solid::OpticalDisc::Audio)
+        {
+            icon =  QLatin1String("media-optical-audio");
+        }
+        else
+        {
+            icon =  QLatin1String("drive-optical");
+        }
+        break;
+    }
+    case Solid::DeviceInterface::StorageDrive:
+    case Solid::DeviceInterface::StorageVolume:
+    {
+        WinStorageDrive storage(const_cast<WinDevice*>(this));
+        if(storage.bus() == Solid::StorageDrive::Usb)
+            icon =  QLatin1String("drive-removable-media-usb-pendrive");
+        else
+            icon =  QLatin1String("drive-harddisk");
+    }
+        break;
+    case Solid::DeviceInterface::Processor:
+        icon = QLatin1String("cpu");
+        break;
+    case Solid::DeviceInterface::Battery:
+        icon = QLatin1String("battery");
+        break;
+    case Solid::DeviceInterface::AcAdapter:
+        icon = QLatin1String("preferences-system-power-management");
+        break;
+    case Solid::DeviceInterface::StorageAccess:
+        icon = QLatin1String("drive-harddisk");
+        break;
+    default:
+        break;
+    }
+    return icon;
+}
+
+QStringList WinDevice::emblems() const
+{
+    QStringList icons;
+    switch(type()){
+    case Solid::DeviceInterface::StorageAccess:
+        icons << QLatin1String("emblem-symbolic-link");
+        break;
+    default:
+        break;
+    }
+    return icons;
+}
+
+bool WinDevice::queryDeviceInterface(const Solid::DeviceInterface::Type &queryType) const
+{
+    if (queryType == Solid::DeviceInterface::GenericInterface) {
+        return true;
+    }
+
+    QList<Solid::DeviceInterface::Type> interfaceList;
+    interfaceList << type();
+
+    switch (type())
+    {
+    case Solid::DeviceInterface::GenericInterface:
+        break;
+    case Solid::DeviceInterface::Block:
+        break;
+    case Solid::DeviceInterface::StorageAccess:
+        break;
+    case Solid::DeviceInterface::StorageDrive:
+        break;
+    case Solid::DeviceInterface::OpticalDrive:
+        interfaceList << Solid::DeviceInterface::Block << Solid::DeviceInterface::StorageDrive;
+        break;
+    case Solid::DeviceInterface::StorageVolume:
+        interfaceList << Solid::DeviceInterface::Block << Solid::DeviceInterface::StorageAccess;
+        break;
+    case Solid::DeviceInterface::OpticalDisc:
+        interfaceList << Solid::DeviceInterface::Block << Solid::DeviceInterface::StorageVolume << Solid::DeviceInterface::StorageAccess;
+        break;
+    case Solid::DeviceInterface::PortableMediaPlayer:
+        break;
+    case Solid::DeviceInterface::Unknown:
+    case Solid::DeviceInterface::Last:
+    default:
+        break;
+    }
+
+    if (interfaceList.size() == 0)
+        qWarning() << "no interface found for type" << type();
+    return interfaceList.contains(queryType);
+}
+
+QObject *WinDevice::createDeviceInterface(const Solid::DeviceInterface::Type &type)
+{
+    if (!queryDeviceInterface(type)) {
+        return 0;
+    }
+    WinInterface *iface = 0;
+
+    switch (type)
+    {
+    case Solid::DeviceInterface::GenericInterface:
+        iface = new WinGenericInterface(this);
+        break;
+    case Solid::DeviceInterface::Block:
+        iface = new WinBlock(this);
+        break;
+    case Solid::DeviceInterface::Processor:
+        iface = new WinProcessor(this);
+        break;
+    case Solid::DeviceInterface::StorageAccess:
+        iface = new WinStorageAccess(this);
+        break;
+    case Solid::DeviceInterface::StorageDrive:
+        iface = new WinStorageDrive(this);
+        break;
+    case Solid::DeviceInterface::OpticalDrive:
+        iface = new WinOpticalDrive(this);
+        break;
+    case Solid::DeviceInterface::StorageVolume:
+        iface = new WinStorageVolume(this);
+        break;
+    case Solid::DeviceInterface::OpticalDisc:
+        iface = new WinOpticalDisc(this);
+        break;
+        //      case Solid::DeviceInterface::PortableMediaPlayer:
+        //          iface = new PortableMediaPlayer(this);
+        //          break;
+    case Solid::DeviceInterface::Battery:
+        iface = new WinBattery(this);
+        break;
+    case Solid::DeviceInterface::AcAdapter:
+        iface = new WinAcadapter(this);
+        break;
+    case Solid::DeviceInterface::Unknown:
+    case Solid::DeviceInterface::Last:
+        break;
+    default:
+        break;
+    }
+
+    return iface;
+}
+
+Solid::DeviceInterface::Type WinDevice::type() const
+{
+    return m_type;
+}
+
+QString WinDevice::batteryTechnology(QString tec) const
+{
+    //based on upowerdevice.cpp
+    if(tec == "LION" || tec == "LI-I")
+    {
+        return QObject::tr("Lithium Ion", "battery technology");
+    }
+    else if(tec == "PBAC")
+    {
+        return QObject::tr("Lead Acid", "battery technology");
+    }
+    else if(tec == "NICD")
+    {
+        return QObject::tr("Nickel Cadmium", "battery technology");
+    }
+    else if(tec == "NIMH")
+    {
+        return QObject::tr("Nickel Metal Hydride", "battery technology");
+    }
+    else if(tec == "NIZN")
+    {
+        return QObject::tr("Nickel  Zinc", "battery technology");
+    }
+    else
+    {
+        qDebug()<<tec<< QObject::tr("Unknown", "battery technology");
+        return QObject::tr("Unknown", "battery technology");
+    }
+}
+
+
+#include "windevice.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/windevice.h kdelibs-4.10.2/solid/solid/backends/win/windevice.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/windevice.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/windevice.h	2013-06-01 14:28:10.295882500 +0200
@@ -0,0 +1,78 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef WINDEVICE_H
+#define WINDEVICE_H
+
+#include <solid/ifaces/device.h>
+#include "windevicemanager.h"
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+
+class WinDevice : public Solid::Ifaces::Device
+{
+    Q_OBJECT
+public:
+    WinDevice(const QString &udi);
+
+   virtual QString udi() const;
+
+   virtual QString parentUdi() const;
+   virtual QString vendor() const;
+   virtual QString product() const;
+
+   virtual QString icon() const;
+
+   virtual QStringList emblems() const;
+
+   virtual QString description() const;
+
+   virtual bool queryDeviceInterface(const Solid::DeviceInterface::Type &type) const;
+   virtual QObject *createDeviceInterface(const Solid::DeviceInterface::Type &type);
+
+    Solid::DeviceInterface::Type type() const;
+
+private:
+    QString m_udi;
+    QString m_parentUdi;
+    QString m_vendor;
+    QString m_product;
+    QString m_description;
+    Solid::DeviceInterface::Type m_type;
+
+    void initStorageDevice();
+    void initBatteryDevice();
+    void initCpuDevice();
+    QString batteryTechnology(QString tech) const;
+
+
+
+};
+
+}
+}
+}
+
+#endif // WINDEVICE_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/windevicemanager.cpp kdelibs-4.10.2/solid/solid/backends/win/windevicemanager.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/windevicemanager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/windevicemanager.cpp	2013-06-01 14:28:10.732907500 +0200
@@ -0,0 +1,250 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <solid/deviceinterface.h>
+#include "windevicemanager.h"
+#include "windevice.h"
+#include "winprocessor.h"
+#include "winblock.h"
+#include "winbattery.h"
+#include "winacadapter.h"
+
+#include <dbt.h>
+
+#include <QDebug>
+#include <QTimer>
+#include <QTime>
+#include <QApplication>
+
+
+using namespace Solid::Backends::Win;
+
+WinDeviceManager *WinDeviceManager::m_instance = NULL;
+
+WinDeviceManager::WinDeviceManager(QObject *parent)
+    :DeviceManager(parent)
+{
+    if(m_instance)
+        qFatal("There are multiple WinDeviceManager instances");
+    m_instance = this;
+    m_supportedInterfaces << Solid::DeviceInterface::GenericInterface
+                             //                          << Solid::DeviceInterface::Block
+                          << Solid::DeviceInterface::StorageAccess
+                          << Solid::DeviceInterface::StorageDrive
+                          << Solid::DeviceInterface::OpticalDrive
+                          << Solid::DeviceInterface::StorageVolume
+                          << Solid::DeviceInterface::OpticalDisc
+                          << Solid::DeviceInterface::Processor
+                          << Solid::DeviceInterface::Battery
+                          << Solid::DeviceInterface::AcAdapter;
+
+
+    updateDeviceList();
+
+    wchar_t title[] = L"KDEWinDeviceManager";
+
+    WNDCLASSEX wcex;
+    ZeroMemory(&wcex, sizeof(wcex));
+    wcex.cbSize = sizeof(WNDCLASSEX);
+    wcex.lpfnWndProc	= WinDeviceManager::WndProc;
+    wcex.hInstance		= (HINSTANCE)::GetModuleHandle(NULL);
+    wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW);
+    wcex.lpszClassName	= title;
+    if(RegisterClassEx(&wcex) ==0)
+    {
+        qWarning() << "Failed to initialize KDEWinDeviceManager we will be unable to detect device changes";
+        return;
+    }
+
+    m_windowID = CreateWindow(title, title, WS_ICONIC, 0, 0,
+                              CW_USEDEFAULT, 0, NULL, NULL, wcex.hInstance, NULL);
+    if(m_windowID == NULL)
+    {
+        qWarning() << "Failed to initialize KDEWinDeviceManager we will be unable to detect device changes";
+        return;
+    }
+    ShowWindow(m_windowID, SW_HIDE);
+}
+
+WinDeviceManager::~WinDeviceManager()
+{
+    PostMessage(m_windowID, WM_CLOSE, 0, 0);
+    m_instance = NULL;
+}
+
+QString WinDeviceManager::udiPrefix() const
+{
+    return QString();
+}
+
+
+QSet<Solid::DeviceInterface::Type> Solid::Backends::Win::WinDeviceManager::supportedInterfaces() const
+{
+    return m_supportedInterfaces;
+}
+
+QStringList WinDeviceManager::allDevices()
+{
+    return m_devicesList;
+}
+
+
+QStringList WinDeviceManager::devicesFromQuery(const QString &parentUdi, Solid::DeviceInterface::Type type)
+{
+
+    QStringList list;
+    if (!parentUdi.isEmpty())
+    {
+        foreach(const QString &udi,allDevices()){
+            WinDevice device(udi);
+            if(device.type() == type && device.parentUdi() == parentUdi ){
+                list << udi;
+            }
+        }
+    } else if (type!=Solid::DeviceInterface::Unknown) {
+        foreach(const QString &udi,allDevices()){
+            WinDevice device(udi);
+            if(device.queryDeviceInterface(type)){
+                list << udi;
+            }
+        }
+    } else {
+        list << allDevices();
+    }
+    return list;
+
+}
+
+
+QObject *Solid::Backends::Win::WinDeviceManager::createDevice(const QString &udi)
+{
+    if (allDevices().contains(udi)) {
+        return new WinDevice(udi);
+    } else {
+        return 0;
+    }
+}
+
+const WinDeviceManager *WinDeviceManager::instance()
+{
+    return m_instance;
+}
+
+void WinDeviceManager::updateDeviceList()
+{
+    QSet<QString> devices = WinProcessor::getUdis();
+    devices += WinBlock::getUdis();
+    devices += WinBattery::getUdis();
+    devices += WinAcadapter::getUdis();
+
+
+    m_devices = devices;
+    m_devicesList = m_devices.toList();
+    qSort(m_devicesList);
+}
+
+
+
+
+LRESULT WinDeviceManager::WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
+{
+    //some parts of the code are based on http://www.codeproject.com/Articles/119168/Hardware-Change-Detection
+    switch(message)
+    {
+    case WM_DEVICECHANGE:
+    {
+
+        if ((wParam == DBT_DEVICEARRIVAL) || (wParam == DBT_DEVICEREMOVECOMPLETE))
+        {
+            DEV_BROADCAST_HDR* header = reinterpret_cast<DEV_BROADCAST_HDR*>(lParam);
+            if (header->dbch_devicetype == DBT_DEVTYP_VOLUME)
+            {
+
+                DEV_BROADCAST_VOLUME* devNot = reinterpret_cast<DEV_BROADCAST_VOLUME*>(lParam);
+                switch(wParam)
+                {
+
+                case DBT_DEVICEREMOVECOMPLETE:
+                {
+                    QSet<QString> udis = WinBlock::getFromBitMask(devNot->dbcv_unitmask);
+                    m_instance->promoteRemovedDevice(udis);
+                }
+                    break;
+                case DBT_DEVICEARRIVAL:
+                {
+                    QSet<QString> udis = WinBlock::updateUdiFromBitMask(devNot->dbcv_unitmask);
+                    m_instance->promoteAddedDevice(udis);
+                }
+                    break;
+                }
+                break;
+            }
+        }
+    }
+        break;
+    case WM_POWERBROADCAST:
+    {
+
+    }
+    break;
+    case WM_DESTROY:
+    {
+        PostQuitMessage(0);
+    }
+        break;
+    default:
+        return DefWindowProc(hWnd, message, wParam, lParam);
+    }
+    return 0;
+}
+
+void WinDeviceManager::promoteAddedDevice(const QSet<QString> &udi)
+{
+    QSet<QString> tmp = udi - m_devices;//dont report devices that are already known(cd drive)
+    m_devices += tmp;
+    m_devicesList = m_devices.toList();
+    qSort(m_devicesList);
+    foreach(const QString &s,tmp)
+    {
+
+        emit deviceAdded(s);
+    }
+}
+
+void WinDeviceManager::promoteRemovedDevice(const QSet<QString> &udi)
+{
+    m_devices -= udi;
+    m_devicesList = m_devices.toList();
+    qSort(m_devicesList);
+    foreach(const QString &s,udi)
+    {
+        emit deviceRemoved(s);
+    }
+}
+
+void WinDeviceManager::promotePowerChange()
+{
+    emit powerChanged();
+}
+
+
+
+#include <windevicemanager.moc>
+
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/windevicemanager.h kdelibs-4.10.2/solid/solid/backends/win/windevicemanager.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/windevicemanager.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/windevicemanager.h	2013-06-01 14:28:10.736907700 +0200
@@ -0,0 +1,192 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef WINDEVICEMANAGER_H
+#define WINDEVICEMANAGER_H
+
+#include <solid/ifaces/devicemanager.h>
+#define HEAVE_DRIVER_KIT
+
+#include <QSet>
+#include <QDebug>
+
+#include <windows.h>
+#include <winioctl.h>
+
+inline QString qGetLastError(ulong errorNummber = GetLastError())
+{
+    LPVOID error = NULL;
+    size_t len = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
+                               FORMAT_MESSAGE_FROM_SYSTEM |
+                               FORMAT_MESSAGE_IGNORE_INSERTS,
+                               NULL,
+                               errorNummber,
+                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+                               (LPWSTR) &error ,
+                               0, NULL );
+    QString out = QString::fromWCharArray((wchar_t*)error,len).trimmed().append(" %1").arg(errorNummber);
+    LocalFree(error);
+    return out;
+}
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+
+class WinDeviceManager : public Solid::Ifaces::DeviceManager
+{
+    Q_OBJECT
+public:
+    WinDeviceManager(QObject *parent=0);
+    ~WinDeviceManager();
+
+    virtual QString udiPrefix() const;
+
+    virtual QSet<Solid::DeviceInterface::Type> supportedInterfaces() const;
+
+    virtual QStringList allDevices();
+
+    virtual QStringList devicesFromQuery(const QString &parentUdi,
+                                         Solid::DeviceInterface::Type type = Solid::DeviceInterface::Unknown);
+
+    virtual QObject *createDevice(const QString &udi);
+
+    static const WinDeviceManager *instance();
+
+    template< class INFO>
+    static INFO getDeviceInfo(const QString &devName, int code)
+    {
+        return getDeviceInfo<INFO,void*>(devName,code);
+    }
+
+
+    template< class INFO, class QUERY>
+    static INFO getDeviceInfo(const QString &devName, int code, QUERY *query = NULL)
+    {
+        INFO info;
+        ZeroMemory(&info,sizeof(INFO));
+        getDeviceInfoPrivate(devName,code,&info,sizeof(INFO),query);
+        return info;
+    }
+
+    template<class BUFFER_TYPE,class QUERY>
+    static void getDeviceInfo(const QString &devName, int code, BUFFER_TYPE *out, size_t outSize, QUERY *query = NULL)
+    {
+        ZeroMemory(out,sizeof(BUFFER_TYPE)*outSize);
+        getDeviceInfoPrivate(devName,code,out,outSize,query);
+    }
+
+    static void deviceAction(const QString &devName, int code)
+    {
+        getDeviceInfoPrivate<void,void*>(devName,code,NULL,0,NULL);
+    }
+
+signals:
+    void powerChanged();
+
+private slots:
+    void updateDeviceList();
+
+private:
+    static WinDeviceManager *m_instance;
+    HWND m_windowID;
+    QSet<QString> m_devices;
+    QStringList m_devicesList;
+    QSet<Solid::DeviceInterface::Type> m_supportedInterfaces;
+
+    static LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
+
+    void promoteAddedDevice(const QSet<QString> &udi);
+    void promoteRemovedDevice(const QSet<QString> &udi);
+
+    void promotePowerChange();
+
+    template< class INFO, class QUERY>
+    static void getDeviceInfoPrivate(const QString &devName, int code,INFO *info,size_t size, QUERY *query = NULL)
+    {
+        Q_ASSERT(!devName.isNull());
+        wchar_t deviceNameBuffer[MAX_PATH];
+        QString dev = devName;
+        if(!dev.startsWith("\\"))
+        {
+            dev = QLatin1String("\\\\?\\") + dev;
+        }
+        deviceNameBuffer[dev.toWCharArray(deviceNameBuffer)] = 0;
+        DWORD bytesReturned =  0;
+
+        ulong err = NO_ERROR;
+        HANDLE handle = ::CreateFileW(deviceNameBuffer, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL  , OPEN_EXISTING , 0, NULL);
+        if(handle == INVALID_HANDLE_VALUE)
+        {
+
+            err = GetLastError();
+            if(err == ERROR_ACCESS_DENIED)
+            {
+                //we would need admin rights for GENERIC_READ on systenm drives and volumes
+                handle = ::CreateFileW(deviceNameBuffer, 0, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL  , OPEN_EXISTING , 0, NULL);
+                err = GetLastError();
+            }
+            if(handle == INVALID_HANDLE_VALUE)
+            {
+                qWarning() << "Invalid Handle" << dev << "reason:" << qGetLastError(err) << " this should not happen.";
+                return;
+            }
+
+        }
+        if(::DeviceIoControl(handle, code, query, sizeof(QUERY), info, size, &bytesReturned, NULL))
+        {
+            ::CloseHandle(handle);
+            return;
+        }
+
+        if(handle == INVALID_HANDLE_VALUE)
+        {
+            qWarning() <<" Invalid Handle" << devName << "reason:" << qGetLastError() << " is probaply a subst path or more seriously there is  bug!";
+            return;
+        }
+
+        err = GetLastError();
+        if(err == ERROR_NOT_READY)
+        {
+            //the drive is a cd drive with no disk
+            ::CloseHandle(handle);
+            return;
+        }
+
+#if 0
+        ::CloseHandle(handle);
+        qFatal("Failed to query %s reason: %s", qPrintable(dev), qPrintable(qGetLastError(err)));
+#else
+        qWarning() << "Failed to query" << dev << "reason:" << qGetLastError(err);
+#endif
+
+
+        ::CloseHandle(handle);
+    }
+
+};
+
+}
+}
+}
+#endif // WINDEVICEMANAGER_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/wingenericinterface.cpp kdelibs-4.10.2/solid/solid/backends/win/wingenericinterface.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/wingenericinterface.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/wingenericinterface.cpp	2013-06-01 14:28:10.739907900 +0200
@@ -0,0 +1,52 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "wingenericinterface.h"
+
+using namespace Solid::Backends::Win;
+
+WinGenericInterface::WinGenericInterface(WinDevice *device)
+    :WinInterface(device)
+{
+}
+
+QVariant WinGenericInterface::property(const QString &key) const
+{
+    Q_UNUSED(key)
+    qFatal("Not implemented");
+    return QVariant();
+}
+
+
+
+QMap<QString, QVariant> Solid::Backends::Win::WinGenericInterface::allProperties() const
+{
+    qFatal("Not implemented");
+    return QMap<QString, QVariant>();
+}
+
+bool WinGenericInterface::propertyExists(const QString &key) const
+{
+    Q_UNUSED(key)
+    qFatal("Not implemented");
+    return true;
+}
+
+#include "wingenericinterface.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/wingenericinterface.h kdelibs-4.10.2/solid/solid/backends/win/wingenericinterface.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/wingenericinterface.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/wingenericinterface.h	2013-06-01 14:28:10.742908100 +0200
@@ -0,0 +1,55 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef WINGENERICINTERFACE_H
+#define WINGENERICINTERFACE_H
+
+#include <solid/ifaces/genericinterface.h>
+#include "wininterface.h"
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+
+
+class WinGenericInterface : public WinInterface,virtual public Solid::Ifaces::GenericInterface
+{
+    Q_OBJECT
+     Q_INTERFACES(Solid::Ifaces::GenericInterface)
+public:
+    WinGenericInterface(WinDevice *device);
+
+    virtual QVariant property(const QString &key) const;
+
+    virtual QMap<QString, QVariant> allProperties() const;
+
+    virtual bool propertyExists(const QString &key) const;
+
+signals:
+    void propertyChanged(const QMap<QString,int> &changes);
+    void conditionRaised(const QString &condition, const QString &reason);
+};
+}
+}
+}
+
+#endif // WINGENERICINTERFACE_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/wininterface.cpp kdelibs-4.10.2/solid/solid/backends/win/wininterface.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/wininterface.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/wininterface.cpp	2013-06-01 14:28:10.744908200 +0200
@@ -0,0 +1,42 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "wininterface.h"
+
+using namespace Solid::Backends::Win;
+
+
+WinInterface::WinInterface(WinDevice *device)
+    :QObject(device)
+    ,m_device(device)
+{
+}
+
+
+
+WinInterface::~WinInterface()
+{
+}
+
+
+
+#include "wininterface.moc"
+
+
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/wininterface.h kdelibs-4.10.2/solid/solid/backends/win/wininterface.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/wininterface.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/wininterface.h	2013-06-01 14:28:10.747908300 +0200
@@ -0,0 +1,53 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef WININTERFACE_H
+#define WININTERFACE_H
+
+#include <solid/ifaces/deviceinterface.h>
+
+#include "windevice.h"
+#include <QDebug>
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+class WinInterface : public QObject, virtual public Solid::Ifaces::DeviceInterface
+{
+Q_OBJECT
+Q_INTERFACES(Solid::Ifaces::DeviceInterface)
+
+public:
+    WinInterface(WinDevice *device);
+    virtual ~WinInterface();
+
+
+protected:
+    WinDevice *m_device;
+};
+
+}
+}
+}
+
+#endif // WININTERFACE_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winopticaldisc.cpp kdelibs-4.10.2/solid/solid/backends/win/winopticaldisc.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winopticaldisc.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winopticaldisc.cpp	2013-06-01 14:28:10.750908500 +0200
@@ -0,0 +1,122 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "winopticaldisc.h"
+#include "winopticaldrive.h"
+
+
+#ifdef HEAVE_DRIVER_KIT
+#include <ntddcdrm.h>
+#include <ntddmmc.h>
+#endif
+
+using namespace Solid::Backends::Win;
+
+WinOpticalDisc::WinOpticalDisc(WinDevice *device) :
+    WinStorageVolume(device),
+    m_discType(Solid::OpticalDisc::UnknownDiscType),
+    m_isRewritable(false)
+{
+    //TODO: blueray etc
+    #ifdef HEAVE_DRIVER_KIT
+    QMap<ulong,MediaProfiles> profiles = MediaProfiles::profiles(WinBlock::driveLetterFromUdi(m_device->udi()));
+
+    if(profiles[ProfileCdRecordable].active)
+    {
+        m_discType = Solid::OpticalDisc::CdRecordable;
+    }else if(profiles[ProfileCdRewritable].active)
+    {
+        m_discType = Solid::OpticalDisc::CdRewritable;
+        m_isRewritable =  true;
+    }
+    else if(profiles[ProfileCdrom].active)
+    {
+        m_discType = Solid::OpticalDisc::CdRom;
+    }
+    else if(profiles[ProfileDvdRecordable].active)
+    {
+        m_discType = Solid::OpticalDisc::DvdRecordable;
+    }
+    else if(profiles[ProfileDvdRewritable].active)
+    {
+        m_discType = Solid::OpticalDisc::DvdRewritable;
+        m_isRewritable = true;
+    }
+    else if(profiles[ProfileDvdRom].active)
+    {
+        m_discType = Solid::OpticalDisc::DvdRom;
+    }
+    else
+    {
+        m_discType = Solid::OpticalDisc::UnknownDiscType;
+    }
+#endif
+
+
+}
+
+WinOpticalDisc::~WinOpticalDisc()
+{
+}
+
+Solid::OpticalDisc::ContentTypes WinOpticalDisc::availableContent() const
+{
+    return Solid::OpticalDisc::NoContent;
+}
+
+Solid::OpticalDisc::DiscType WinOpticalDisc::discType() const
+{
+    return m_discType;
+}
+
+bool WinOpticalDisc::isAppendable() const
+{
+    return false;
+}
+
+bool WinOpticalDisc::isBlank() const
+{
+
+    wchar_t dLetter[MAX_PATH];
+    int dLetterSize = WinBlock::driveLetterFromUdi(m_device->udi()).toWCharArray(dLetter);
+    dLetter[dLetterSize] = (wchar_t)'\\';
+    dLetter[dLetterSize+1] = 0;
+
+    ULARGE_INTEGER sizeTotal;
+    ULARGE_INTEGER sizeFree;
+    if(GetDiskFreeSpaceEx(dLetter,&sizeFree,&sizeTotal,NULL))
+    {
+        return sizeFree.QuadPart>0 && sizeTotal.QuadPart == 0;
+    }
+    //FIXME: the call will fail on a blank cd, and inf there is no cd, but if we got a disc type we could guess that it is a blank cd
+    return m_discType != Solid::OpticalDisc::UnknownDiscType ;
+}
+
+bool WinOpticalDisc::isRewritable() const
+{
+    return m_isRewritable;
+}
+
+qulonglong WinOpticalDisc::capacity() const
+{
+    return size();
+}
+
+#include "winopticaldisc.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winopticaldisc.h kdelibs-4.10.2/solid/solid/backends/win/winopticaldisc.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winopticaldisc.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winopticaldisc.h	2013-06-01 14:28:10.753908700 +0200
@@ -0,0 +1,68 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifndef WINOPTICALDISC_H
+#define WINOPTICALDISC_H
+
+
+#include <solid/ifaces/opticaldisc.h>
+
+#include "winstoragevolume.h"
+
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+class WinOpticalDisc : public WinStorageVolume, virtual public Solid::Ifaces::OpticalDisc
+{
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::OpticalDisc)
+
+public:
+    WinOpticalDisc(WinDevice *device);
+    virtual ~WinOpticalDisc();
+
+
+    virtual Solid::OpticalDisc::ContentTypes availableContent() const;
+
+    virtual Solid::OpticalDisc::DiscType discType() const;
+
+    virtual bool isAppendable() const;
+
+    virtual bool isBlank() const;
+
+    virtual bool isRewritable() const;
+
+    virtual qulonglong capacity() const;
+
+private:
+    Solid::OpticalDisc::DiscType m_discType;
+    bool m_isRewritable;
+    bool m_isBlank;
+    bool m_isAppendable;
+
+};
+}
+}
+}
+
+#endif // WINOPTICALDISC_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winopticaldrive.cpp kdelibs-4.10.2/solid/solid/backends/win/winopticaldrive.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winopticaldrive.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winopticaldrive.cpp	2013-06-01 14:28:10.756908900 +0200
@@ -0,0 +1,177 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "winopticaldrive.h"
+
+#ifdef HEAVE_DRIVER_KIT
+#include <ntddcdrm.h>
+#include <ntddmmc.h>
+#endif
+
+
+using namespace Solid::Backends::Win;
+
+WinOpticalDrive::WinOpticalDrive(WinDevice *device) :
+    WinStorageDrive(device)
+{
+#ifdef HEAVE_DRIVER_KIT
+    QMap<ulong,MediaProfiles> profiles = MediaProfiles::profiles(WinBlock::driveLetterFromUdi(m_device->udi()));
+    foreach(const MediaProfiles p,profiles.values())
+    {
+        m_supportedTypes |= p.type;
+    }
+#else
+    m_supportedTypes = Solid::OpticalDrive::Cdr;
+#endif
+}
+
+WinOpticalDrive::~WinOpticalDrive()
+{
+}
+
+Solid::OpticalDrive::MediumTypes WinOpticalDrive::supportedMedia() const
+{
+    return m_supportedTypes;
+}
+
+
+bool WinOpticalDrive::eject()
+{
+    WinDeviceManager::deviceAction(WinBlock::driveLetterFromUdi(m_device->udi()),IOCTL_STORAGE_EJECT_MEDIA);
+    return true;
+}
+
+
+QList<int> WinOpticalDrive::writeSpeeds() const
+{
+    return QList<int>();
+}
+
+
+int WinOpticalDrive::writeSpeed() const
+{
+    return 0;
+}
+
+
+int WinOpticalDrive::readSpeed() const
+{
+    return 0;
+}
+
+
+#ifdef HEAVE_DRIVER_KIT
+MediaProfiles::MediaProfiles() :
+    profile(0),
+    type(0),
+    active(false)
+{
+}
+
+MediaProfiles::MediaProfiles(ulong profile, Solid::OpticalDrive::MediumTypes type, QString name):
+    profile(profile),
+    type(type),
+    name(name),
+    active(false)
+{
+}
+
+MediaProfiles::MediaProfiles(FEATURE_DATA_PROFILE_LIST_EX *feature) :
+    profile(0),
+    type(0),
+    active(false)
+{
+    ulong val =  (feature->ProfileNumber[0] << 8 | feature->ProfileNumber[1] << 0);
+    MediaProfiles p =  MediaProfiles::getProfile(val);
+    if(!p.isNull())
+    {
+        profile = p.profile;
+        type = p.type;
+        name = p.name;
+        active =  feature->Current;
+    }
+}
+
+bool MediaProfiles::isNull()
+{
+    return name.isNull();
+}
+
+QMap<ulong,MediaProfiles> MediaProfiles::profiles(const QString &drive)
+{
+
+    //thx to http://www.adras.com/Determine-optical-drive-type-and-capabilities.t6826-144-1.html
+
+    QMap<ulong,MediaProfiles> out;
+    size_t buffSize = 1024;
+    char buffer[1024];
+    GET_CONFIGURATION_IOCTL_INPUT input;
+    ZeroMemory(&input,sizeof(GET_CONFIGURATION_IOCTL_INPUT));
+    input.Feature = FeatureProfileList;
+    input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL;
+
+    WinDeviceManager::getDeviceInfo<char,GET_CONFIGURATION_IOCTL_INPUT>(drive,IOCTL_CDROM_GET_CONFIGURATION,buffer,buffSize,&input);
+
+    GET_CONFIGURATION_HEADER *info = (GET_CONFIGURATION_HEADER*)buffer;
+    FEATURE_DATA_PROFILE_LIST* profile = (FEATURE_DATA_PROFILE_LIST*)info->Data;
+    FEATURE_DATA_PROFILE_LIST_EX* feature = profile->Profiles;
+    for(int i = 0;i<profile->Header.AdditionalLength/4;++feature,++i)
+    {
+        MediaProfiles p = MediaProfiles(feature);
+        if(!p.isNull())
+        {
+            out.insert(p.profile,p);
+        }
+    }
+
+    return out;
+}
+
+const MediaProfiles MediaProfiles::getProfile(ulong val)
+{
+#define AddProfile(profile,type) profiles.insert(profile,MediaProfiles(profile,type,#profile))
+    static QMap<ulong,MediaProfiles> profiles;
+    if(profiles.isEmpty())
+    {
+        AddProfile(ProfileCdrom,0);
+        AddProfile(ProfileCdRecordable,Solid::OpticalDrive::Cdr);
+        AddProfile(ProfileCdRewritable,Solid::OpticalDrive::Cdrw);
+        AddProfile(ProfileDvdRom,Solid::OpticalDrive::Dvd);
+        AddProfile(ProfileDvdRecordable,Solid::OpticalDrive::Dvdr);
+        AddProfile(ProfileDvdRewritable,Solid::OpticalDrive::Dvdrw);
+        AddProfile(ProfileDvdRam,Solid::OpticalDrive::Dvdram);
+        AddProfile(ProfileDvdPlusR,Solid::OpticalDrive::Dvdplusr);
+        AddProfile(ProfileDvdPlusRW,Solid::OpticalDrive::Dvdplusrw);
+        AddProfile(ProfileDvdPlusRDualLayer,Solid::OpticalDrive::Dvdplusdl);
+        AddProfile(ProfileDvdPlusRWDualLayer,Solid::OpticalDrive::Dvdplusdlrw);
+        AddProfile(ProfileBDRom,Solid::OpticalDrive::Bd);
+        AddProfile(ProfileBDRRandomWritable,Solid::OpticalDrive::Bdr);
+        AddProfile(ProfileBDRSequentialWritable,Solid::OpticalDrive::Bdr);
+        AddProfile(ProfileBDRewritable,Solid::OpticalDrive::Bdre);
+        AddProfile(ProfileHDDVDRom,Solid::OpticalDrive::HdDvd);
+        AddProfile(ProfileHDDVDRecordable,Solid::OpticalDrive::HdDvdr);
+        AddProfile(ProfileHDDVDRewritable,Solid::OpticalDrive::HdDvdrw);
+    }
+    return profiles[val];
+}
+#endif
+
+
+#include "winopticaldrive.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winopticaldrive.h kdelibs-4.10.2/solid/solid/backends/win/winopticaldrive.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winopticaldrive.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winopticaldrive.h	2013-06-01 14:28:10.759909000 +0200
@@ -0,0 +1,90 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifndef WINOPTICALDRIVE_H
+#define WINOPTICALDRIVE_H
+
+#include <solid/ifaces/opticaldrive.h>
+
+#include "winstoragedrive.h"
+
+struct _FEATURE_DATA_PROFILE_LIST_EX;
+typedef _FEATURE_DATA_PROFILE_LIST_EX FEATURE_DATA_PROFILE_LIST_EX;
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+class WinOpticalDrive : public WinStorageDrive, virtual public Solid::Ifaces::OpticalDrive
+{
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::OpticalDrive)
+public:
+    WinOpticalDrive(WinDevice *device);
+    virtual ~WinOpticalDrive();
+
+    virtual Solid::OpticalDrive::MediumTypes supportedMedia() const;
+
+    virtual int readSpeed() const;
+
+    virtual int writeSpeed() const;
+
+    virtual QList<int> writeSpeeds() const;
+
+    virtual bool eject();
+
+signals:
+    void ejectPressed(const QString &udi);
+
+    void ejectDone(Solid::ErrorType error, QVariant errorData, const QString &udi);
+
+private:
+    Solid::OpticalDrive::MediumTypes m_supportedTypes;
+
+};
+
+#ifdef HEAVE_DRIVER_KIT
+class MediaProfiles//TODO: cleanup
+{
+public:
+    MediaProfiles();
+    ulong profile;
+    Solid::OpticalDrive::MediumTypes type;
+    QString name;
+    bool active;
+
+    static QMap<ulong, MediaProfiles> profiles(const QString &drive);
+
+private:
+
+    MediaProfiles(ulong profile,Solid::OpticalDrive::MediumTypes type,QString name = "");
+
+    MediaProfiles(FEATURE_DATA_PROFILE_LIST_EX* feature);
+    bool isNull();
+
+    static const MediaProfiles getProfile(ulong id);
+} ;
+#endif
+}
+}
+}
+
+#endif // WINOPTICALDRIVE_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winprocessor.cpp kdelibs-4.10.2/solid/solid/backends/win/winprocessor.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winprocessor.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winprocessor.cpp	2013-06-01 23:15:08.731155700 +0200
@@ -0,0 +1,146 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "winprocessor.h"
+
+#include <solid/backends/shared/cpufeatures.h>
+
+#include <QSettings>
+
+using namespace Solid::Backends::Win;
+
+typedef BOOL (WINAPI *GLPI_fn)(SYSTEM_LOGICAL_PROCESSOR_INFORMATION* Buffer, DWORD* ReturnLength);
+GLPI_fn pGetLogicalProcessorInformation = 0;
+
+WinProcessor::WinProcessor(WinDevice *device):
+    WinInterface(device)
+{
+    if(pGetLogicalProcessorInformation == 0) {
+        HMODULE hKernel32 = LoadLibraryA("kernel32.dll");
+        pGetLogicalProcessorInformation = (GLPI_fn)GetProcAddress(hKernel32, "GetLogicalProcessorInformation");
+    }
+    m_number = m_device->udi().mid(m_device->udi().length()-1).toInt();
+}
+
+WinProcessor::~WinProcessor()
+{
+}
+
+int WinProcessor::number() const
+{
+    return m_number;
+}
+
+int WinProcessor::maxSpeed() const
+{
+    return updateCache()[m_number].speed;
+}
+
+bool WinProcessor::canChangeFrequency() const
+{
+    //TODO:implement
+    return false;
+}
+
+Solid::Processor::InstructionSets WinProcessor::instructionSets() const
+{
+    static Solid::Processor::InstructionSets set = Solid::Backends::Shared::cpuFeatures();
+    return set;
+}
+
+QSet<QString> WinProcessor::getUdis()
+{
+    static QSet<QString> out;
+    if(out.isEmpty())
+    {
+        foreach(const ProcessorInfo &info,updateCache())
+        {
+            out << QString("/org/kde/solid/win/cpu/device#%1,cpu#%2").arg(info.id).arg(info.lgicalId);
+        }
+    }
+    return out;
+}
+
+
+DWORD WinProcessor::countSetBits(ULONG_PTR bitMask)
+{
+    DWORD LSHIFT = sizeof(ULONG_PTR)*8 - 1;
+    DWORD bitSetCount = 0;
+    ULONG_PTR bitTest = (ULONG_PTR)1 << LSHIFT;
+    DWORD i;
+
+    for (i = 0; i <= LSHIFT; ++i)
+    {
+        bitSetCount += ((bitMask & bitTest)?1:0);
+        bitTest/=2;
+    }
+
+    return bitSetCount;
+}
+
+
+
+const QMap<int,WinProcessor::ProcessorInfo> &WinProcessor::updateCache()
+{
+    static QMap<int,ProcessorInfo> p;
+    if(p.isEmpty())
+    {
+        DWORD size = 0;
+        pGetLogicalProcessorInformation(NULL,&size);
+        char *buff = new char[size];
+        SYSTEM_LOGICAL_PROCESSOR_INFORMATION *info = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION*)buff;
+        pGetLogicalProcessorInformation(info,&size);
+        size /= sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
+
+
+        uint processorCoreCount = 0;
+        uint logicalProcessorCount = 0;
+
+        for(uint i=0;i< size;++i)
+        {
+            if (info[i].Relationship == RelationProcessorCore)
+            {
+                // A hyperthreaded core supplies more than one logical processor.
+                uint old = logicalProcessorCount;
+                logicalProcessorCount += countSetBits(info[i].ProcessorMask);
+                for(;old<logicalProcessorCount;++old)
+                {
+                    QSettings settings(QLatin1String("HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\") + QString::number(old),  QSettings::NativeFormat);
+                    ProcessorInfo proc;
+                    proc.id = processorCoreCount;
+                    proc.lgicalId = old;
+                    proc.speed = settings.value("~MHz").toInt();
+                    proc.vendor = settings.value("VendorIdentifier").toString().trimmed();
+                    proc.name = settings.value("ProcessorNameString").toString().trimmed();
+                    proc.produuct = settings.value("Identifier").toString().trimmed();
+
+                    p[old] = proc;
+                }
+                processorCoreCount++;
+            }
+
+        }
+        delete [] buff;
+    }
+    return p;
+
+}
+
+#include "winprocessor.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winprocessor.h kdelibs-4.10.2/solid/solid/backends/win/winprocessor.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winprocessor.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winprocessor.h	2013-06-01 14:28:10.774909900 +0200
@@ -0,0 +1,76 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifndef WINPROCESSOR_H
+#define WINPROCESSOR_H
+
+#include <solid/ifaces/processor.h>
+
+#include "wininterface.h"
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+
+class WinProcessor :public WinInterface, public Solid::Ifaces::Processor
+{
+    friend class WinDevice;
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::Processor)
+public:
+    WinProcessor(WinDevice *device);
+    ~WinProcessor();
+
+    virtual int number() const;
+
+    virtual int maxSpeed() const;
+
+    virtual bool canChangeFrequency() const;
+
+    virtual Solid::Processor::InstructionSets instructionSets() const;
+
+    static QSet<QString> getUdis();
+
+
+
+private:
+    int m_number;
+
+    class ProcessorInfo
+    {
+    public:
+        int lgicalId;
+        int id;
+        int speed;
+        QString vendor;
+        QString name;
+        QString produuct;
+
+    };
+
+    static DWORD countSetBits(ULONG_PTR bitMask);
+    static const QMap<int, WinProcessor::ProcessorInfo> &updateCache();
+};
+}
+}
+}
+
+#endif // WINPROCESSOR_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winstorageaccess.cpp kdelibs-4.10.2/solid/solid/backends/win/winstorageaccess.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winstorageaccess.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winstorageaccess.cpp	2013-06-01 14:28:10.778910100 +0200
@@ -0,0 +1,69 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "winstorageaccess.h"
+#include "winblock.h"
+#include "winstoragedrive.h"
+
+
+using namespace Solid::Backends::Win;
+
+WinStorageAccess::WinStorageAccess(WinDevice *device) :
+    WinInterface(device)
+{
+}
+
+WinStorageAccess::~WinStorageAccess()
+{
+}
+
+bool WinStorageAccess::isAccessible() const
+{
+    return true;
+}
+
+QString WinStorageAccess::filePath() const
+{
+    return WinBlock::driveLetterFromUdi(m_device->udi()).append("/");
+}
+
+bool WinStorageAccess::isIgnored() const
+{
+    return false;
+}
+
+bool WinStorageAccess::setup()
+{
+    return true;
+}
+
+bool WinStorageAccess::teardown()
+{
+    //only allow eject if we are an usb stick
+    //else we get "The request could not be performed because of an I/O device error. 1117"
+    if(m_device->queryDeviceInterface(Solid::DeviceInterface::StorageVolume) && WinStorageDrive(m_device).driveType() == Solid::StorageDrive::MemoryStick)
+    {
+        WinDeviceManager::deviceAction(WinBlock::driveLetterFromUdi(m_device->udi()),IOCTL_STORAGE_EJECT_MEDIA);
+    }
+    return true;
+}
+
+
+#include "winstorageaccess.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winstorageaccess.h kdelibs-4.10.2/solid/solid/backends/win/winstorageaccess.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winstorageaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winstorageaccess.h	2013-06-01 14:28:10.780910200 +0200
@@ -0,0 +1,70 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef WINSTORAGEACCESS_H
+#define WINSTORAGEACCESS_H
+
+#include <solid/ifaces/storageaccess.h>
+
+#include "windevice.h"
+#include "wininterface.h"
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+class WinStorageAccess : public WinInterface,  public virtual Solid::Ifaces::StorageAccess
+{
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::StorageAccess)
+public:
+    WinStorageAccess(WinDevice *device);
+    ~WinStorageAccess();
+
+    virtual bool isAccessible() const;
+
+
+    virtual QString filePath() const;
+
+    virtual bool isIgnored() const;
+
+    virtual bool setup();
+
+    virtual bool teardown();
+
+signals:
+    void accessibilityChanged(bool accessible, const QString &udi);
+
+    void setupDone(Solid::ErrorType error, QVariant resultData, const QString &udi);
+
+    void teardownDone(Solid::ErrorType error, QVariant resultData, const QString &udi);
+
+    void setupRequested(const QString &udi);
+
+    void teardownRequested(const QString &udi);
+};
+}
+}
+}
+
+
+#endif // WINSTORAGEACCESS_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winstoragedrive.cpp kdelibs-4.10.2/solid/solid/backends/win/winstoragedrive.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winstoragedrive.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winstoragedrive.cpp	2013-06-01 14:28:10.783910400 +0200
@@ -0,0 +1,114 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "winstoragedrive.h"
+
+#include <windows.h>
+#include <winioctl.h>
+
+#if defined(__MINGW32__) && !defined(IOCTL_STORAGE_QUERY_PROPERTY)
+#include <winioctl_backport.h>
+#endif
+
+using namespace Solid::Backends::Win;
+
+WinStorageDrive::WinStorageDrive(WinDevice *device):
+    WinBlock(device)
+{
+    updateCache();
+}
+
+WinStorageDrive::~WinStorageDrive()
+{
+}
+
+Solid::StorageDrive::Bus WinStorageDrive::bus() const
+{
+    return m_bus;
+}
+
+Solid::StorageDrive::DriveType WinStorageDrive::driveType() const
+{
+    if(m_device->type() == Solid::DeviceInterface::OpticalDrive)
+        return Solid::StorageDrive::CdromDrive;
+    if(bus() == Solid::StorageDrive::Usb)
+        return Solid::StorageDrive::MemoryStick;
+    return Solid::StorageDrive::HardDisk;
+}
+
+bool WinStorageDrive::isRemovable() const
+{
+    return m_isRemovable;
+}
+
+bool WinStorageDrive::isHotpluggable() const
+{
+    return m_isHotplugges;
+}
+
+qulonglong WinStorageDrive::size() const
+{
+    return m_size;
+}
+
+void WinStorageDrive::updateCache()
+{
+    STORAGE_PROPERTY_QUERY storageProperty;
+    storageProperty.PropertyId = StorageAdapterProperty;
+    storageProperty.QueryType = PropertyStandardQuery;
+
+    QString dev;
+    if(m_device->type() == Solid::DeviceInterface::OpticalDrive)
+    {
+        dev =  WinBlock::driveLetterFromUdi(m_device->udi());
+    }
+    else
+    {
+        dev = QLatin1String("PhysicalDrive") + QString::number(deviceMajor());
+    }
+    STORAGE_ADAPTER_DESCRIPTOR  busInfo = WinDeviceManager::getDeviceInfo<STORAGE_ADAPTER_DESCRIPTOR>(dev,IOCTL_STORAGE_QUERY_PROPERTY,&storageProperty);
+
+    switch(busInfo.BusType)
+    {
+    case BusTypeUsb:
+        m_bus = Solid::StorageDrive::Usb;
+        break;
+    case BusType1394:
+        m_bus = Solid::StorageDrive::Ieee1394;
+        break;
+    case BusTypeScsi:
+        m_bus = Solid::StorageDrive::Scsi;
+        break;
+    case BusTypeAta:
+    default:
+        m_bus = Solid::StorageDrive::Ide;
+    }
+
+    DISK_GEOMETRY  sizeInfo = WinDeviceManager::getDeviceInfo<DISK_GEOMETRY>(dev,IOCTL_DISK_GET_DRIVE_GEOMETRY);
+    m_size = sizeInfo.Cylinders.QuadPart * sizeInfo.TracksPerCylinder * sizeInfo.SectorsPerTrack * sizeInfo.BytesPerSector;
+
+
+
+    STORAGE_HOTPLUG_INFO plugInfo = WinDeviceManager::getDeviceInfo<STORAGE_HOTPLUG_INFO>(dev,IOCTL_STORAGE_GET_HOTPLUG_INFO);
+    m_isHotplugges = plugInfo.DeviceHotplug;
+    m_isRemovable = plugInfo.MediaRemovable;
+
+}
+
+#include "winstoragedrive.moc"
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winstoragedrive.h kdelibs-4.10.2/solid/solid/backends/win/winstoragedrive.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winstoragedrive.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winstoragedrive.h	2013-06-01 14:28:10.786910600 +0200
@@ -0,0 +1,66 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifndef WINSTORAGEDRIVE_H
+#define WINSTORAGEDRIVE_H
+
+#include <solid/ifaces/storagedrive.h>
+
+
+#include "windevice.h"
+#include "winblock.h"
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+
+class WinStorageDrive : public WinBlock ,  public virtual Solid::Ifaces::StorageDrive
+{
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::StorageDrive)
+public:
+    WinStorageDrive(WinDevice *device);
+    ~WinStorageDrive();
+
+    virtual Solid::StorageDrive::Bus bus() const;
+
+    virtual Solid::StorageDrive::DriveType driveType() const;
+
+    virtual bool isRemovable() const;
+
+    virtual bool isHotpluggable() const;
+
+    virtual qulonglong size() const;
+
+private:
+    void updateCache();
+
+    Solid::StorageDrive::Bus m_bus;
+    qulonglong m_size;
+    bool m_isHotplugges;
+    bool m_isRemovable;
+};
+}
+}
+}
+
+#endif // WINSTORAGEDRIVE_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winstoragevolume.cpp kdelibs-4.10.2/solid/solid/backends/win/winstoragevolume.cpp
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winstoragevolume.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winstoragevolume.cpp	2013-06-01 14:28:10.789910700 +0200
@@ -0,0 +1,108 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "winstoragevolume.h"
+
+#include "windevicemanager.h"
+
+#include <windows.h>
+
+#include <iostream>
+
+using namespace Solid::Backends::Win;
+
+WinStorageVolume::WinStorageVolume(WinDevice *device)
+    : WinBlock(device),
+      m_size(0)
+{
+    updateCache();
+}
+
+WinStorageVolume::~WinStorageVolume()
+{
+}
+
+bool WinStorageVolume::isIgnored() const
+{
+    return WinBlock::driveLetterFromUdi(m_device->udi()).isNull();
+}
+
+Solid::StorageVolume::UsageType WinStorageVolume::usage() const
+{
+    return Solid::StorageVolume::FileSystem;//TODO:???
+}
+
+
+void WinStorageVolume::updateCache()
+{
+    wchar_t label[MAX_PATH];
+    wchar_t fs[MAX_PATH];
+    DWORD serial;
+    DWORD flags;
+    //TODO:get correct name
+    wchar_t dLetter[MAX_PATH];
+    int dLetterSize = WinBlock::driveLetterFromUdi(m_device->udi()).toWCharArray(dLetter);
+    dLetter[dLetterSize] = (wchar_t)'\\';
+    dLetter[dLetterSize+1] = 0;
+
+    if(GetVolumeInformation(dLetter,label,MAX_PATH,&serial,NULL,&flags,fs,MAX_PATH))
+    {
+        m_label = QString::fromWCharArray(label);
+        m_fs = QString::fromWCharArray(fs);
+        m_uuid =  QString::number(serial,16);
+    }
+
+    ULARGE_INTEGER size;
+    if(GetDiskFreeSpaceEx(dLetter,NULL,&size,NULL))
+    {
+        m_size = size.QuadPart;
+    }
+}
+
+
+QString WinStorageVolume::fsType() const
+{
+    return m_fs;
+}
+
+QString WinStorageVolume::label() const
+{
+    return m_label;
+}
+
+QString WinStorageVolume::uuid() const
+{
+    return m_uuid;
+}
+
+qulonglong WinStorageVolume::size() const
+{
+    return m_size;
+}
+
+QString WinStorageVolume::encryptedContainerUdi() const
+{
+    return QString();
+}
+
+#include "winstoragevolume.moc"
+
+
+
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/backends/win/winstoragevolume.h kdelibs-4.10.2/solid/solid/backends/win/winstoragevolume.h
--- kdelibs-4.10.2.orig/solid/solid/backends/win/winstoragevolume.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-4.10.2/solid/solid/backends/win/winstoragevolume.h	2013-06-01 14:28:10.792910900 +0200
@@ -0,0 +1,68 @@
+/*
+    Copyright 2013 Patrick von Reth <vonreth@kde.org>
+    
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef WINSTORAGEVOLUME_H
+#define WINSTORAGEVOLUME_H
+
+#include <solid/ifaces/storagevolume.h>
+
+#include "wininterface.h"
+#include "winblock.h"
+
+namespace Solid
+{
+namespace Backends
+{
+namespace Win
+{
+
+class WinStorageVolume : public WinBlock, public virtual Solid::Ifaces::StorageVolume
+{
+    Q_OBJECT
+    Q_INTERFACES(Solid::Ifaces::StorageVolume)
+
+public:
+    WinStorageVolume(WinDevice *device);
+    ~WinStorageVolume();
+
+    virtual bool isIgnored() const;
+
+    virtual Solid::StorageVolume::UsageType usage() const;
+    virtual QString fsType() const;
+    virtual QString label() const;
+    virtual QString uuid() const;
+    virtual qulonglong size() const;
+    virtual QString encryptedContainerUdi() const;
+
+private:
+    QString m_fs;
+    QString m_label;
+    QString m_uuid;
+    qulonglong m_size;
+
+    void updateCache();
+
+};
+
+}
+}
+}
+
+#endif // WINVOLUME_H
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/CMakeLists.txt kdelibs-4.10.2/solid/solid/CMakeLists.txt
--- kdelibs-4.10.2.orig/solid/solid/CMakeLists.txt	2013-03-29 08:00:27.998064000 +0100
+++ kdelibs-4.10.2/solid/solid/CMakeLists.txt	2013-06-01 14:28:10.795911100 +0200
@@ -10,7 +10,12 @@
 configure_file(solid_export.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/solid_export.h)
 
 include (CheckCXXSourceCompiles)
-
+if(MSVC)
+check_cxx_source_compiles("int main() { __asm { pxor mm0, mm0 }; }" HAVE_X86_MMX)
+check_cxx_source_compiles("int main() { __asm { xorps xmm0, xmm0 }; }" HAVE_X86_SSE)
+check_cxx_source_compiles("int main() { __asm { xorpd xmm0, xmm0 }; }" HAVE_X86_SSE2)
+check_cxx_source_compiles("int main() { __asm { femms }; }" HAVE_X86_3DNOW)
+else(MSVC)
 check_cxx_source_compiles("	#ifdef __SUNPRO_CC
 					#define __asm__ asm
 				#endif
@@ -27,6 +32,7 @@
                                         #define __asm__ asm
                                 #endif
 				int main() { __asm__(\"femms\"); }" HAVE_X86_3DNOW)
+endif(MSVC)
 check_cxx_source_compiles("     #ifdef __SUNPRO_CC
                                         #define __asm__ asm
                                 #endif
@@ -43,6 +49,7 @@
    ${CMAKE_CURRENT_BINARY_DIR}/backends/hal
    ${CMAKE_CURRENT_BINARY_DIR}/backends/udev
    ${CMAKE_CURRENT_BINARY_DIR}/backends/wmi
+   ${CMAKE_CURRENT_BINARY_DIR}/backends/win
 )
 
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${KDE4_C_FLAGS}") # enable -fvisibility=hidden for C sources
@@ -338,17 +345,20 @@
 endif(APPLE)
 
 if(WIN32)
-   include(CheckIncludeFileCXX)
-   check_include_file_cxx(wbemidl.h HAVE_WBEM)
-   FIND_LIBRARY(WBEM_LIBRARIES NAMES wbemuuid wbemuuidd)
-   if(HAVE_WBEM AND WBEM_LIBRARIES)
-      set(HAVE_WBEM True)
-      message(STATUS "Found wbemuuid library: ${WBEM_LIBRARIES}")
-   else(HAVE_WBEM AND WBEM_LIBRARIES)
-      set(HAVE_WBEM False)
-   endif(HAVE_WBEM AND WBEM_LIBRARIES)
-   if(HAVE_WBEM AND NOT WINCE)
-       set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DHAVE_WBEM")
+    if(WITH_SOLID_WMI)
+       include(CheckIncludeFileCXX)
+       check_include_file_cxx(wbemidl.h HAVE_WBEM)
+       FIND_LIBRARY(WBEM_LIBRARIES NAMES wbemuuid wbemuuidd)
+       if(HAVE_WBEM AND WBEM_LIBRARIES)
+          set(HAVE_WBEM True)
+          message(STATUS "Found wbemuuid library: ${WBEM_LIBRARIES}")
+       else(HAVE_WBEM AND WBEM_LIBRARIES)
+          set(HAVE_WBEM False)
+          set(WITH_SOLID_WMI False)
+      endif(HAVE_WBEM AND WBEM_LIBRARIES)
+   endif(WITH_SOLID_WMI)
+   if(WITH_SOLID_WMI)
+       add_definitions(-WITH_SOLID_WMI)
        message(STATUS "-- Building Solid WMI backend." )
 
        set(solid_LIB_SRCS ${solid_LIB_SRCS}
@@ -375,7 +385,25 @@
        backends/wmi/wmivolume.cpp
 
        )
-    endif(HAVE_WBEM AND NOT WINCE)
+    else(WITH_SOLID_WMI)
+       message(STATUS "-- Building Solid Windows backend." )
+       set(solid_LIB_SRCS ${solid_LIB_SRCS}
+       backends/win/winblock.cpp
+       backends/win/winopticaldrive.cpp
+       backends/win/wininterface.cpp
+       backends/win/wingenericinterface.cpp
+       backends/win/windevice.cpp
+       backends/win/windevicemanager.cpp
+       backends/win/winopticaldisc.cpp
+       backends/win/winprocessor.cpp
+       #backends/win/wmiportablemediaplayer.cpp
+       backends/win/winstorageaccess.cpp
+       backends/win/winstoragedrive.cpp
+       backends/win/winstoragevolume.cpp
+       backends/win/winbattery.cpp
+       backends/win/winacadapter.cpp
+       )
+    endif(WITH_SOLID_WMI)
 endif(WIN32)
 
 set_source_files_properties( org.freedesktop.PowerManagement.xml
@@ -394,9 +422,11 @@
 
 if(WIN32)
    set(solid_OPTIONAL_LIBS ${solid_OPTIONAL_LIBS} ${KDEWIN_LIBRARY})
-   if(HAVE_WBEM)
+   if(WITH_SOLID_WMI)
       set(solid_OPTIONAL_LIBS ${solid_OPTIONAL_LIBS} ${WBEM_LIBRARIES})
-   endif(HAVE_WBEM)
+   else(WITH_SOLID_WMI)
+      set(solid_OPTIONAL_LIBS ${solid_OPTIONAL_LIBS} setupapi)
+   endif(WITH_SOLID_WMI)
 endif(WIN32)
 
 if(APPLE)
diff -Nru -x '*~' kdelibs-4.10.2.orig/solid/solid/managerbase.cpp kdelibs-4.10.2/solid/solid/managerbase.cpp
--- kdelibs-4.10.2.orig/solid/solid/managerbase.cpp	2013-03-01 07:26:14.567774000 +0100
+++ kdelibs-4.10.2/solid/solid/managerbase.cpp	2013-06-01 14:28:11.076927200 +0200
@@ -48,9 +48,12 @@
 
 #include "backends/fstab/fstabmanager.h"
 
-#elif defined (Q_WS_WIN) && defined(HAVE_WBEM) && !defined(_WIN32_WCE)
+#elif defined (Q_WS_WIN) && !defined(_WIN32_WCE)
+#include "backends/win/windevicemanager.h"
+#ifdef WITH_SOLID_WMI
 #include "backends/wmi/wmimanager.h"
 #endif
+#endif
 
 
 Solid::ManagerBasePrivate::ManagerBasePrivate()
@@ -72,9 +75,10 @@
 #        if defined(Q_OS_MAC)
             m_backends << new Solid::Backends::IOKit::IOKitManager(0);
 
-#        elif defined(Q_WS_WIN) && defined(HAVE_WBEM) && !defined(_WIN32_WCE)
+#        elif defined(Q_WS_WIN) && defined(WITH_SOLID_WMI) && !defined(_WIN32_WCE)
             m_backends << new Solid::Backends::Wmi::WmiManager(0);
-
+#        elif defined(Q_WS_WIN) && !defined(_WIN32_WCE)
+            m_backends << new Solid::Backends::Win::WinDeviceManager(0);
 #        elif defined(Q_OS_UNIX) && !defined(Q_OS_LINUX)
             m_backends << new Solid::Backends::Hal::HalManager(0);
 
