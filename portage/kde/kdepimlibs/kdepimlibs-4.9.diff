diff --git a/akonadi/notes/noteutils.cpp b/akonadi/notes/noteutils.cpp
index 2ea47a5..1db80e1 100644
--- a/akonadi/notes/noteutils.cpp
+++ b/akonadi/notes/noteutils.cpp
@@ -209,9 +209,9 @@ void NoteMessageWrapper::NoteMessageWrapperPrivate::readMimeMessage(const KMime:
 
   if (KMime::Headers::Base *classificationHeader = msg->headerByType(X_NOTES_CLASSIFICATION_HEADER)) {
     const QString &c = classificationHeader->asUnicodeString();
-    if ( c == CLASSIFICATION_PRIVATE ) {
+    if ( c == QString::fromLatin1( CLASSIFICATION_PRIVATE ) ) {
       classification = Private;
-    } else if ( c == CLASSIFICATION_CONFIDENTIAL ) {
+    } else if ( c == QString::fromLatin1( CLASSIFICATION_CONFIDENTIAL ) ) {
       classification = Confidential;
     }
   }
@@ -220,9 +220,9 @@ void NoteMessageWrapper::NoteMessageWrapperPrivate::readMimeMessage(const KMime:
   Q_FOREACH(KMime::Content *c, msg->contents()) {
     if (KMime::Headers::Base *typeHeader = c->headerByType(X_NOTES_CONTENTTYPE_HEADER)) {
       const QString &type = typeHeader->asUnicodeString();
-      if ( type == CONTENT_TYPE_CUSTOM ) {
+      if ( type == QString::fromLatin1( CONTENT_TYPE_CUSTOM ) ) {
         parseCustomPart(c);
-      } else if ( type == CONTENT_TYPE_ATTACHMENT ) {
+      } else if ( type == QString::fromLatin1( CONTENT_TYPE_ATTACHMENT ) ) {
         parseAttachmentPart(c);
       } else {
         qWarning() << "unknown type " << type;
@@ -234,8 +234,8 @@ void NoteMessageWrapper::NoteMessageWrapperPrivate::readMimeMessage(const KMime:
 QDomDocument createXMLDocument()
 {
   QDomDocument document;
-  QString p = "version=\"1.0\" encoding=\"UTF-8\"";
-  document.appendChild(document.createProcessingInstruction( "xml", p ) );
+  QString p = QString::fromLatin1( "version=\"1.0\" encoding=\"UTF-8\"" );
+  document.appendChild(document.createProcessingInstruction( QString::fromLatin1( "xml" ), p ) );
   return document;
 }
 
@@ -256,10 +256,10 @@ QDomDocument loadDocument(KMime::Content *part)
 KMime::Content* NoteMessageWrapper::NoteMessageWrapperPrivate::createCustomPart() const
 {
   KMime::Content* content = new KMime::Content();
-  content->appendHeader( new KMime::Headers::Generic( X_NOTES_CONTENTTYPE_HEADER, content, CONTENT_TYPE_CUSTOM, ENCODING ) );
+  content->appendHeader( new KMime::Headers::Generic( X_NOTES_CONTENTTYPE_HEADER, content, QString::fromLatin1( CONTENT_TYPE_CUSTOM ), ENCODING ) );
   QDomDocument document = createXMLDocument();
-  QDomElement element = document.createElement( "custom" );
-  element.setAttribute( "version", "1.0" );
+  QDomElement element = document.createElement( QString::fromLatin1( "custom" ) );
+  element.setAttribute( QString::fromLatin1( "version" ), QString::fromLatin1( "1.0" ) );
   for ( QMap <QString, QString >::const_iterator it = custom.begin(); it != custom.end(); ++it ) {
     QDomElement e = element.ownerDocument().createElement( it.key() );
     QDomText t = element.ownerDocument().createTextNode( it.value() );
@@ -278,7 +278,7 @@ void NoteMessageWrapper::NoteMessageWrapperPrivate::parseCustomPart( KMime::Cont
     return;
   }
   QDomElement top = document.documentElement();
-  if ( top.tagName() != "custom" ) {
+  if ( top.tagName() != QString::fromLatin1( "custom" ) ) {
     qWarning( "XML error: Top tag was %s instead of the expected custom",
               top.tagName().toAscii().data() );
     return;
@@ -298,19 +298,19 @@ void NoteMessageWrapper::NoteMessageWrapperPrivate::parseCustomPart( KMime::Cont
 KMime::Content* NoteMessageWrapper::NoteMessageWrapperPrivate::createAttachmentPart( const Attachment &a ) const
 {
   KMime::Content* content = new KMime::Content();
-  content->appendHeader( new KMime::Headers::Generic( X_NOTES_CONTENTTYPE_HEADER, content, CONTENT_TYPE_ATTACHMENT, ENCODING ) );
+  content->appendHeader( new KMime::Headers::Generic( X_NOTES_CONTENTTYPE_HEADER, content, QString::fromLatin1( CONTENT_TYPE_ATTACHMENT ), ENCODING ) );
   if (a.url().isValid()) {
-    content->appendHeader( new KMime::Headers::Generic( X_NOTES_URL_HEADER, content, a.url().toString().toLatin1(), ENCODING ) );
+    content->appendHeader( new KMime::Headers::Generic( X_NOTES_URL_HEADER, content, QString::fromLatin1( a.url().toString().toLatin1() ), ENCODING ) );
   } else {
     content->setBody( a.data() );
   }
   content->contentType()->setMimeType( a.mimetype().toLatin1() );
   if (!a.label().isEmpty()) {
-    content->appendHeader( new KMime::Headers::Generic( X_NOTES_LABEL_HEADER, content, a.label().toLatin1(), ENCODING ) );
+    content->appendHeader( new KMime::Headers::Generic( X_NOTES_LABEL_HEADER, content, QString::fromLatin1( a.label().toLatin1() ), ENCODING ) );
   }
   content->contentTransferEncoding()->setEncoding( KMime::Headers::CEbase64 );
   content->contentDisposition()->setDisposition( KMime::Headers::CDattachment );
-  content->contentDisposition()->setFilename( "attachment" );
+  content->contentDisposition()->setFilename( QString::fromLatin1( "attachment" ) );
   return content;
 }
 
@@ -321,11 +321,11 @@ void NoteMessageWrapper::NoteMessageWrapperPrivate::parseAttachmentPart( KMime::
     label = labelHeader->asUnicodeString();
   }
   if ( KMime::Headers::Base *header = part->headerByType( X_NOTES_URL_HEADER ) ) {
-    Attachment attachment( QUrl( header->asUnicodeString() ), part->contentType()->mimeType() );
+    Attachment attachment( QUrl( header->asUnicodeString() ), QString::fromLatin1( part->contentType()->mimeType() ) );
     attachment.setLabel( label );
     attachments.append(attachment);
   } else {
-    Attachment attachment( part->decodedContent(), part->contentType()->mimeType() );
+    Attachment attachment( part->decodedContent(), QString::fromLatin1( part->contentType()->mimeType() ) );
     attachment.setLabel( label );
     attachments.append(attachment);
   }
@@ -383,7 +383,7 @@ KMime::Message::Ptr NoteMessageWrapper::message() const
   msg->date( true )->setDateTime( creationDate );
   msg->from( true )->fromUnicodeString( d->from, ENCODING );
   msg->mainBodyPart()->fromUnicodeString( text );
-  msg->appendHeader( new KMime::Headers::Generic(X_NOTES_LASTMODIFIED_HEADER, msg.get(), lastModifiedDate.toString( KDateTime::RFCDateDay ).toLatin1(), ENCODING ) );
+  msg->appendHeader( new KMime::Headers::Generic(X_NOTES_LASTMODIFIED_HEADER, msg.get(), QString::fromLatin1( lastModifiedDate.toString( KDateTime::RFCDateDay ).toLatin1() ), ENCODING ) );
   msg->appendHeader( new KMime::Headers::Generic( X_NOTES_UID_HEADER, msg.get(), uid, ENCODING ) );
 
   QString classification = QString::fromLatin1(CLASSIFICATION_PUBLIC);
diff --git a/gpgme++/ConfigureChecks.cmake b/gpgme++/ConfigureChecks.cmake
index 0870d08..ef61853 100644
--- a/gpgme++/ConfigureChecks.cmake
+++ b/gpgme++/ConfigureChecks.cmake
@@ -3,6 +3,8 @@ include(CheckFunctionExists)
 
 if ( GPGME_FOUND )
 
+set(CMAKE_REQUIRED_INCLUDES_SAVE ${CMAKE_REQUIRED_INCLUDES})
+set(CMAKE_REQUIRED_LIBRARIES_SAVE ${CMAKE_REQUIRED_LIBRARIES})
 set(CMAKE_REQUIRED_INCLUDES ${GPGME_INCLUDES})
 set(CMAKE_REQUIRED_DEFINITIONS ${KDE4_DEFINITIONS})
 set(CMAKE_REQUIRED_LIBRARIES)
@@ -426,7 +428,9 @@ check_cxx_source_compiles ("
   }
 " HAVE_GPGME_CONF_ARG_NEW_WITH_CONST_VALUE )
 
-set(CMAKE_REQUIRED_INCLUDES)
-set(CMAKE_REQUIRED_LIBRARIES)
+set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_SAVE})
+set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES_SAVE})
+set(CMAKE_REQUIRED_INCLUDES_SAVE)
+set(CMAKE_REQUIRED_LIBRARIES_SAVE)
 
 endif()
