diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/API/APICast.h b/src/3rdparty/javascriptcore/JavaScriptCore/API/APICast.h
index 4284c44..5a0628a 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/API/APICast.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/API/APICast.h
@@ -65,7 +65,7 @@ inline JSC::JSValue toJS(JSC::ExecState* exec, JSValueRef v)
 {
     ASSERT_UNUSED(exec, exec);
     ASSERT(v);
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     JSC::JSCell* jsCell = reinterpret_cast<JSC::JSCell*>(const_cast<OpaqueJSValue*>(v));
     if (!jsCell)
         return JSC::JSValue();
@@ -81,7 +81,7 @@ inline JSC::JSValue toJSForGC(JSC::ExecState* exec, JSValueRef v)
 {
     ASSERT_UNUSED(exec, exec);
     ASSERT(v);
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     JSC::JSCell* jsCell = reinterpret_cast<JSC::JSCell*>(const_cast<OpaqueJSValue*>(v));
     if (!jsCell)
         return JSC::JSValue();
@@ -108,7 +108,7 @@ inline JSC::JSGlobalData* toJS(JSContextGroupRef g)
 
 inline JSValueRef toRef(JSC::ExecState* exec, JSC::JSValue v)
 {
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     if (!v)
         return 0;
     if (!v.isCell())
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/API/JSContextRef.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/API/JSContextRef.cpp
index 6bdc3c8..e37ec6f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/API/JSContextRef.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/API/JSContextRef.cpp
@@ -35,7 +35,7 @@
 #include "JSObject.h"
 #include <wtf/Platform.h>
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #include <mach-o/dyld.h>
 
 static const int32_t webkitFirstVersionWithConcurrentGlobalContexts = 0x2100500; // 528.5.0
@@ -63,7 +63,7 @@ void JSContextGroupRelease(JSContextGroupRef group)
 JSGlobalContextRef JSGlobalContextCreate(JSClassRef globalObjectClass)
 {
     initializeThreading();
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     // When running on Tiger or Leopard, or if the application was linked before JSGlobalContextCreate was changed
     // to use a unique JSGlobalData, we use a shared one for compatibility.
 #if !defined(BUILDING_ON_TIGER) && !defined(BUILDING_ON_LEOPARD)
@@ -74,7 +74,7 @@ JSGlobalContextRef JSGlobalContextCreate(JSClassRef globalObjectClass)
         JSLock lock(LockForReal);
         return JSGlobalContextCreateInGroup(toRef(&JSGlobalData::sharedInstance()), globalObjectClass);
     }
-#endif // OS(DARWIN)
+#endif // (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
     return JSGlobalContextCreateInGroup(0, globalObjectClass);
 }
@@ -88,7 +88,7 @@ JSGlobalContextRef JSGlobalContextCreateInGroup(JSContextGroupRef group, JSClass
 
     APIEntryShim entryShim(globalData.get(), false);
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     globalData->makeUsableFromMultipleThreads();
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMAssembler.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMAssembler.cpp
index 6dd2b87..c6a8587 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMAssembler.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMAssembler.cpp
@@ -26,7 +26,7 @@
 
 #include "config.h"
 
-#if ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 #include "ARMAssembler.h"
 
@@ -374,4 +374,4 @@ void* ARMAssembler::executableCopy(ExecutablePool* allocator)
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMAssembler.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMAssembler.h
index 6967b37..cb3f15b 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMAssembler.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMAssembler.h
@@ -29,7 +29,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 #include "AssemblerBufferWithConstantPool.h"
 #include <wtf/Assertions.h>
@@ -831,6 +831,6 @@ namespace JSC {
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 #endif // ARMAssembler_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMv7Assembler.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMv7Assembler.h
index 4e394b2..0fd94fe 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMv7Assembler.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/ARMv7Assembler.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER) && CPU(ARM_THUMB2)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
 
 #include "AssemblerBuffer.h"
 #include <wtf/Assertions.h>
@@ -1832,6 +1832,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER) && CPU(ARM_THUMB2)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
 
 #endif // ARMAssembler_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AbstractMacroAssembler.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AbstractMacroAssembler.h
index 198e8d1..340b46b 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AbstractMacroAssembler.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AbstractMacroAssembler.h
@@ -33,7 +33,7 @@
 #include <wtf/Noncopyable.h>
 #include <wtf/UnusedParam.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 namespace JSC {
 
@@ -173,16 +173,16 @@ public:
     struct Imm32 {
         explicit Imm32(int32_t value)
             : m_value(value)
-#if CPU(ARM)
+#if (defined WTF_CPU_ARM && WTF_CPU_ARM)
             , m_isPointer(false)
 #endif
         {
         }
 
-#if !CPU(X86_64)
+#if !(defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         explicit Imm32(ImmPtr ptr)
             : m_value(ptr.asIntptr())
-#if CPU(ARM)
+#if (defined WTF_CPU_ARM && WTF_CPU_ARM)
             , m_isPointer(true)
 #endif
         {
@@ -190,7 +190,7 @@ public:
 #endif
 
         int32_t m_value;
-#if CPU(ARM)
+#if (defined WTF_CPU_ARM && WTF_CPU_ARM)
         // We rely on being able to regenerate code to recover exception handling
         // information.  Since ARMv7 supports 16-bit immediates there is a danger
         // that if pointer values change the layout of the generated code will change.
@@ -530,6 +530,6 @@ protected:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // AbstractMacroAssembler_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AssemblerBuffer.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AssemblerBuffer.h
index 073906a..c683fbb 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AssemblerBuffer.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AssemblerBuffer.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #include "stdint.h"
 #include <string.h>
@@ -168,6 +168,6 @@ namespace JSC {
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // AssemblerBuffer_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AssemblerBufferWithConstantPool.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AssemblerBufferWithConstantPool.h
index af3c3be..ca7ae06 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AssemblerBufferWithConstantPool.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/AssemblerBufferWithConstantPool.h
@@ -29,7 +29,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #include "AssemblerBuffer.h"
 #include <wtf/SegmentedVector.h>
@@ -313,6 +313,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // AssemblerBufferWithConstantPool_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/CodeLocation.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/CodeLocation.h
index b910b6f..c705d9c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/CodeLocation.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/CodeLocation.h
@@ -30,7 +30,7 @@
 
 #include <MacroAssemblerCodeRef.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 namespace JSC {
 
@@ -181,6 +181,6 @@ inline CodeLocationDataLabel32 CodeLocationCommon::dataLabel32AtOffset(int offse
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // CodeLocation_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/LinkBuffer.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/LinkBuffer.h
index 6d08117..d8ef4f2 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/LinkBuffer.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/LinkBuffer.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #include <MacroAssembler.h>
 #include <wtf/Noncopyable.h>
@@ -190,6 +190,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // LinkBuffer_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssembler.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssembler.h
index 76bd205..01fa890 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssembler.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssembler.h
@@ -28,21 +28,21 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
-#if CPU(ARM_THUMB2)
+#if (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
 #include "MacroAssemblerARMv7.h"
 namespace JSC { typedef MacroAssemblerARMv7 MacroAssemblerBase; };
 
-#elif CPU(ARM_TRADITIONAL)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 #include "MacroAssemblerARM.h"
 namespace JSC { typedef MacroAssemblerARM MacroAssemblerBase; };
 
-#elif CPU(X86)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86)
 #include "MacroAssemblerX86.h"
 namespace JSC { typedef MacroAssemblerX86 MacroAssemblerBase; };
 
-#elif CPU(X86_64)
+#elif (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 #include "MacroAssemblerX86_64.h"
 namespace JSC { typedef MacroAssemblerX86_64 MacroAssemblerBase; };
 
@@ -60,7 +60,7 @@ public:
     using MacroAssemblerBase::jump;
     using MacroAssemblerBase::branch32;
     using MacroAssemblerBase::branch16;
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     using MacroAssemblerBase::branchPtr;
     using MacroAssemblerBase::branchTestPtr;
 #endif
@@ -134,7 +134,7 @@ public:
     // Ptr methods
     // On 32-bit platforms (i.e. x86), these methods directly map onto their 32-bit equivalents.
     // FIXME: should this use a test for 32-bitness instead of this specific exception?
-#if !CPU(X86_64)
+#if !(defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void addPtr(RegisterID src, RegisterID dest)
     {
         add32(src, dest);
@@ -333,6 +333,6 @@ public:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // MacroAssembler_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARM.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARM.cpp
index b5b20fa..769adbf 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARM.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARM.cpp
@@ -26,11 +26,11 @@
 
 #include "config.h"
 
-#if ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 #include "MacroAssemblerARM.h"
 
-#if OS(LINUX)
+#if (defined WTF_OS_LINUX && WTF_OS_LINUX)
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
@@ -43,7 +43,7 @@ namespace JSC {
 
 static bool isVFPPresent()
 {
-#if OS(LINUX)
+#if (defined WTF_OS_LINUX && WTF_OS_LINUX)
     int fd = open("/proc/self/auxv", O_RDONLY);
     if (fd > 0) {
         Elf32_auxv_t aux;
@@ -62,7 +62,7 @@ static bool isVFPPresent()
 
 const bool MacroAssemblerARM::s_isVFPPresent = isVFPPresent();
 
-#if CPU(ARMV5_OR_LOWER)
+#if (defined WTF_CPU_ARMV5_OR_LOWER && WTF_CPU_ARMV5_OR_LOWER)
 /* On ARMv5 and below, natural alignment is required. */
 void MacroAssemblerARM::load32WithUnalignedHalfWords(BaseIndex address, RegisterID dest)
 {
@@ -92,4 +92,4 @@ void MacroAssemblerARM::load32WithUnalignedHalfWords(BaseIndex address, Register
 
 }
 
-#endif // ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARM.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARM.h
index e5ba261..1f7fbaf 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARM.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARM.h
@@ -30,7 +30,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 #include "ARMAssembler.h"
 #include "AbstractMacroAssembler.h"
@@ -224,7 +224,7 @@ public:
         m_assembler.baseIndexTransfer32(true, dest, address.base, address.index, static_cast<int>(address.scale), address.offset);
     }
 
-#if CPU(ARMV5_OR_LOWER)
+#if (defined WTF_CPU_ARMV5_OR_LOWER && WTF_CPU_ARMV5_OR_LOWER)
     void load32WithUnalignedHalfWords(BaseIndex address, RegisterID dest);
 #else
     void load32WithUnalignedHalfWords(BaseIndex address, RegisterID dest)
@@ -935,6 +935,6 @@ private:
 
 }
 
-#endif // ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 #endif // MacroAssemblerARM_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARMv7.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARMv7.h
index 532a9cf..5872b2d 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARMv7.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerARMv7.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #include "ARMv7Assembler.h"
 #include "AbstractMacroAssembler.h"
@@ -1127,6 +1127,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // MacroAssemblerARMv7_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerCodeRef.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerCodeRef.h
index cae8bf6..c3e9e8c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerCodeRef.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerCodeRef.h
@@ -33,11 +33,11 @@
 #include "RefPtr.h"
 #include "UnusedParam.h"
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 // ASSERT_VALID_CODE_POINTER checks that ptr is a non-null pointer, and that it is a valid
 // instruction address on the platform (for example, check any alignment requirements).
-#if CPU(ARM_THUMB2)
+#if (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
 // ARM/thumb instructions must be 16-bit aligned, but all code pointers to be loaded
 // into the processor are decorated with the bottom bit set, indicating that this is
 // thumb code (as oposed to 32-bit traditional ARM).  The first test checks for both
@@ -69,7 +69,7 @@ public:
 
     template<typename FunctionType>
     explicit FunctionPtr(FunctionType* value)
-#if COMPILER(RVCT)
+#if (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
      // RVTC compiler needs C-style cast as it fails with the following error
      // Error:  #694: reinterpret_cast cannot cast away const or other type qualifiers
         : m_value((void*)(value))
@@ -130,7 +130,7 @@ public:
     }
 
     explicit MacroAssemblerCodePtr(void* value)
-#if CPU(ARM_THUMB2)
+#if (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
         // Decorate the pointer as a thumb code pointer.
         : m_value(reinterpret_cast<char*>(value) + 1)
 #else
@@ -147,7 +147,7 @@ public:
     }
 
     void* executableAddress() const { return m_value; }
-#if CPU(ARM_THUMB2)
+#if (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
     // To use this pointer as a data address remove the decoration.
     void* dataLocation() const { ASSERT_VALID_CODE_POINTER(m_value); return reinterpret_cast<char*>(m_value) - 1; }
 #else
@@ -189,6 +189,6 @@ public:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // MacroAssemblerCodeRef_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86.h
index ca7c31a..39a4c33 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER) && CPU(X86)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_X86 && WTF_CPU_X86)
 
 #include "MacroAssemblerX86Common.h"
 
@@ -199,6 +199,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // MacroAssemblerX86_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86Common.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86Common.h
index ab29cb0..268c982 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86Common.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86Common.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #include "X86Assembler.h"
 #include "AbstractMacroAssembler.h"
@@ -542,7 +542,7 @@ public:
             m_assembler.movl_i32r(imm.m_value, dest);
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void move(RegisterID src, RegisterID dest)
     {
         // Note: on 64-bit this is is a full register move; perhaps it would be
@@ -951,8 +951,8 @@ private:
     // x86_64, and clients & subclasses of MacroAssembler should be using 'supportsFloatingPoint()'.
     friend class MacroAssemblerX86;
 
-#if CPU(X86)
-#if OS(MAC_OS_X)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
+#if (defined WTF_OS_MAC_OS_X && WTF_OS_MAC_OS_X)
 
     // All X86 Macs are guaranteed to support at least SSE2,
     static bool isSSE2Present()
@@ -960,7 +960,7 @@ private:
         return true;
     }
 
-#else // OS(MAC_OS_X)
+#else // (defined WTF_OS_MAC_OS_X && WTF_OS_MAC_OS_X)
 
     enum SSE2CheckState {
         NotCheckedSSE2,
@@ -974,13 +974,13 @@ private:
             // Default the flags value to zero; if the compiler is
             // not MSVC or GCC we will read this as SSE2 not present.
             int flags = 0;
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
             _asm {
                 mov eax, 1 // cpuid function 1 gives us the standard feature set
                 cpuid;
                 mov flags, edx;
             }
-#elif COMPILER(GCC)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
             asm (
                  "movl $0x1, %%eax;"
                  "pushl %%ebx;"
@@ -1003,8 +1003,8 @@ private:
     
     static SSE2CheckState s_sse2CheckState;
 
-#endif // OS(MAC_OS_X)
-#elif !defined(NDEBUG) // CPU(X86)
+#endif // (defined WTF_OS_MAC_OS_X && WTF_OS_MAC_OS_X)
+#elif !defined(NDEBUG) // (defined WTF_CPU_X86 && WTF_CPU_X86)
 
     // On x86-64 we should never be checking for SSE2 in a non-debug build,
     // but non debug add this method to keep the asserts above happy.
@@ -1018,6 +1018,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // MacroAssemblerX86Common_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86_64.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86_64.h
index ec93f8c..3e1429b 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86_64.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/MacroAssemblerX86_64.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER) && CPU(X86_64)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
 #include "MacroAssemblerX86Common.h"
 
@@ -448,6 +448,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // MacroAssemblerX86_64_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/RepatchBuffer.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/RepatchBuffer.h
index 89cbf06..d458182 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/RepatchBuffer.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/RepatchBuffer.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #include <MacroAssembler.h>
 #include <wtf/Noncopyable.h>
@@ -131,6 +131,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // RepatchBuffer_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/X86Assembler.h b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/X86Assembler.h
index ab3d05f..e52524d 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/assembler/X86Assembler.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/assembler/X86Assembler.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(ASSEMBLER) && (CPU(X86) || CPU(X86_64))
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && ((defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64))
 
 #include "AssemblerBuffer.h"
 #include <stdint.h>
@@ -50,7 +50,7 @@ namespace X86Registers {
         esi,
         edi,
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         r8,
         r9,
         r10,
@@ -118,12 +118,12 @@ private:
         OP_XOR_GvEv                     = 0x33,
         OP_CMP_EvGv                     = 0x39,
         OP_CMP_GvEv                     = 0x3B,
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         PRE_REX                         = 0x40,
 #endif
         OP_PUSH_EAX                     = 0x50,
         OP_POP_EAX                      = 0x58,
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         OP_MOVSXD_GvEv                  = 0x63,
 #endif
         PRE_OPERAND_SIZE                = 0x66,
@@ -296,7 +296,7 @@ public:
 
     // Arithmetic operations:
 
-#if !CPU(X86_64)
+#if !(defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void adcl_im(int imm, void* addr)
     {
         if (CAN_SIGN_EXTEND_8_32(imm)) {
@@ -346,7 +346,7 @@ public:
         }
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void addq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_ADD_EvGv, src, dst);
@@ -423,7 +423,7 @@ public:
         }
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void andq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_AND_EvGv, src, dst);
@@ -509,7 +509,7 @@ public:
         }
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void orq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_OR_EvGv, src, dst);
@@ -575,7 +575,7 @@ public:
         }
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void subq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_SUB_EvGv, src, dst);
@@ -641,7 +641,7 @@ public:
         }
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void xorq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_XOR_EvGv, src, dst);
@@ -689,7 +689,7 @@ public:
         m_formatter.oneByteOp(OP_GROUP2_EvCL, GROUP2_OP_SHL, dst);
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void sarq_CLr(RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_GROUP2_EvCL, GROUP2_OP_SAR, dst);
@@ -789,7 +789,7 @@ public:
         m_formatter.immediate32(imm);
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void cmpq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_CMP_EvGv, src, dst);
@@ -897,7 +897,7 @@ public:
         m_formatter.immediate32(imm);
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void testq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_TEST_EvGv, src, dst);
@@ -971,7 +971,7 @@ public:
         m_formatter.oneByteOp(OP_XCHG_EvGv, src, dst);
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void xchgq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_XCHG_EvGv, src, dst);
@@ -1001,7 +1001,7 @@ public:
     void movl_mEAX(void* addr)
     {
         m_formatter.oneByteOp(OP_MOV_EAXOv);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
 #else
         m_formatter.immediate32(reinterpret_cast<int>(addr));
@@ -1038,14 +1038,14 @@ public:
     void movl_EAXm(void* addr)
     {
         m_formatter.oneByteOp(OP_MOV_OvEAX);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
 #else
         m_formatter.immediate32(reinterpret_cast<int>(addr));
 #endif
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void movq_rr(RegisterID src, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_MOV_EvGv, src, dst);
@@ -1157,7 +1157,7 @@ public:
     {
         m_formatter.oneByteOp(OP_LEA, dst, base, offset);
     }
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void leaq_mr(int offset, RegisterID base, RegisterID dst)
     {
         m_formatter.oneByteOp64(OP_LEA, dst, base, offset);
@@ -1323,7 +1323,7 @@ public:
         m_formatter.twoByteOp(OP2_CVTSI2SD_VsdEd, (RegisterID)dst, base, offset);
     }
 
-#if !CPU(X86_64)
+#if !(defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void cvtsi2sd_mr(void* address, XMMRegisterID dst)
     {
         m_formatter.prefix(PRE_SSE_F2);
@@ -1343,7 +1343,7 @@ public:
         m_formatter.twoByteOp(OP2_MOVD_EdVd, (RegisterID)src, dst);
     }
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void movq_rr(XMMRegisterID src, RegisterID dst)
     {
         m_formatter.prefix(PRE_SSE_66);
@@ -1369,7 +1369,7 @@ public:
         m_formatter.twoByteOp(OP2_MOVSD_VsdWsd, (RegisterID)dst, base, offset);
     }
 
-#if !CPU(X86_64)
+#if !(defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     void movsd_mr(void* address, XMMRegisterID dst)
     {
         m_formatter.prefix(PRE_SSE_F2);
@@ -1535,7 +1535,7 @@ public:
 
     static void repatchLoadPtrToLEA(void* where)
     {
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         // On x86-64 pointer memory accesses require a 64-bit operand, and as such a REX prefix.
         // Skip over the prefix byte.
         where = reinterpret_cast<char*>(where) + 1;
@@ -1679,7 +1679,7 @@ private:
             memoryModRM(reg, base, index, scale, offset);
         }
 
-#if !CPU(X86_64)
+#if !(defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         void oneByteOp(OneByteOpcodeID opcode, int reg, void* address)
         {
             m_buffer.ensureSpace(maxInstructionSize);
@@ -1722,7 +1722,7 @@ private:
             memoryModRM(reg, base, index, scale, offset);
         }
 
-#if !CPU(X86_64)
+#if !(defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         void twoByteOp(TwoByteOpcodeID opcode, int reg, void* address)
         {
             m_buffer.ensureSpace(maxInstructionSize);
@@ -1732,7 +1732,7 @@ private:
         }
 #endif
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         // Quad-word-sized operands:
         //
         // Used to format 64-bit operantions, planting a REX.w prefix.
@@ -1891,7 +1891,7 @@ private:
         static const RegisterID noBase = X86Registers::ebp;
         static const RegisterID hasSib = X86Registers::esp;
         static const RegisterID noIndex = X86Registers::esp;
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         static const RegisterID noBase2 = X86Registers::r13;
         static const RegisterID hasSib2 = X86Registers::r12;
 
@@ -1967,7 +1967,7 @@ private:
         void memoryModRM(int reg, RegisterID base, int offset)
         {
             // A base of esp or r12 would be interpreted as a sib, so force a sib with no index & put the base in there.
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
             if ((base == hasSib) || (base == hasSib2)) {
 #else
             if (base == hasSib) {
@@ -1982,7 +1982,7 @@ private:
                     m_buffer.putIntUnchecked(offset);
                 }
             } else {
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
                 if (!offset && (base != noBase) && (base != noBase2))
 #else
                 if (!offset && (base != noBase))
@@ -2001,7 +2001,7 @@ private:
         void memoryModRM_disp32(int reg, RegisterID base, int offset)
         {
             // A base of esp or r12 would be interpreted as a sib, so force a sib with no index & put the base in there.
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
             if ((base == hasSib) || (base == hasSib2)) {
 #else
             if (base == hasSib) {
@@ -2018,7 +2018,7 @@ private:
         {
             ASSERT(index != noIndex);
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
             if (!offset && (base != noBase) && (base != noBase2))
 #else
             if (!offset && (base != noBase))
@@ -2033,7 +2033,7 @@ private:
             }
         }
 
-#if !CPU(X86_64)
+#if !(defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         void memoryModRM(int reg, void* address)
         {
             // noBase + ModRmMemoryNoDisp means noBase + ModRmMemoryDisp32!
@@ -2048,6 +2048,6 @@ private:
 
 } // namespace JSC
 
-#endif // ENABLE(ASSEMBLER) && CPU(X86)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_X86 && WTF_CPU_X86)
 
 #endif // X86Assembler_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/CodeBlock.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/CodeBlock.cpp
index 2256583..dc9ad10 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/CodeBlock.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/CodeBlock.cpp
@@ -44,7 +44,7 @@
 
 namespace JSC {
 
-#if !defined(NDEBUG) || ENABLE(OPCODE_SAMPLING)
+#if !defined(NDEBUG) || (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
 
 static UString escapeQuotes(const UString& str)
 {
@@ -177,7 +177,7 @@ void CodeBlock::printPutByIdOp(ExecState* exec, int location, Vector<Instruction
     it += 4;
 }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 static bool isGlobalResolve(OpcodeID opcodeID)
 {
     return opcodeID == op_resolve_global;
@@ -373,7 +373,7 @@ void CodeBlock::dump(ExecState* exec) const
         } while (i < m_rareData->m_regexps.size());
     }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     if (!m_globalResolveInfos.isEmpty() || !m_structureStubInfos.isEmpty())
         printf("\nStructures:\n");
 
@@ -1129,7 +1129,7 @@ void CodeBlock::dump(ExecState* exec, const Vector<Instruction>::const_iterator&
     }
 }
 
-#endif // !defined(NDEBUG) || ENABLE(OPCODE_SAMPLING)
+#endif // !defined(NDEBUG) || (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
 
 #if DUMP_CODE_BLOCK_STATISTICS
 static HashSet<CodeBlock*> liveCodeBlockSet;
@@ -1298,7 +1298,7 @@ CodeBlock::CodeBlock(ScriptExecutable* ownerExecutable, CodeType codeType, PassR
 
 CodeBlock::~CodeBlock()
 {
-#if !ENABLE(JIT)
+#if !(defined ENABLE_JIT && ENABLE_JIT)
     for (size_t size = m_globalResolveInstructions.size(), i = 0; i < size; ++i)
         derefStructures(&m_instructions[m_globalResolveInstructions[i]]);
 
@@ -1328,18 +1328,18 @@ CodeBlock::~CodeBlock()
         }
     }
 
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
     unlinkCallers();
 #endif
 
-#endif // !ENABLE(JIT)
+#endif // !(defined ENABLE_JIT && ENABLE_JIT)
 
 #if DUMP_CODE_BLOCK_STATISTICS
     liveCodeBlockSet.remove(this);
 #endif
 }
 
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 void CodeBlock::unlinkCallers()
 {
     size_t size = m_linkedCallerList.size();
@@ -1570,7 +1570,7 @@ bool CodeBlock::getByIdExceptionInfoForBytecodeOffset(CallFrame* callFrame, unsi
     return true;
 }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 bool CodeBlock::functionRegisterForBytecodeOffset(unsigned bytecodeOffset, int& functionRegisterIndex)
 {
     ASSERT(bytecodeOffset < m_instructionCount);
@@ -1596,7 +1596,7 @@ bool CodeBlock::functionRegisterForBytecodeOffset(unsigned bytecodeOffset, int&
 }
 #endif
 
-#if !ENABLE(JIT)
+#if !(defined ENABLE_JIT && ENABLE_JIT)
 bool CodeBlock::hasGlobalResolveInstructionAtBytecodeOffset(unsigned bytecodeOffset)
 {
     if (m_globalResolveInstructions.isEmpty())
@@ -1642,7 +1642,7 @@ void CodeBlock::shrinkToFit()
 {
     m_instructions.shrinkToFit();
 
-#if !ENABLE(JIT)
+#if !(defined ENABLE_JIT && ENABLE_JIT)
     m_propertyAccessInstructions.shrinkToFit();
     m_globalResolveInstructions.shrinkToFit();
 #else
@@ -1669,7 +1669,7 @@ void CodeBlock::shrinkToFit()
         m_rareData->m_immediateSwitchJumpTables.shrinkToFit();
         m_rareData->m_characterSwitchJumpTables.shrinkToFit();
         m_rareData->m_stringSwitchJumpTables.shrinkToFit();
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         m_rareData->m_functionRegisterInfos.shrinkToFit();
 #endif
     }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/CodeBlock.h b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/CodeBlock.h
index eb874cc..d71f709 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/CodeBlock.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/CodeBlock.h
@@ -43,7 +43,7 @@
 #include <wtf/RefPtr.h>
 #include <wtf/Vector.h>
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 #include "StructureStubInfo.h"
 #endif
 
@@ -70,7 +70,7 @@ namespace JSC {
         uint32_t end;
         uint32_t target;
         uint32_t scopeDepth;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         CodeLocationLabel nativeCode;
 #endif
     };
@@ -99,7 +99,7 @@ namespace JSC {
         bool isOpConstruct : 1;
     };
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     struct CallLinkInfo {
         CallLinkInfo()
             : callee(0)
@@ -253,7 +253,7 @@ namespace JSC {
         Vector<LineInfo> m_lineInfo;
         Vector<GetByIdExceptionInfo> m_getByIdExceptionInfo;
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         Vector<CallReturnOffsetToBytecodeIndex> m_callReturnIndexVector;
 #endif
     };
@@ -268,7 +268,7 @@ namespace JSC {
         void markAggregate(MarkStack&);
         void refStructures(Instruction* vPC) const;
         void derefStructures(Instruction* vPC) const;
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
         void unlinkCallers();
 #endif
 
@@ -301,7 +301,7 @@ namespace JSC {
         int expressionRangeForBytecodeOffset(CallFrame*, unsigned bytecodeOffset, int& divot, int& startOffset, int& endOffset);
         bool getByIdExceptionInfoForBytecodeOffset(CallFrame*, unsigned bytecodeOffset, OpcodeID&);
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         void addCaller(CallLinkInfo* caller)
         {
             caller->callee = this;
@@ -356,7 +356,7 @@ namespace JSC {
         void setInstructionCount(unsigned instructionCount) { m_instructionCount = instructionCount; }
 #endif
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         JITCode& getJITCode() { return ownerExecutable()->generatedJITCode(); }
         ExecutablePool* executablePool() { return ownerExecutable()->getExecutablePool(); }
 #endif
@@ -385,7 +385,7 @@ namespace JSC {
         unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
         unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
 
-#if !ENABLE(JIT)
+#if !(defined ENABLE_JIT && ENABLE_JIT)
         void addPropertyAccessInstruction(unsigned propertyAccessInstruction) { m_propertyAccessInstructions.append(propertyAccessInstruction); }
         void addGlobalResolveInstruction(unsigned globalResolveInstruction) { m_globalResolveInstructions.append(globalResolveInstruction); }
         bool hasGlobalResolveInstructionAtBytecodeOffset(unsigned bytecodeOffset);
@@ -425,7 +425,7 @@ namespace JSC {
         void addLineInfo(const LineInfo& lineInfo) { ASSERT(m_exceptionInfo); m_exceptionInfo->m_lineInfo.append(lineInfo); }
         LineInfo& lastLineInfo() { ASSERT(m_exceptionInfo); return m_exceptionInfo->m_lineInfo.last(); }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         Vector<CallReturnOffsetToBytecodeIndex>& callReturnIndexVector() { ASSERT(m_exceptionInfo); return m_exceptionInfo->m_callReturnIndexVector; }
 #endif
 
@@ -480,7 +480,7 @@ namespace JSC {
         int m_numParameters;
 
     private:
-#if !defined(NDEBUG) || ENABLE(OPCODE_SAMPLING)
+#if !defined(NDEBUG) || (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         void dump(ExecState*, const Vector<Instruction>::const_iterator& begin, Vector<Instruction>::const_iterator&) const;
 
         CString registerName(ExecState*, int r) const;
@@ -519,7 +519,7 @@ namespace JSC {
         RefPtr<SourceProvider> m_source;
         unsigned m_sourceOffset;
 
-#if !ENABLE(JIT)
+#if !(defined ENABLE_JIT && ENABLE_JIT)
         Vector<unsigned> m_propertyAccessInstructions;
         Vector<unsigned> m_globalResolveInstructions;
 #else
@@ -555,7 +555,7 @@ namespace JSC {
 
             EvalCodeCache m_evalCodeCache;
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
             Vector<FunctionRegisterInfo> m_functionRegisterInfos;
 #endif
         };
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Instruction.h b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Instruction.h
index bc2de19..2a6edb7 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Instruction.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Instruction.h
@@ -43,7 +43,7 @@ namespace JSC {
     // If the JIT is not in use we don't actually need the variable (that said, if the JIT is not in use we don't
     // curently actually use PolymorphicAccessStructureLists, which we should).  Anyway, this seems like the best
     // solution for now - will need to something smarter if/when we actually want mixed-mode operation.
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     typedef CodeLocationLabel PolymorphicAccessStructureListStubRoutineType;
 #else
     typedef void* PolymorphicAccessStructureListStubRoutineType;
@@ -125,7 +125,7 @@ namespace JSC {
     struct Instruction {
         Instruction(Opcode opcode)
         {
-#if !HAVE(COMPUTED_GOTO)
+#if !(defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
             // We have to initialize one of the pointer members to ensure that
             // the entire struct is initialized, when opcode is not a pointer.
             u.jsCell = 0;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/JumpTable.h b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/JumpTable.h
index b4f8e44..6bff099 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/JumpTable.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/JumpTable.h
@@ -39,7 +39,7 @@ namespace JSC {
 
     struct OffsetLocation {
         int32_t branchOffset;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         CodeLocationLabel ctiOffset;
 #endif
     };
@@ -47,7 +47,7 @@ namespace JSC {
     struct StringJumpTable {
         typedef HashMap<RefPtr<UString::Rep>, OffsetLocation> StringOffsetTable;
         StringOffsetTable offsetTable;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         CodeLocationLabel ctiDefault; // FIXME: it should not be necessary to store this.
 #endif
 
@@ -60,7 +60,7 @@ namespace JSC {
             return loc->second.branchOffset;
         }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         inline CodeLocationLabel ctiForValue(UString::Rep* value)
         {
             StringOffsetTable::const_iterator end = offsetTable.end();
@@ -76,7 +76,7 @@ namespace JSC {
         // FIXME: The two Vectors can be combind into one Vector<OffsetLocation>
         Vector<int32_t> branchOffsets;
         int32_t min;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         Vector<CodeLocationLabel> ctiOffsets;
         CodeLocationLabel ctiDefault;
 #endif
@@ -88,7 +88,7 @@ namespace JSC {
                 branchOffsets[key] = offset;
         }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         inline CodeLocationLabel ctiForValue(int32_t value)
         {
             if (value >= min && static_cast<uint32_t>(value - min) < ctiOffsets.size())
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Opcode.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Opcode.cpp
index bb7696d..e65961d 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Opcode.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Opcode.cpp
@@ -34,7 +34,7 @@ using namespace std;
 
 namespace JSC {
 
-#if ENABLE(OPCODE_SAMPLING) || ENABLE(CODEBLOCK_SAMPLING) || ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING) || (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING) || (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
 
 const char* const opcodeNames[] = {
 #define OPCODE_NAME_ENTRY(opcode, size) #opcode,
@@ -44,7 +44,7 @@ const char* const opcodeNames[] = {
 
 #endif
 
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
 
 long long OpcodeStats::opcodeCounts[numOpcodeIDs];
 long long OpcodeStats::opcodePairCounts[numOpcodeIDs][numOpcodeIDs];
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Opcode.h b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Opcode.h
index 9ac17ec..5f678e1 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Opcode.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/Opcode.h
@@ -195,8 +195,8 @@ namespace JSC {
         FOR_EACH_OPCODE_ID(VERIFY_OPCODE_ID);
     #undef VERIFY_OPCODE_ID
 
-#if HAVE(COMPUTED_GOTO)
-#if COMPILER(RVCT) || COMPILER(INTEL)
+#if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
+#if (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT) || (defined WTF_COMPILER_INTEL && WTF_COMPILER_INTEL)
     typedef void* Opcode;
 #else
     typedef const void* Opcode;
@@ -205,7 +205,7 @@ namespace JSC {
     typedef OpcodeID Opcode;
 #endif
 
-#if ENABLE(OPCODE_SAMPLING) || ENABLE(CODEBLOCK_SAMPLING) || ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING) || (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING) || (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
 
 #define PADDING_STRING "                                "
 #define PADDING_STRING_LENGTH static_cast<unsigned>(strlen(PADDING_STRING))
@@ -224,7 +224,7 @@ namespace JSC {
 
 #endif
 
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
 
     struct OpcodeStats {
         OpcodeStats();
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/SamplingTool.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/SamplingTool.cpp
index 3f0babc..c469844 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/SamplingTool.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/SamplingTool.cpp
@@ -33,13 +33,13 @@
 #include "Interpreter.h"
 #include "Opcode.h"
 
-#if !OS(WINDOWS)
+#if !(defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #include <unistd.h>
 #endif
 
 namespace JSC {
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
 
 void SamplingFlags::sample()
 {
@@ -91,7 +91,7 @@ void SamplingFlags::stop() {}
 uint32_t SamplingFlags::s_flags = 1 << 15;
 
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
 static void sleepForMicroseconds(unsigned us)
 {
@@ -128,10 +128,10 @@ void* SamplingThread::threadStartFunc(void*)
     while (s_running) {
         sleepForMicroseconds(hertz2us(s_hertz));
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
         SamplingFlags::sample();
 #endif
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         SamplingTool::sample();
 #endif
     }
@@ -194,7 +194,7 @@ void SamplingTool::doRun()
             m_opcodeSamplesInCTIFunctions[opcodeID]++;
     }
 
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
     if (CodeBlock* codeBlock = sample.codeBlock()) {
         MutexLocker locker(m_scriptSampleMapMutex);
         ScriptSampleRecord* record = m_scopeSampleMap->get(codeBlock->ownerExecutable());
@@ -211,7 +211,7 @@ void SamplingTool::sample()
 
 void SamplingTool::notifyOfScope(ScriptExecutable* script)
 {
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
     MutexLocker locker(m_scriptSampleMapMutex);
     m_scopeSampleMap->set(script, new ScriptSampleRecord(script));
 #else
@@ -224,7 +224,7 @@ void SamplingTool::setup()
     s_samplingTool = this;
 }
 
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
 
 struct OpcodeSampleInfo {
     OpcodeID opcode;
@@ -245,7 +245,7 @@ static int compareOpcodeIndicesSampling(const void* left, const void* right)
     return (leftSampleInfo->count < rightSampleInfo->count) ? 1 : (leftSampleInfo->count > rightSampleInfo->count) ? -1 : 0;
 }
 
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
 static int compareLineCountInfoSampling(const void* left, const void* right)
 {
     const LineCountInfo* leftLineCount = reinterpret_cast<const LineCountInfo*>(left);
@@ -313,7 +313,7 @@ void SamplingTool::dump(ExecState* exec)
     printf("\tcti count:\tsamples inside a CTI function called by this opcode\n");
     printf("\tcti %% of self:\tcti count / sample count\n");
     
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
 
     // (3) Build and sort 'codeBlockSamples' array.
 
@@ -388,7 +388,7 @@ void SamplingTool::dump(ExecState*)
 
 void AbstractSamplingCounter::dump()
 {
-#if ENABLE(SAMPLING_COUNTERS)
+#if (defined ENABLE_SAMPLING_COUNTERS && ENABLE_SAMPLING_COUNTERS)
     if (s_abstractSamplingCounterChain != &s_abstractSamplingCounterChainEnd) {
         printf("\nSampling Counter Values:\n");
         for (AbstractSamplingCounter* currCounter = s_abstractSamplingCounterChain; (currCounter != &s_abstractSamplingCounterChainEnd); currCounter = currCounter->m_next)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/SamplingTool.h b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/SamplingTool.h
index c3e6247..4d088ac 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/SamplingTool.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/SamplingTool.h
@@ -46,7 +46,7 @@ namespace JSC {
         static void start();
         static void stop();
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
         static void setFlag(unsigned flag)
         {
             ASSERT(flag >= 1);
@@ -83,7 +83,7 @@ namespace JSC {
 #endif
     private:
         static uint32_t s_flags;
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
         static uint64_t s_flagCounts[33];
 #endif
     };
@@ -113,7 +113,7 @@ namespace JSC {
         
         void sample(CodeBlock*, Instruction*);
 
-#if COMPILER(WINSCW) || COMPILER(ACC)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW) || (defined WTF_COMPILER_ACC && WTF_COMPILER_ACC)
         ScriptExecutable* m_executable;
 #else
         RefPtr<ScriptExecutable> m_executable;
@@ -145,7 +145,7 @@ namespace JSC {
         friend struct CallRecord;
         friend class HostCallRecord;
         
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         class CallRecord : public Noncopyable {
         public:
             CallRecord(SamplingTool* samplingTool)
@@ -198,7 +198,7 @@ namespace JSC {
             , m_sample(0)
             , m_sampleCount(0)
             , m_opcodeSampleCount(0)
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
             , m_scopeSampleMap(new ScriptSampleRecordMap())
 #endif
         {
@@ -208,7 +208,7 @@ namespace JSC {
 
         ~SamplingTool()
         {
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
             deleteAllValues(*m_scopeSampleMap);
 #endif
         }
@@ -271,7 +271,7 @@ namespace JSC {
         unsigned m_opcodeSamples[numOpcodeIDs];
         unsigned m_opcodeSamplesInCTIFunctions[numOpcodeIDs];
         
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
         Mutex m_scriptSampleMapMutex;
         OwnPtr<ScriptSampleRecordMap> m_scopeSampleMap;
 #endif
@@ -279,7 +279,7 @@ namespace JSC {
 
     // AbstractSamplingCounter:
     //
-    // Implements a named set of counters, printed on exit if ENABLE(SAMPLING_COUNTERS).
+    // Implements a named set of counters, printed on exit if (defined ENABLE_SAMPLING_COUNTERS && ENABLE_SAMPLING_COUNTERS).
     // See subclasses below, SamplingCounter, GlobalSamplingCounter and DeletableSamplingCounter.
     class AbstractSamplingCounter {
         friend class JIT;
@@ -320,7 +320,7 @@ namespace JSC {
         static bool s_completed;
     };
 
-#if ENABLE(SAMPLING_COUNTERS)
+#if (defined ENABLE_SAMPLING_COUNTERS && ENABLE_SAMPLING_COUNTERS)
     // SamplingCounter:
     //
     // This class is suitable and (hopefully!) convenient for cases where a counter is
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/StructureStubInfo.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/StructureStubInfo.cpp
index 018d832..40bbbfb 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/StructureStubInfo.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/StructureStubInfo.cpp
@@ -28,7 +28,7 @@
 
 namespace JSC {
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 void StructureStubInfo::deref()
 {
     switch (accessType) {
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/StructureStubInfo.h b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/StructureStubInfo.h
index 8e2c489..6ddb789 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/StructureStubInfo.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecode/StructureStubInfo.h
@@ -26,7 +26,7 @@
 #ifndef StructureStubInfo_h
 #define StructureStubInfo_h
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 #include "Instruction.h"
 #include "MacroAssembler.h"
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp
index b0a0877..05f4947 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp
@@ -155,7 +155,7 @@ void BytecodeGenerator::generate()
         
     m_codeBlock->setIsNumericCompareFunction(instructions() == m_globalData->numericCompareFunction(m_scopeChain->globalObject()->globalExec()));
 
-#if !ENABLE(OPCODE_SAMPLING)
+#if !(defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     if (!m_regeneratingForExceptionInfo && (m_codeType == FunctionCode || m_codeType == EvalCode))
         m_codeBlock->clearExceptionInfo();
 #endif
@@ -1070,7 +1070,7 @@ RegisterID* BytecodeGenerator::emitResolve(RegisterID* dst, const Identifier& pr
     if (globalObject) {
         bool forceGlobalResolve = false;
         if (m_regeneratingForExceptionInfo) {
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
             forceGlobalResolve = m_codeBlockBeingRegeneratedFrom->hasGlobalResolveInfoAtBytecodeOffset(instructions().size());
 #else
             forceGlobalResolve = m_codeBlockBeingRegeneratedFrom->hasGlobalResolveInstructionAtBytecodeOffset(instructions().size());
@@ -1082,7 +1082,7 @@ RegisterID* BytecodeGenerator::emitResolve(RegisterID* dst, const Identifier& pr
             return emitGetScopedVar(dst, depth, index, globalObject);
         }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         m_codeBlock->addGlobalResolveInfo(instructions().size());
 #else
         m_codeBlock->addGlobalResolveInstruction(instructions().size());
@@ -1177,7 +1177,7 @@ RegisterID* BytecodeGenerator::emitResolveWithBase(RegisterID* baseDst, Register
 
     bool forceGlobalResolve = false;
     if (m_regeneratingForExceptionInfo) {
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         forceGlobalResolve = m_codeBlockBeingRegeneratedFrom->hasGlobalResolveInfoAtBytecodeOffset(instructions().size());
 #else
         forceGlobalResolve = m_codeBlockBeingRegeneratedFrom->hasGlobalResolveInstructionAtBytecodeOffset(instructions().size());
@@ -1193,7 +1193,7 @@ RegisterID* BytecodeGenerator::emitResolveWithBase(RegisterID* baseDst, Register
         return baseDst;
     }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     m_codeBlock->addGlobalResolveInfo(instructions().size());
 #else
     m_codeBlock->addGlobalResolveInstruction(instructions().size());
@@ -1214,7 +1214,7 @@ void BytecodeGenerator::emitMethodCheck()
 
 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, const Identifier& property)
 {
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     m_codeBlock->addStructureStubInfo(StructureStubInfo(access_get_by_id));
 #else
     m_codeBlock->addPropertyAccessInstruction(instructions().size());
@@ -1233,7 +1233,7 @@ RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, co
 
 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, const Identifier& property, RegisterID* value)
 {
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     m_codeBlock->addStructureStubInfo(StructureStubInfo(access_put_by_id));
 #else
     m_codeBlock->addPropertyAccessInstruction(instructions().size());
@@ -1437,14 +1437,14 @@ RegisterID* BytecodeGenerator::emitCall(OpcodeID opcodeID, RegisterID* dst, Regi
         emitOpcode(op_profile_will_call);
         instructions().append(func->index());
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         m_codeBlock->addFunctionRegisterInfo(instructions().size(), func->index());
 #endif
     }
 
     emitExpressionInfo(divot, startOffset, endOffset);
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     m_codeBlock->addCallLinkInfo();
 #endif
 
@@ -1486,7 +1486,7 @@ RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func
         emitOpcode(op_profile_will_call);
         instructions().append(func->index());
         
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         m_codeBlock->addFunctionRegisterInfo(instructions().size(), func->index());
 #endif
     }
@@ -1568,7 +1568,7 @@ RegisterID* BytecodeGenerator::emitConstruct(RegisterID* dst, RegisterID* func,
 
     emitExpressionInfo(divot, startOffset, endOffset);
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     m_codeBlock->addCallLinkInfo();
 #endif
 
@@ -1834,7 +1834,7 @@ RegisterID* BytecodeGenerator::emitNextPropertyName(RegisterID* dst, RegisterID*
 
 RegisterID* BytecodeGenerator::emitCatch(RegisterID* targetRegister, Label* start, Label* end)
 {
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     HandlerInfo info = { start->bind(0, 0), end->bind(0, 0), instructions().size(), m_dynamicScopeDepth + m_baseScopeDepth, CodeLocationLabel() };
 #else
     HandlerInfo info = { start->bind(0, 0), end->bind(0, 0), instructions().size(), m_dynamicScopeDepth + m_baseScopeDepth };
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/config.h b/src/3rdparty/javascriptcore/JavaScriptCore/config.h
index 2af2e71..aad7378 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/config.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/config.h
@@ -25,7 +25,7 @@
 
 #include <wtf/Platform.h>
 
-#if !defined(QT_BUILD_SCRIPT_LIB) && OS(WINDOWS) && !defined(BUILDING_WX__) && !COMPILER(GCC)
+#if !defined(QT_BUILD_SCRIPT_LIB) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && !defined(BUILDING_WX__) && !(defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #if defined(BUILDING_JavaScriptCore) || defined(BUILDING_WTF)
 #define JS_EXPORTDATA __declspec(dllexport)
 #else
@@ -37,14 +37,14 @@
 #define JS_EXPORTCLASS
 #endif
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
 // If we don't define these, they get defined in windef.h. 
 // We want to use std::min and std::max
 #define max max
 #define min min
 
-#if !COMPILER(MSVC7) && !OS(WINCE)
+#if !(defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7) && !(defined WTF_OS_WINCE && WTF_OS_WINCE)
 // We need to define this before the first #include of stdlib.h or it won't contain rand_s.
 #ifndef _CRT_RAND_S
 #define _CRT_RAND_S
@@ -53,7 +53,7 @@
 
 #endif
 
-#if OS(FREEBSD) || OS(OPENBSD)
+#if (defined WTF_OS_FREEBSD && WTF_OS_FREEBSD) || (defined WTF_OS_OPENBSD && WTF_OS_OPENBSD)
 #define HAVE_PTHREAD_NP_H 1
 #endif
 
@@ -71,15 +71,15 @@
 // this breaks compilation of <QFontDatabase>, at least, so turn it off for now
 // Also generates errors on wx on Windows, because these functions
 // are used from wx headers. 
-#if !PLATFORM(QT) && !PLATFORM(WX)
+#if !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) && !(defined WTF_PLATFORM_WX && WTF_PLATFORM_WX)
 #include <wtf/DisallowCType.h>
 #endif
 
-#if PLATFORM(CHROMIUM)
+#if (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM)
 #if !defined(WTF_USE_V8)
 #define WTF_USE_V8 1
 #endif
-#endif /* PLATFORM(CHROMIUM) */
+#endif /* (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM) */
 
 #if !defined(WTF_USE_V8)
 #define WTF_USE_V8 0
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/debugger/Debugger.h b/src/3rdparty/javascriptcore/JavaScriptCore/debugger/Debugger.h
index 3725478..6174a44 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/debugger/Debugger.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/debugger/Debugger.h
@@ -41,7 +41,7 @@ namespace JSC {
         void attach(JSGlobalObject*);
         virtual void detach(JSGlobalObject*);
 
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #ifdef QT_BUILD_SCRIPT_LIB
         virtual void scriptUnload(QT_PREPEND_NAMESPACE(qint64) id)
         {
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/generated/Grammar.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/generated/Grammar.cpp
index 31c2068..d7ebd16 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/generated/Grammar.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/generated/Grammar.cpp
@@ -120,7 +120,7 @@
 // Default values for bison.
 #define YYDEBUG 0 // Set to 1 to debug a parse error.
 #define jscyydebug 0 // Set to 1 to debug a parse error.
-#if !OS(DARWIN)
+#if !(defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 // Avoid triggering warnings in older bison by not setting this on the Darwin platform.
 // FIXME: Is this still needed?
 #define YYERROR_VERBOSE
@@ -155,7 +155,7 @@ static ExpressionNode* makeRightShiftNode(JSGlobalData*, ExpressionNode* left, E
 static StatementNode* makeVarStatementNode(JSGlobalData*, ExpressionNode*);
 static ExpressionNode* combineCommaNodes(JSGlobalData*, ExpressionNode* list, ExpressionNode* init);
 
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 
 #pragma warning(disable: 4065)
 #pragma warning(disable: 4244)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Interpreter.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Interpreter.cpp
index 187d409..e33a981 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Interpreter.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Interpreter.cpp
@@ -62,7 +62,7 @@
 #include <stdio.h>
 #include <wtf/Threading.h>
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 #include "JIT.h"
 #endif
 
@@ -76,7 +76,7 @@ namespace JSC {
 
 static ALWAYS_INLINE unsigned bytecodeOffsetForPC(CallFrame* callFrame, CodeBlock* codeBlock, void* pc)
 {
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     return codeBlock->getBytecodeIndex(callFrame, ReturnAddressPtr(pc));
 #else
     UNUSED_PARAM(callFrame);
@@ -92,7 +92,7 @@ static int depth(CodeBlock* codeBlock, ScopeChain& sc)
     return sc.localDepth();
 }
 
-#if USE(INTERPRETER)
+#if (defined WTF_USE_INTERPRETER && WTF_USE_INTERPRETER)
 NEVER_INLINE bool Interpreter::resolve(CallFrame* callFrame, Instruction* vPC, JSValue& exceptionValue)
 {
     int dst = vPC[1].u.operand;
@@ -237,7 +237,7 @@ NEVER_INLINE bool Interpreter::resolveBaseAndProperty(CallFrame* callFrame, Inst
     return false;
 }
 
-#endif // USE(INTERPRETER)
+#endif // (defined WTF_USE_INTERPRETER && WTF_USE_INTERPRETER)
 
 ALWAYS_INLINE CallFrame* Interpreter::slideRegisterWindowForCall(CodeBlock* newCodeBlock, RegisterFile* registerFile, CallFrame* callFrame, size_t registerOffset, int argc)
 {
@@ -276,7 +276,7 @@ ALWAYS_INLINE CallFrame* Interpreter::slideRegisterWindowForCall(CodeBlock* newC
     return CallFrame::create(r);
 }
 
-#if USE(INTERPRETER)
+#if (defined WTF_USE_INTERPRETER && WTF_USE_INTERPRETER)
 static NEVER_INLINE bool isInvalidParamForIn(CallFrame* callFrame, CodeBlock* codeBlock, const Instruction* vPC, JSValue value, JSValue& exceptionData)
 {
     if (value.isObject())
@@ -325,14 +325,14 @@ Interpreter::Interpreter()
     : m_sampleEntryDepth(0)
     , m_reentryDepth(0)
 {
-#if HAVE(COMPUTED_GOTO)
+#if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
     privateExecute(InitializeAndReturn, 0, 0, 0);
 
     for (int i = 0; i < numOpcodeIDs; ++i)
         m_opcodeIDTable.add(m_opcodeTable[i], static_cast<OpcodeID>(i));
-#endif // HAVE(COMPUTED_GOTO)
+#endif // (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
 
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     enableSampler();
 #endif
 }
@@ -363,7 +363,7 @@ void Interpreter::dumpRegisters(CallFrame* callFrame)
         end = it + registerFile->numGlobals();
         while (it != end) {
             v = (*it).jsValue();
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
             printf("[global var]               | %10p | %-16s 0x%llx \n", it, v.description(), JSValue::encode(v));
 #else
             printf("[global var]               | %10p | %-16s %p \n", it, v.description(), JSValue::encode(v));
@@ -375,7 +375,7 @@ void Interpreter::dumpRegisters(CallFrame* callFrame)
     
     it = callFrame->registers() - RegisterFile::CallFrameHeaderSize - codeBlock->m_numParameters;
     v = (*it).jsValue();
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     printf("[this]                     | %10p | %-16s 0x%llx \n", it, v.description(), JSValue::encode(v)); ++it;
 #else
     printf("[this]                     | %10p | %-16s %p \n", it, v.description(), JSValue::encode(v)); ++it;
@@ -384,7 +384,7 @@ void Interpreter::dumpRegisters(CallFrame* callFrame)
     if (it != end) {
         do {
             v = (*it).jsValue();
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
             printf("[param]                    | %10p | %-16s 0x%llx \n", it, v.description(), JSValue::encode(v));
 #else
             printf("[param]                    | %10p | %-16s %p \n", it, v.description(), JSValue::encode(v));
@@ -409,7 +409,7 @@ void Interpreter::dumpRegisters(CallFrame* callFrame)
     if (it != end) {
         do {
             v = (*it).jsValue();
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
             printf("[r%2d]                      | %10p | %-16s 0x%llx \n", registerCount, it, v.description(), JSValue::encode(v));
 #else
             printf("[r%2d]                      | %10p | %-16s %p \n", registerCount, it, v.description(), JSValue::encode(v));
@@ -424,7 +424,7 @@ void Interpreter::dumpRegisters(CallFrame* callFrame)
     if (it != end) {
         do {
             v = (*it).jsValue();
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
             printf("[r%2d]                      | %10p | %-16s 0x%llx \n", registerCount, it, v.description(), JSValue::encode(v));
 #else
             printf("[r%2d]                      | %10p | %-16s %p \n", registerCount, it, v.description(), JSValue::encode(v));
@@ -440,7 +440,7 @@ void Interpreter::dumpRegisters(CallFrame* callFrame)
 
 bool Interpreter::isOpcode(Opcode opcode)
 {
-#if HAVE(COMPUTED_GOTO)
+#if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
     return opcode != HashTraits<Opcode>::emptyValue()
         && !HashTraits<Opcode>::isDeletedValue(opcode)
         && m_opcodeIDTable.contains(opcode);
@@ -549,7 +549,7 @@ NEVER_INLINE HandlerInfo* Interpreter::throwException(CallFrame*& callFrame, JSV
     // the profiler manually that the call instruction has returned, since
     // we'll never reach the relevant op_profile_did_call.
     if (Profiler* profiler = *Profiler::enabledProfilerReference()) {
-#if !ENABLE(JIT)
+#if !(defined ENABLE_JIT && ENABLE_JIT)
         if (isCallBytecode(codeBlock->instructions()[bytecodeOffset].u.opcode))
             profiler->didExecute(callFrame, callFrame->r(codeBlock->instructions()[bytecodeOffset + 2].u.operand).jsValue());
         else if (codeBlock->instructions().size() > (bytecodeOffset + 8) && codeBlock->instructions()[bytecodeOffset + 8].u.opcode == getOpcode(op_construct))
@@ -646,7 +646,7 @@ JSValue Interpreter::execute(ProgramExecutable* program, CallFrame* callFrame, S
         SamplingTool::CallRecord callRecord(m_sampler.get());
 
         m_reentryDepth++;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         result = program->jitCode(newCallFrame, scopeChain).execute(&m_registerFile, newCallFrame, scopeChain->globalData, exception);
 #else
         result = privateExecute(Normal, &m_registerFile, newCallFrame, exception);
@@ -712,7 +712,7 @@ JSValue Interpreter::execute(FunctionExecutable* functionExecutable, CallFrame*
         SamplingTool::CallRecord callRecord(m_sampler.get());
 
         m_reentryDepth++;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         result = functionExecutable->jitCode(newCallFrame, scopeChain).execute(&m_registerFile, newCallFrame, scopeChain->globalData, exception);
 #else
         result = privateExecute(Normal, &m_registerFile, newCallFrame, exception);
@@ -760,7 +760,7 @@ CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* FunctionE
     }
     // a 0 codeBlock indicates a built-in caller
     newCallFrame->init(codeBlock, 0, scopeChain, callFrame->addHostCallFrameFlag(), 0, argc, function);
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     FunctionExecutable->jitCode(newCallFrame, scopeChain);
 #endif
 
@@ -780,7 +780,7 @@ JSValue Interpreter::execute(CallFrameClosure& closure, JSValue* exception)
         SamplingTool::CallRecord callRecord(m_sampler.get());
         
         m_reentryDepth++;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         result = closure.functionExecutable->generatedJITCode().execute(&m_registerFile, closure.newCallFrame, closure.globalData, exception);
 #else
         result = privateExecute(Normal, &m_registerFile, closure.newCallFrame, exception);
@@ -882,7 +882,7 @@ JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSObjec
         SamplingTool::CallRecord callRecord(m_sampler.get());
 
         m_reentryDepth++;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         result = eval->jitCode(newCallFrame, scopeChain).execute(&m_registerFile, newCallFrame, scopeChain->globalData, exception);
 #else
         result = privateExecute(Normal, &m_registerFile, newCallFrame, exception);
@@ -925,7 +925,7 @@ NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookID debugHook
     }
 }
     
-#if USE(INTERPRETER)
+#if (defined WTF_USE_INTERPRETER && WTF_USE_INTERPRETER)
 NEVER_INLINE ScopeChainNode* Interpreter::createExceptionScope(CallFrame* callFrame, const Instruction* vPC)
 {
     int dst = vPC[1].u.operand;
@@ -1124,28 +1124,28 @@ NEVER_INLINE void Interpreter::uncacheGetByID(CodeBlock* codeBlock, Instruction*
     vPC[4] = 0;
 }
 
-#endif // USE(INTERPRETER)
+#endif // (defined WTF_USE_INTERPRETER && WTF_USE_INTERPRETER)
 
 JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFile, CallFrame* callFrame, JSValue* exception)
 {
     // One-time initialization of our address tables. We have to put this code
     // here because our labels are only in scope inside this function.
     if (UNLIKELY(flag == InitializeAndReturn)) {
-        #if HAVE(COMPUTED_GOTO)
+        #if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
             #define LIST_OPCODE_LABEL(id, length) &&id,
                 static Opcode labels[] = { FOR_EACH_OPCODE_ID(LIST_OPCODE_LABEL) };
                 for (size_t i = 0; i < sizeof(labels) / sizeof(Opcode); ++i)
                     m_opcodeTable[i] = labels[i];
             #undef LIST_OPCODE_LABEL
-        #endif // HAVE(COMPUTED_GOTO)
+        #endif // (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
         return JSValue();
     }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     // Mixing Interpreter + JIT is not supported.
     ASSERT_NOT_REACHED();
 #endif
-#if !USE(INTERPRETER)
+#if !(defined WTF_USE_INTERPRETER && WTF_USE_INTERPRETER)
     UNUSED_PARAM(registerFile);
     UNUSED_PARAM(callFrame);
     UNUSED_PARAM(exception);
@@ -1168,7 +1168,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
         } \
     } while (0)
 
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
     OpcodeStats::resetLastInstruction();
 #endif
 
@@ -1182,15 +1182,15 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
         CHECK_FOR_EXCEPTION(); \
     }
     
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     #define SAMPLE(codeBlock, vPC) m_sampler->sample(codeBlock, vPC)
 #else
     #define SAMPLE(codeBlock, vPC)
 #endif
 
-#if HAVE(COMPUTED_GOTO)
+#if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
     #define NEXT_INSTRUCTION() SAMPLE(callFrame->codeBlock(), vPC); goto *vPC->u.opcode
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
     #define DEFINE_OPCODE(opcode) opcode: OpcodeStats::recordInstruction(opcode);
 #else
     #define DEFINE_OPCODE(opcode) opcode:
@@ -1198,7 +1198,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
     NEXT_INSTRUCTION();
 #else
     #define NEXT_INSTRUCTION() SAMPLE(callFrame->codeBlock(), vPC); goto interpreterLoopStart
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
     #define DEFINE_OPCODE(opcode) case opcode: OpcodeStats::recordInstruction(opcode);
 #else
     #define DEFINE_OPCODE(opcode) case opcode:
@@ -2654,7 +2654,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
            Additionally this loop instruction may terminate JS execution is
            the JS timeout is reached.
          */
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
         OpcodeStats::resetLastInstruction();
 #endif
         int target = vPC[1].u.operand;
@@ -2668,7 +2668,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
            Jumps unconditionally to offset target from the current
            instruction.
         */
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
         OpcodeStats::resetLastInstruction();
 #endif
         int target = vPC[1].u.operand;
@@ -3112,7 +3112,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
             callFrame->init(newCodeBlock, vPC + 5, callDataScopeChain, previousCallFrame, dst, argCount, asFunction(v));
             vPC = newCodeBlock->instructions().begin();
 
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
             OpcodeStats::resetLastInstruction();
 #endif
 
@@ -3269,7 +3269,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
             callFrame->init(newCodeBlock, vPC + 5, callDataScopeChain, previousCallFrame, dst, argCount, asFunction(v));
             vPC = newCodeBlock->instructions().begin();
             
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
             OpcodeStats::resetLastInstruction();
 #endif
             
@@ -3544,7 +3544,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
             callFrame->init(newCodeBlock, vPC + 7, callDataScopeChain, previousCallFrame, dst, argCount, asFunction(v));
             vPC = newCodeBlock->instructions().begin();
 
-#if ENABLE(OPCODE_STATS)
+#if (defined ENABLE_OPCODE_STATS && ENABLE_OPCODE_STATS)
             OpcodeStats::resetLastInstruction();
 #endif
 
@@ -3726,7 +3726,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
         vPC += target;
         NEXT_INSTRUCTION();
     }
-#if HAVE(COMPUTED_GOTO)
+#if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
     // Appease GCC
     goto *(&&skip_new_scope);
 #endif
@@ -3742,7 +3742,7 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
         vPC += OPCODE_LENGTH(op_push_new_scope);
         NEXT_INSTRUCTION();
     }
-#if HAVE(COMPUTED_GOTO)
+#if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
     skip_new_scope:
 #endif
     DEFINE_OPCODE(op_catch) {
@@ -3963,10 +3963,10 @@ JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFi
         NEXT_INSTRUCTION();
     }
     }
-#if !HAVE(COMPUTED_GOTO)
+#if !(defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
     } // iterator loop ends
 #endif
-#endif // USE(INTERPRETER)
+#endif // (defined WTF_USE_INTERPRETER && WTF_USE_INTERPRETER)
     #undef NEXT_INSTRUCTION
     #undef DEFINE_OPCODE
     #undef CHECK_FOR_EXCEPTION
@@ -4051,7 +4051,7 @@ CallFrame* Interpreter::findFunctionCallFrame(CallFrame* callFrame, InternalFunc
 
 void Interpreter::enableSampler()
 {
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     if (!m_sampler) {
         m_sampler.set(new SamplingTool(this));
         m_sampler->setup();
@@ -4060,7 +4060,7 @@ void Interpreter::enableSampler()
 }
 void Interpreter::dumpSampleData(ExecState* exec)
 {
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     if (m_sampler)
         m_sampler->dump(exec);
 #else
@@ -4069,7 +4069,7 @@ void Interpreter::dumpSampleData(ExecState* exec)
 }
 void Interpreter::startSampling()
 {
-#if ENABLE(SAMPLING_THREAD)
+#if (defined ENABLE_SAMPLING_THREAD && ENABLE_SAMPLING_THREAD)
     if (!m_sampleEntryDepth)
         SamplingThread::start();
 
@@ -4078,7 +4078,7 @@ void Interpreter::startSampling()
 }
 void Interpreter::stopSampling()
 {
-#if ENABLE(SAMPLING_THREAD)
+#if (defined ENABLE_SAMPLING_THREAD && ENABLE_SAMPLING_THREAD)
     m_sampleEntryDepth--;
     if (!m_sampleEntryDepth)
         SamplingThread::stop();
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Interpreter.h b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Interpreter.h
index e17b055..118571c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Interpreter.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Interpreter.h
@@ -76,7 +76,7 @@ namespace JSC {
         
         Opcode getOpcode(OpcodeID id)
         {
-            #if HAVE(COMPUTED_GOTO)
+            #if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
                 return m_opcodeTable[id];
             #else
                 return id;
@@ -85,7 +85,7 @@ namespace JSC {
 
         OpcodeID getOpcodeID(Opcode opcode)
         {
-            #if HAVE(COMPUTED_GOTO)
+            #if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
                 ASSERT(isOpcode(opcode));
                 return m_opcodeIDTable.get(opcode);
             #else
@@ -123,7 +123,7 @@ namespace JSC {
 
         JSValue execute(EvalExecutable*, CallFrame*, JSObject* thisObject, int globalRegisterOffset, ScopeChainNode*, JSValue* exception);
 
-#if USE(INTERPRETER)
+#if (defined WTF_USE_INTERPRETER && WTF_USE_INTERPRETER)
         NEVER_INLINE bool resolve(CallFrame*, Instruction*, JSValue& exceptionValue);
         NEVER_INLINE bool resolveSkip(CallFrame*, Instruction*, JSValue& exceptionValue);
         NEVER_INLINE bool resolveGlobal(CallFrame*, Instruction*, JSValue& exceptionValue);
@@ -158,7 +158,7 @@ namespace JSC {
 
         RegisterFile m_registerFile;
         
-#if HAVE(COMPUTED_GOTO)
+#if (defined HAVE_COMPUTED_GOTO && HAVE_COMPUTED_GOTO)
         Opcode m_opcodeTable[numOpcodeIDs]; // Maps OpcodeID => Opcode for compiling
         HashMap<Opcode, OpcodeID> m_opcodeIDTable; // Maps Opcode => OpcodeID for decompiling
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Register.h b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Register.h
index 3486fa7..bf9782c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Register.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/Register.h
@@ -104,7 +104,7 @@ namespace JSC {
 
     ALWAYS_INLINE Register::Register(const JSValue& v)
     {
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         ASSERT(!v.isZombie());
 #endif
         u.value = JSValue::encode(v);
@@ -112,7 +112,7 @@ namespace JSC {
 
     ALWAYS_INLINE Register& Register::operator=(const JSValue& v)
     {
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         ASSERT(!v.isZombie());
 #endif
         u.value = JSValue::encode(v);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/RegisterFile.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/RegisterFile.cpp
index ef4f525..22f1c1f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/RegisterFile.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/RegisterFile.cpp
@@ -33,14 +33,14 @@ namespace JSC {
 
 RegisterFile::~RegisterFile()
 {
-#if HAVE(MMAP)
+#if (defined HAVE_MMAP && HAVE_MMAP)
     munmap(reinterpret_cast<char*>(m_buffer), ((m_max - m_start) + m_maxGlobals) * sizeof(Register));
-#elif HAVE(VIRTUALALLOC)
-#if OS(WINCE)
+#elif (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
     VirtualFree(m_buffer, DWORD(m_commitEnd) - DWORD(m_buffer), MEM_DECOMMIT);
 #endif
     VirtualFree(m_buffer, 0, MEM_RELEASE);
-#elif OS(SYMBIAN)
+#elif (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     delete m_registerFileAllocator;
 #else
     fastFree(m_buffer);
@@ -49,7 +49,7 @@ RegisterFile::~RegisterFile()
 
 void RegisterFile::releaseExcessCapacity()
 {
-#if OS(QNX)
+#if (defined WTF_OS_QNX && WTF_OS_QNX)
     size_t sizeForGlobals = roundUpAllocationSize(m_maxGlobals * sizeof(Register), commitSize);
     Register *endOfGlobals = reinterpret_cast<Register*>(reinterpret_cast<char*>(m_buffer) + sizeForGlobals);
     size_t decommitSize = (m_max - endOfGlobals) * sizeof(Register);
@@ -59,9 +59,9 @@ void RegisterFile::releaseExcessCapacity()
     }
     m_commitEnd = endOfGlobals;
 
-#elif HAVE(MMAP) && HAVE(MADV_FREE) && !HAVE(VIRTUALALLOC)
+#elif (defined HAVE_MMAP && HAVE_MMAP) && (defined HAVE_MADV_FREE && HAVE_MADV_FREE) && !(defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
     while (madvise(m_start, (m_max - m_start) * sizeof(Register), MADV_FREE) == -1 && errno == EAGAIN) { }
-#elif HAVE(VIRTUALALLOC)
+#elif (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
     VirtualFree(m_start, (m_max - m_start) * sizeof(Register), MEM_DECOMMIT);
     m_commitEnd = m_start;
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/RegisterFile.h b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/RegisterFile.h
index 0b7731c..8b37f99 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/RegisterFile.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/interpreter/RegisterFile.h
@@ -36,12 +36,12 @@
 #include <wtf/Noncopyable.h>
 #include <wtf/VMTags.h>
 
-#if HAVE(MMAP)
+#if (defined HAVE_MMAP && HAVE_MMAP)
 #include <errno.h>
 #include <sys/mman.h>
 #endif
 
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 #include <wtf/symbian/RegisterFileAllocatorSymbian.h>
 #endif
 
@@ -153,10 +153,10 @@ namespace JSC {
         Register* m_buffer;
         Register* m_maxUsed;
 
-#if HAVE(VIRTUALALLOC) || OS(QNX)
+#if (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC) || (defined WTF_OS_QNX && WTF_OS_QNX)
         Register* m_commitEnd;
 #endif
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
         // Commits and frees a continguous chunk of memory as required
         WTF::RegisterFileAllocator* m_registerFileAllocator;
 #endif
@@ -166,7 +166,7 @@ namespace JSC {
 
     // FIXME: Add a generic getpagesize() to WTF, then move this function to WTF as well.
     // This is still a hack that should be fixed later. We know that a Symbian page size is 4K.
-    #if OS(SYMBIAN)
+    #if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     inline bool isPageAligned(size_t size) { return size && !(size % (4 * 1024)); }
     #else
     inline bool isPageAligned(size_t size) { return size && !(size % (8 * 1024)); }
@@ -186,7 +186,7 @@ namespace JSC {
         ASSERT(isPageAligned(capacity));
 
         size_t bufferLength = (capacity + maxGlobals) * sizeof(Register);
-    #if OS(QNX)
+    #if (defined WTF_OS_QNX && WTF_OS_QNX)
         // First, reserve uncommitted memory
         m_buffer = reinterpret_cast<Register*>(mmap(0, bufferLength, PROT_NONE, MAP_LAZY|MAP_PRIVATE|MAP_ANON, VM_TAG_FOR_REGISTERFILE_MEMORY, 0));
         if (m_buffer == MAP_FAILED) {
@@ -202,20 +202,20 @@ namespace JSC {
         }
         m_commitEnd = reinterpret_cast<Register*>(reinterpret_cast<char*>(m_buffer) + committedSize);
 
-    #elif HAVE(MMAP)
+    #elif (defined HAVE_MMAP && HAVE_MMAP)
         m_buffer = reinterpret_cast<Register*>(mmap(0, bufferLength, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, VM_TAG_FOR_REGISTERFILE_MEMORY, 0));
         if (m_buffer == MAP_FAILED) {
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
             fprintf(stderr, "Could not allocate register file: %d\n", GetLastError());
 #else
             fprintf(stderr, "Could not allocate register file: %d\n", errno);
 #endif
             CRASH();
         }
-    #elif HAVE(VIRTUALALLOC)
+    #elif (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
         m_buffer = static_cast<Register*>(VirtualAlloc(0, roundUpAllocationSize(bufferLength, commitSize), MEM_RESERVE, PAGE_READWRITE));
         if (!m_buffer) {
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
             fprintf(stderr, "Could not allocate register file: %d\n", GetLastError());
 #else
             fprintf(stderr, "Could not allocate register file: %d\n", errno);
@@ -225,7 +225,7 @@ namespace JSC {
         size_t committedSize = roundUpAllocationSize(maxGlobals * sizeof(Register), commitSize);
         void* commitCheck = VirtualAlloc(m_buffer, committedSize, MEM_COMMIT, PAGE_READWRITE);
         if (commitCheck != m_buffer) {
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
             fprintf(stderr, "Could not allocate register file: %d\n", GetLastError());
 #else
             fprintf(stderr, "Could not allocate register file: %d\n", errno);
@@ -233,7 +233,7 @@ namespace JSC {
             CRASH();
         }
         m_commitEnd = reinterpret_cast<Register*>(reinterpret_cast<char*>(m_buffer) + committedSize);
-    #elif OS(SYMBIAN)
+    #elif (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
         m_registerFileAllocator = new WTF::RegisterFileAllocator(bufferLength);
         m_buffer = (Register*)(m_registerFileAllocator->buffer());
         // start by committing enough space to hold maxGlobals
@@ -262,7 +262,7 @@ namespace JSC {
             return;
         m_end = newEnd;
         if (m_end == m_start && (m_maxUsed - m_start) > maxExcessCapacity) {
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
             m_registerFileAllocator->shrink(newEnd);
 #endif
 
@@ -278,7 +278,7 @@ namespace JSC {
         if (newEnd > m_max)
             return false;
 
-#if OS(QNX)
+#if (defined WTF_OS_QNX && WTF_OS_QNX)
         if (newEnd > m_commitEnd) {
             size_t size = roundUpAllocationSize(reinterpret_cast<char*>(newEnd) - reinterpret_cast<char*>(m_commitEnd), commitSize);
             if (mmap(m_commitEnd, size, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE|MAP_ANON, VM_TAG_FOR_REGISTERFILE_MEMORY, 0) == MAP_FAILED) {
@@ -287,11 +287,11 @@ namespace JSC {
             }
             m_commitEnd = reinterpret_cast<Register*>(reinterpret_cast<char*>(m_commitEnd) + size);
         }
-#elif !HAVE(MMAP) && HAVE(VIRTUALALLOC)
+#elif !(defined HAVE_MMAP && HAVE_MMAP) && (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
         if (newEnd > m_commitEnd) {
             size_t size = roundUpAllocationSize(reinterpret_cast<char*>(newEnd) - reinterpret_cast<char*>(m_commitEnd), commitSize);
             if (!VirtualAlloc(m_commitEnd, size, MEM_COMMIT, PAGE_READWRITE)) {
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
                 fprintf(stderr, "Could not allocate register file: %d\n", GetLastError());
 #else
                 fprintf(stderr, "Could not allocate register file: %d\n", errno);
@@ -301,7 +301,7 @@ namespace JSC {
             m_commitEnd = reinterpret_cast<Register*>(reinterpret_cast<char*>(m_commitEnd) + size);
         }
 #endif
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
         m_registerFileAllocator->grow((void*)newEnd);
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocator.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocator.cpp
index f0ebbab..f55432f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocator.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocator.cpp
@@ -27,13 +27,13 @@
 
 #include "ExecutableAllocator.h"
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 namespace JSC {
 
 size_t ExecutableAllocator::pageSize = 0;
 
-#if ENABLE(ASSEMBLER_WX_EXCLUSIVE)
+#if (defined ENABLE_ASSEMBLER_WX_EXCLUSIVE && ENABLE_ASSEMBLER_WX_EXCLUSIVE)
 void ExecutableAllocator::reprotectRegion(void* start, size_t size, ProtectionSeting setting)
 {
     if (!pageSize)
@@ -56,4 +56,4 @@ void ExecutableAllocator::reprotectRegion(void* start, size_t size, ProtectionSe
 
 }
 
-#endif // HAVE(ASSEMBLER)
+#endif // (defined HAVE_ASSEMBLER && HAVE_ASSEMBLER)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocator.h b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocator.h
index 1fb8ff7..7e41c27 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocator.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocator.h
@@ -34,16 +34,16 @@
 #include <wtf/UnusedParam.h>
 #include <wtf/Vector.h>
 
-#if OS(IPHONE_OS)
+#if (defined WTF_OS_IPHONE_OS && WTF_OS_IPHONE_OS)
 #include <libkern/OSCacheControl.h>
 #include <sys/mman.h>
 #endif
 
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 #include <e32std.h>
 #endif
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 // From pkfuncs.h (private header file from the Platform Builder)
 #define CACHE_SYNC_ALL 0x07F
 extern "C" __declspec(dllimport) void CacheRangeFlush(LPVOID pAddr, DWORD dwLength, DWORD dwFlags);
@@ -52,7 +52,7 @@ extern "C" __declspec(dllimport) void CacheRangeFlush(LPVOID pAddr, DWORD dwLeng
 #define JIT_ALLOCATOR_PAGE_SIZE (ExecutableAllocator::pageSize)
 #define JIT_ALLOCATOR_LARGE_ALLOC_SIZE (ExecutableAllocator::pageSize * 4)
 
-#if ENABLE(ASSEMBLER_WX_EXCLUSIVE)
+#if (defined ENABLE_ASSEMBLER_WX_EXCLUSIVE && ENABLE_ASSEMBLER_WX_EXCLUSIVE)
 #define PROTECTION_FLAGS_RW (PROT_READ | PROT_WRITE)
 #define PROTECTION_FLAGS_RX (PROT_READ | PROT_EXEC)
 #define INITIAL_PROTECTION_FLAGS PROTECTION_FLAGS_RX
@@ -76,7 +76,7 @@ inline size_t roundUpAllocationSize(size_t request, size_t granularity)
 
 }
 
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 namespace JSC {
 
@@ -85,7 +85,7 @@ private:
     struct Allocation {
         char* pages;
         size_t size;
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
         RChunk* chunk;
 #endif
     };
@@ -170,7 +170,7 @@ public:
         return pool.release();
     }
 
-#if ENABLE(ASSEMBLER_WX_EXCLUSIVE)
+#if (defined ENABLE_ASSEMBLER_WX_EXCLUSIVE && ENABLE_ASSEMBLER_WX_EXCLUSIVE)
     static void makeWritable(void* start, size_t size)
     {
         reprotectRegion(start, size, Writable);
@@ -186,17 +186,17 @@ public:
 #endif
 
 
-#if CPU(X86) || CPU(X86_64)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     static void cacheFlush(void*, size_t)
     {
     }
-#elif CPU(ARM_THUMB2) && OS(IPHONE_OS)
+#elif (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2) && (defined WTF_OS_IPHONE_OS && WTF_OS_IPHONE_OS)
     static void cacheFlush(void* code, size_t size)
     {
         sys_dcache_flush(code, size);
         sys_icache_invalidate(code, size);
     }
-#elif CPU(ARM_THUMB2) && OS(LINUX)
+#elif (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2) && (defined WTF_OS_LINUX && WTF_OS_LINUX)
     static void cacheFlush(void* code, size_t size)
     {
         asm volatile (
@@ -212,12 +212,12 @@ public:
             : "r" (code), "r" (reinterpret_cast<char*>(code) + size)
             : "r0", "r1", "r2");
     }
-#elif OS(SYMBIAN)
+#elif (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     static void cacheFlush(void* code, size_t size)
     {
         User::IMB_Range(code, static_cast<char*>(code) + size);
     }
-#elif CPU(ARM_TRADITIONAL) && OS(LINUX)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL) && (defined WTF_OS_LINUX && WTF_OS_LINUX)
     static void cacheFlush(void* code, size_t size)
     {
         asm volatile (
@@ -233,7 +233,7 @@ public:
             : "r" (code), "r" (reinterpret_cast<char*>(code) + size)
             : "r0", "r1", "r2");
     }
-#elif OS(WINCE)
+#elif (defined WTF_OS_WINCE && WTF_OS_WINCE)
     static void cacheFlush(void* code, size_t size)
     {
         CacheRangeFlush(code, size, CACHE_SYNC_ALL);
@@ -244,7 +244,7 @@ public:
 
 private:
 
-#if ENABLE(ASSEMBLER_WX_EXCLUSIVE)
+#if (defined ENABLE_ASSEMBLER_WX_EXCLUSIVE && ENABLE_ASSEMBLER_WX_EXCLUSIVE)
     static void reprotectRegion(void*, size_t, ProtectionSeting);
 #endif
 
@@ -284,6 +284,6 @@ inline void* ExecutablePool::poolAllocate(size_t n)
 
 }
 
-#endif // ENABLE(ASSEMBLER)
+#endif // (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
 
 #endif // !defined(ExecutableAllocator)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorFixedVMPool.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorFixedVMPool.cpp
index 5233923..5edc93d 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorFixedVMPool.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorFixedVMPool.cpp
@@ -27,7 +27,7 @@
 
 #include "ExecutableAllocator.h"
 
-#if ENABLE(EXECUTABLE_ALLOCATOR_FIXED)
+#if (defined ENABLE_EXECUTABLE_ALLOCATOR_FIXED && ENABLE_EXECUTABLE_ALLOCATOR_FIXED)
 
 #include <errno.h>
 
@@ -37,7 +37,7 @@
 #include <wtf/AVLTree.h>
 #include <wtf/VMTags.h>
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     // These limits suitable on 64-bit platforms (particularly x86-64, where we require all jumps to have a 2Gb max range).
 #ifdef QT_USE_ONEGB_VMALLOCATOR
     #define VM_POOL_SIZE (1024u * 1024u * 1024u) // 1Gb
@@ -52,7 +52,7 @@
 #endif
 
 // ASLR currently only works on darwin (due to arc4random) & 64-bit (due to address space size).
-#define VM_POOL_ASLR (OS(DARWIN) && CPU(X86_64))
+#define VM_POOL_ASLR ((defined WTF_OS_DARWIN && WTF_OS_DARWIN) && (defined WTF_CPU_X86_64 && WTF_CPU_X86_64))
 
 using namespace WTF;
 
@@ -130,7 +130,7 @@ class FixedVMPoolAllocator
 
     // Use madvise as apropriate to prevent freed pages from being spilled,
     // and to attempt to ensure that used memory is reported correctly.
-#if HAVE(MADV_FREE_REUSE)
+#if (defined HAVE_MADV_FREE_REUSE && HAVE_MADV_FREE_REUSE)
     void release(void* position, size_t size)
     {
         while (madvise(position, size, MADV_FREE_REUSABLE) == -1 && errno == EAGAIN) { }
@@ -140,7 +140,7 @@ class FixedVMPoolAllocator
     {
         while (madvise(position, size, MADV_FREE_REUSE) == -1 && errno == EAGAIN) { }
     }
-#elif HAVE(MADV_DONTNEED)
+#elif (defined HAVE_MADV_DONTNEED && HAVE_MADV_DONTNEED)
     void release(void* position, size_t size)
     {
         while (madvise(position, size, MADV_DONTNEED) == -1 && errno == EAGAIN) { }
@@ -459,4 +459,4 @@ void ExecutablePool::systemRelease(const ExecutablePool::Allocation& allocation)
 
 }
 
-#endif // HAVE(ASSEMBLER)
+#endif // (defined HAVE_ASSEMBLER && HAVE_ASSEMBLER)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorPosix.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorPosix.cpp
index b04049c..60155a9 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorPosix.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorPosix.cpp
@@ -27,7 +27,7 @@
 
 #include "ExecutableAllocator.h"
 
-#if ENABLE(EXECUTABLE_ALLOCATOR_DEMAND) && !OS(WINDOWS) && !OS(SYMBIAN)
+#if (defined ENABLE_EXECUTABLE_ALLOCATOR_DEMAND && ENABLE_EXECUTABLE_ALLOCATOR_DEMAND) && !(defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && !(defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 
 #include <sys/mman.h>
 #include <unistd.h>
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorSymbian.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorSymbian.cpp
index 9028f50..9a91403 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorSymbian.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorSymbian.cpp
@@ -22,7 +22,7 @@
 
 #include "ExecutableAllocator.h"
 
-#if ENABLE(EXECUTABLE_ALLOCATOR_DEMAND) && OS(SYMBIAN)
+#if (defined ENABLE_EXECUTABLE_ALLOCATOR_DEMAND && ENABLE_EXECUTABLE_ALLOCATOR_DEMAND) && (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 
 #include <e32hal.h>
 #include <e32std.h>
@@ -34,7 +34,7 @@ namespace JSC {
 
 void ExecutableAllocator::intializePageSize()
 {
-#if CPU(ARMV5_OR_LOWER)
+#if (defined WTF_CPU_ARMV5_OR_LOWER && WTF_CPU_ARMV5_OR_LOWER)
     // The moving memory model (as used in ARMv5 and earlier platforms)
     // on Symbian OS limits the number of chunks for each process to 16. 
     // To mitigate this limitation increase the pagesize to 
@@ -66,10 +66,10 @@ void ExecutablePool::systemRelease(const ExecutablePool::Allocation& alloc)
     delete alloc.chunk;
 }
 
-#if ENABLE(ASSEMBLER_WX_EXCLUSIVE)
+#if (defined ENABLE_ASSEMBLER_WX_EXCLUSIVE && ENABLE_ASSEMBLER_WX_EXCLUSIVE)
 #error "ASSEMBLER_WX_EXCLUSIVE not yet suported on this platform."
 #endif
 
 }
 
-#endif // HAVE(ASSEMBLER)
+#endif // (defined HAVE_ASSEMBLER && HAVE_ASSEMBLER)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorWin.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorWin.cpp
index 72a1d5f..f6752f4 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorWin.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/ExecutableAllocatorWin.cpp
@@ -27,7 +27,7 @@
 
 #include "ExecutableAllocator.h"
 
-#if ENABLE(EXECUTABLE_ALLOCATOR_DEMAND) && OS(WINDOWS)
+#if (defined ENABLE_EXECUTABLE_ALLOCATOR_DEMAND && ENABLE_EXECUTABLE_ALLOCATOR_DEMAND) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
 #include "windows.h"
 
@@ -54,10 +54,10 @@ void ExecutablePool::systemRelease(const ExecutablePool::Allocation& alloc)
     VirtualFree(alloc.pages, 0, MEM_RELEASE); 
 }
 
-#if ENABLE(ASSEMBLER_WX_EXCLUSIVE)
+#if (defined ENABLE_ASSEMBLER_WX_EXCLUSIVE && ENABLE_ASSEMBLER_WX_EXCLUSIVE)
 #error "ASSEMBLER_WX_EXCLUSIVE not yet suported on this platform."
 #endif
 
 }
 
-#endif // HAVE(ASSEMBLER)
+#endif // (defined HAVE_ASSEMBLER && HAVE_ASSEMBLER)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JIT.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JIT.cpp
index c0da66d..842fcca 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JIT.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JIT.cpp
@@ -27,12 +27,12 @@
 #include "JIT.h"
 
 // This probably does not belong here; adding here for now as a quick Windows build fix.
-#if ENABLE(ASSEMBLER) && CPU(X86) && !OS(MAC_OS_X)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER) && (defined WTF_CPU_X86 && WTF_CPU_X86) && !(defined WTF_OS_MAC_OS_X && WTF_OS_MAC_OS_X)
 #include "MacroAssembler.h"
 JSC::MacroAssemblerX86Common::SSE2CheckState JSC::MacroAssemblerX86Common::s_sse2CheckState = NotCheckedSSE2;
 #endif
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 #include "CodeBlock.h"
 #include "Interpreter.h"
@@ -79,7 +79,7 @@ JIT::JIT(JSGlobalData* globalData, CodeBlock* codeBlock)
     , m_propertyAccessCompilationInfo(codeBlock ? codeBlock->numberOfStructureStubInfos() : 0)
     , m_callStructureStubCompilationInfo(codeBlock ? codeBlock->numberOfCallLinkInfos() : 0)
     , m_bytecodeIndex((unsigned)-1)
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     , m_jumpTargetIndex(0)
     , m_mappedBytecodeIndex((unsigned)-1)
     , m_mappedVirtualRegisterIndex((unsigned)-1)
@@ -92,7 +92,7 @@ JIT::JIT(JSGlobalData* globalData, CodeBlock* codeBlock)
 {
 }
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 void JIT::emitTimeoutCheck()
 {
     Jump skipTimeout = branchSub32(NonZero, Imm32(1), timeoutCheckRegister);
@@ -117,7 +117,7 @@ void JIT::emitTimeoutCheck()
     m_bytecodeIndex += OPCODE_LENGTH(name); \
     break;
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 #define DEFINE_BINARY_OP(name) \
     case name: { \
         JITStubCall stubCall(this, cti_##name); \
@@ -135,7 +135,7 @@ void JIT::emitTimeoutCheck()
         NEXT_OPCODE(name); \
     }
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 #define DEFINE_BINARY_OP(name) \
     case name: { \
@@ -153,7 +153,7 @@ void JIT::emitTimeoutCheck()
         stubCall.call(currentInstruction[1].u.operand); \
         NEXT_OPCODE(name); \
     }
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 #define DEFINE_OP(name) \
     case name: { \
@@ -180,12 +180,12 @@ void JIT::privateCompileMainPass()
         Instruction* currentInstruction = instructionsBegin + m_bytecodeIndex;
         ASSERT_WITH_MESSAGE(m_interpreter->isOpcode(currentInstruction->u.opcode), "privateCompileMainPass gone bad @ %d", m_bytecodeIndex);
 
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         if (m_bytecodeIndex > 0) // Avoid the overhead of sampling op_enter twice.
             sampleInstruction(currentInstruction);
 #endif
 
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         if (m_labels[m_bytecodeIndex].isUsed())
             killLastResultRegister();
 #endif
@@ -194,7 +194,7 @@ void JIT::privateCompileMainPass()
 
         switch (m_interpreter->getOpcodeID(currentInstruction->u.opcode)) {
         DEFINE_BINARY_OP(op_del_by_val)
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         DEFINE_BINARY_OP(op_div)
 #endif
         DEFINE_BINARY_OP(op_in)
@@ -207,7 +207,7 @@ void JIT::privateCompileMainPass()
         DEFINE_UNARY_OP(op_is_object)
         DEFINE_UNARY_OP(op_is_string)
         DEFINE_UNARY_OP(op_is_undefined)
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         DEFINE_UNARY_OP(op_negate)
 #endif
         DEFINE_UNARY_OP(op_typeof)
@@ -228,7 +228,7 @@ void JIT::privateCompileMainPass()
         DEFINE_OP(op_create_arguments)
         DEFINE_OP(op_debug)
         DEFINE_OP(op_del_by_id)
-#if !USE(JSVALUE32)
+#if !(defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         DEFINE_OP(op_div)
 #endif
         DEFINE_OP(op_end)
@@ -265,7 +265,7 @@ void JIT::privateCompileMainPass()
         DEFINE_OP(op_mod)
         DEFINE_OP(op_mov)
         DEFINE_OP(op_mul)
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         DEFINE_OP(op_negate)
 #endif
         DEFINE_OP(op_neq)
@@ -353,13 +353,13 @@ void JIT::privateCompileSlowCases()
     Instruction* instructionsBegin = m_codeBlock->instructions().begin();
 
     m_propertyAccessInstructionIndex = 0;
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     m_globalResolveInfoIndex = 0;
 #endif
     m_callLinkInfoIndex = 0;
 
     for (Vector<SlowCaseEntry>::iterator iter = m_slowCases.begin(); iter != m_slowCases.end();) {
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         killLastResultRegister();
 #endif
 
@@ -381,7 +381,7 @@ void JIT::privateCompileSlowCases()
         DEFINE_SLOWCASE_OP(op_construct)
         DEFINE_SLOWCASE_OP(op_construct_verify)
         DEFINE_SLOWCASE_OP(op_convert_this)
-#if !USE(JSVALUE32)
+#if !(defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         DEFINE_SLOWCASE_OP(op_div)
 #endif
         DEFINE_SLOWCASE_OP(op_eq)
@@ -402,7 +402,7 @@ void JIT::privateCompileSlowCases()
         DEFINE_SLOWCASE_OP(op_method_check)
         DEFINE_SLOWCASE_OP(op_mod)
         DEFINE_SLOWCASE_OP(op_mul)
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         DEFINE_SLOWCASE_OP(op_negate)
 #endif
         DEFINE_SLOWCASE_OP(op_neq)
@@ -414,7 +414,7 @@ void JIT::privateCompileSlowCases()
         DEFINE_SLOWCASE_OP(op_pre_inc)
         DEFINE_SLOWCASE_OP(op_put_by_id)
         DEFINE_SLOWCASE_OP(op_put_by_val)
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         DEFINE_SLOWCASE_OP(op_resolve_global)
 #endif
         DEFINE_SLOWCASE_OP(op_rshift)
@@ -432,7 +432,7 @@ void JIT::privateCompileSlowCases()
         emitJumpSlowToHot(jump(), 0);
     }
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     ASSERT(m_propertyAccessInstructionIndex == m_codeBlock->numberOfStructureStubInfos());
 #endif
     ASSERT(m_callLinkInfoIndex == m_codeBlock->numberOfCallLinkInfos());
@@ -446,7 +446,7 @@ void JIT::privateCompileSlowCases()
 JITCode JIT::privateCompile()
 {
     sampleCodeBlock(m_codeBlock);
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     sampleInstruction(m_codeBlock->instructions().begin());
 #endif
 
@@ -533,14 +533,14 @@ JITCode JIT::privateCompile()
     for (Vector<JSRInfo>::iterator iter = m_jsrSites.begin(); iter != m_jsrSites.end(); ++iter)
         patchBuffer.patch(iter->storeLocation, patchBuffer.locationOf(iter->target).executableAddress());
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     for (unsigned i = 0; i < m_codeBlock->numberOfStructureStubInfos(); ++i) {
         StructureStubInfo& info = m_codeBlock->structureStubInfo(i);
         info.callReturnLocation = patchBuffer.locationOf(m_propertyAccessCompilationInfo[i].callReturnLocation);
         info.hotPathBegin = patchBuffer.locationOf(m_propertyAccessCompilationInfo[i].hotPathBegin);
     }
 #endif
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
     for (unsigned i = 0; i < m_codeBlock->numberOfCallLinkInfos(); ++i) {
         CallLinkInfo& info = m_codeBlock->callLinkInfo(i);
         info.ownerCodeBlock = m_codeBlock;
@@ -560,7 +560,7 @@ JITCode JIT::privateCompile()
     return patchBuffer.finalizeCode();
 }
 
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 void JIT::emitGetVariableObjectRegister(RegisterID variableObject, int index, RegisterID dst)
 {
     loadPtr(Address(variableObject, OBJECT_OFFSETOF(JSVariableObject, d)), dst);
@@ -576,14 +576,14 @@ void JIT::emitPutVariableObjectRegister(RegisterID src, RegisterID variableObjec
 }
 #endif
 
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 void JIT::unlinkCall(CallLinkInfo* callLinkInfo)
 {
     // When the JSFunction is deleted the pointer embedded in the instruction stream will no longer be valid
     // (and, if a new JSFunction happened to be constructed at the same location, we could get a false positive
     // match).  Reset the check so it no longer matches.
     RepatchBuffer repatchBuffer(callLinkInfo->ownerCodeBlock.get());
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     repatchBuffer.repatch(callLinkInfo->hotPathBegin, 0);
 #else
     repatchBuffer.repatch(callLinkInfo->hotPathBegin, JSValue::encode(JSValue()));
@@ -609,8 +609,8 @@ void JIT::linkCall(JSFunction* callee, CodeBlock* callerCodeBlock, CodeBlock* ca
     // patch the call so we do not continue to try to link.
     repatchBuffer.relink(callLinkInfo->callReturnLocation, globalData->jitStubs.ctiVirtualCall());
 }
-#endif // ENABLE(JIT_OPTIMIZE_CALL)
+#endif // (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JIT.h b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JIT.h
index 8e0c9ac..ed8cfed 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JIT.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JIT.h
@@ -28,11 +28,11 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 // We've run into some problems where changing the size of the class JIT leads to
 // performance fluctuations.  Try forcing alignment in an attempt to stabalize this.
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define JIT_CLASS_ALIGNMENT __attribute__ ((aligned (32)))
 #else
 #define JIT_CLASS_ALIGNMENT
@@ -192,7 +192,7 @@ namespace JSC {
         // on x86/x86-64 it is ecx for performance reasons, since the
         // MacroAssembler will need to plant register swaps if it is not -
         // however the code will still function correctly.
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         static const RegisterID returnValueRegister = X86Registers::eax;
         static const RegisterID cachedResultRegister = X86Registers::eax;
         static const RegisterID firstArgumentRegister = X86Registers::edi;
@@ -210,7 +210,7 @@ namespace JSC {
         static const FPRegisterID fpRegT0 = X86Registers::xmm0;
         static const FPRegisterID fpRegT1 = X86Registers::xmm1;
         static const FPRegisterID fpRegT2 = X86Registers::xmm2;
-#elif CPU(X86)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86)
         static const RegisterID returnValueRegister = X86Registers::eax;
         static const RegisterID cachedResultRegister = X86Registers::eax;
         // On x86 we always use fastcall conventions = but on
@@ -228,7 +228,7 @@ namespace JSC {
         static const FPRegisterID fpRegT0 = X86Registers::xmm0;
         static const FPRegisterID fpRegT1 = X86Registers::xmm1;
         static const FPRegisterID fpRegT2 = X86Registers::xmm2;
-#elif CPU(ARM_THUMB2)
+#elif (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
         static const RegisterID returnValueRegister = ARMRegisters::r0;
         static const RegisterID cachedResultRegister = ARMRegisters::r0;
         static const RegisterID firstArgumentRegister = ARMRegisters::r0;
@@ -244,7 +244,7 @@ namespace JSC {
         static const FPRegisterID fpRegT0 = ARMRegisters::d0;
         static const FPRegisterID fpRegT1 = ARMRegisters::d1;
         static const FPRegisterID fpRegT2 = ARMRegisters::d2;
-#elif CPU(ARM_TRADITIONAL)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
         static const RegisterID returnValueRegister = ARMRegisters::r0;
         static const RegisterID cachedResultRegister = ARMRegisters::r0;
         static const RegisterID firstArgumentRegister = ARMRegisters::r0;
@@ -389,7 +389,7 @@ namespace JSC {
 
         void testPrototype(Structure*, JumpList& failureCases);
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         Address tagFor(unsigned index, RegisterID base = callFrameRegister);
         Address payloadFor(unsigned index, RegisterID base = callFrameRegister);
 
@@ -422,7 +422,7 @@ namespace JSC {
         void emitJumpSlowCaseIfNotJSCell(unsigned virtualRegisterIndex, RegisterID tag);
         void linkSlowCaseIfNotJSCell(Vector<SlowCaseEntry>::iterator&, unsigned virtualRegisterIndex);
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
         void compileGetByIdHotPath();
         void compileGetByIdSlowCase(int resultVReg, int baseVReg, Identifier* ident, Vector<SlowCaseEntry>::iterator& iter, bool isMethodCheck = false);
 #endif
@@ -436,7 +436,7 @@ namespace JSC {
         void emitSub32Constant(unsigned dst, unsigned op, int32_t constant, ResultType opType);
         void emitBinaryDoubleOp(OpcodeID, unsigned dst, unsigned op1, unsigned op2, OperandTypes, JumpList& notInt32Op1, JumpList& notInt32Op2, bool op1IsInRegisters = true, bool op2IsInRegisters = true);
 
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
         // These architecture specific value are used to enable patching - see comment on op_put_by_id.
         static const int patchOffsetPutByIdStructure = 7;
         static const int patchOffsetPutByIdExternalLoad = 13;
@@ -451,11 +451,11 @@ namespace JSC {
         static const int patchOffsetGetByIdPropertyMapOffset1 = 22;
         static const int patchOffsetGetByIdPropertyMapOffset2 = 28;
         static const int patchOffsetGetByIdPutResult = 28;
-#if ENABLE(OPCODE_SAMPLING) && USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING) && (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
         static const int patchOffsetGetByIdSlowCaseCall = 35;
-#elif ENABLE(OPCODE_SAMPLING)
+#elif (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         static const int patchOffsetGetByIdSlowCaseCall = 37;
-#elif USE(JIT_STUB_ARGUMENT_VA_LIST)
+#elif (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
         static const int patchOffsetGetByIdSlowCaseCall = 25;
 #else
         static const int patchOffsetGetByIdSlowCaseCall = 27;
@@ -465,7 +465,7 @@ namespace JSC {
         static const int patchOffsetMethodCheckProtoObj = 11;
         static const int patchOffsetMethodCheckProtoStruct = 18;
         static const int patchOffsetMethodCheckPutFunction = 29;
-#elif CPU(ARM_TRADITIONAL)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
         // These architecture specific value are used to enable patching - see comment on op_put_by_id.
         static const int patchOffsetPutByIdStructure = 4;
         static const int patchOffsetPutByIdExternalLoad = 16;
@@ -480,7 +480,7 @@ namespace JSC {
         static const int patchOffsetGetByIdPropertyMapOffset1 = 20;
         static const int patchOffsetGetByIdPropertyMapOffset2 = 28;
         static const int patchOffsetGetByIdPutResult = 36;
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         #error "OPCODE_SAMPLING is not yet supported"
 #else
         static const int patchOffsetGetByIdSlowCaseCall = 32;
@@ -510,7 +510,7 @@ namespace JSC {
 #error "JSVALUE32_64 not supported on this platform."
 #endif
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         void emitGetVirtualRegister(int src, RegisterID dst);
         void emitGetVirtualRegisters(int src1, RegisterID dst1, int src2, RegisterID dst2);
         void emitPutVirtualRegister(unsigned dst, RegisterID from = regT0);
@@ -528,7 +528,7 @@ namespace JSC {
         Jump emitJumpIfNotJSCell(RegisterID);
         void emitJumpSlowCaseIfNotJSCell(RegisterID);
         void emitJumpSlowCaseIfNotJSCell(RegisterID, int VReg);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         JIT::Jump emitJumpIfImmediateNumber(RegisterID);
         JIT::Jump emitJumpIfNotImmediateNumber(RegisterID);
 #else
@@ -549,7 +549,7 @@ namespace JSC {
         void emitJumpSlowCaseIfNotImmediateNumber(RegisterID);
         void emitJumpSlowCaseIfNotImmediateIntegers(RegisterID, RegisterID, RegisterID);
 
-#if !USE(JSVALUE64)
+#if !(defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         void emitFastArithDeTagImmediate(RegisterID);
         Jump emitFastArithDeTagImmediateJumpIfZero(RegisterID);
 #endif
@@ -559,13 +559,13 @@ namespace JSC {
 
         void emitTagAsBoolImmediate(RegisterID reg);
         void compileBinaryArithOp(OpcodeID, unsigned dst, unsigned src1, unsigned src2, OperandTypes opi);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         void compileBinaryArithOpSlowCase(OpcodeID, Vector<SlowCaseEntry>::iterator&, unsigned dst, unsigned src1, unsigned src2, OperandTypes, bool op1HasImmediateIntFastCase, bool op2HasImmediateIntFastCase);
 #else
         void compileBinaryArithOpSlowCase(OpcodeID, Vector<SlowCaseEntry>::iterator&, unsigned dst, unsigned src1, unsigned src2, OperandTypes);
 #endif
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
         void compileGetByIdHotPath(int resultVReg, int baseVReg, Identifier* ident, unsigned propertyAccessInstructionIndex);
         void compileGetByIdSlowCase(int resultVReg, int baseVReg, Identifier* ident, Vector<SlowCaseEntry>::iterator& iter, bool isMethodCheck = false);
 #endif
@@ -574,7 +574,7 @@ namespace JSC {
         void compileGetDirectOffset(RegisterID base, RegisterID result, RegisterID structure, RegisterID offset, RegisterID scratch);
         void compilePutDirectOffset(RegisterID base, RegisterID value, Structure* structure, size_t cachedOffset);
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         // These architecture specific value are used to enable patching - see comment on op_put_by_id.
         static const int patchOffsetPutByIdStructure = 10;
         static const int patchOffsetPutByIdExternalLoad = 20;
@@ -587,7 +587,7 @@ namespace JSC {
         static const int patchLengthGetByIdExternalLoad = 4;
         static const int patchOffsetGetByIdPropertyMapOffset = 31;
         static const int patchOffsetGetByIdPutResult = 31;
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         static const int patchOffsetGetByIdSlowCaseCall = 64;
 #else
         static const int patchOffsetGetByIdSlowCaseCall = 41;
@@ -597,7 +597,7 @@ namespace JSC {
         static const int patchOffsetMethodCheckProtoObj = 20;
         static const int patchOffsetMethodCheckProtoStruct = 30;
         static const int patchOffsetMethodCheckPutFunction = 50;
-#elif CPU(X86)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86)
         // These architecture specific value are used to enable patching - see comment on op_put_by_id.
         static const int patchOffsetPutByIdStructure = 7;
         static const int patchOffsetPutByIdExternalLoad = 13;
@@ -610,11 +610,11 @@ namespace JSC {
         static const int patchLengthGetByIdExternalLoad = 3;
         static const int patchOffsetGetByIdPropertyMapOffset = 22;
         static const int patchOffsetGetByIdPutResult = 22;
-#if ENABLE(OPCODE_SAMPLING) && USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING) && (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
         static const int patchOffsetGetByIdSlowCaseCall = 31;
-#elif ENABLE(OPCODE_SAMPLING)
+#elif (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         static const int patchOffsetGetByIdSlowCaseCall = 33;
-#elif USE(JIT_STUB_ARGUMENT_VA_LIST)
+#elif (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
         static const int patchOffsetGetByIdSlowCaseCall = 21;
 #else
         static const int patchOffsetGetByIdSlowCaseCall = 23;
@@ -624,7 +624,7 @@ namespace JSC {
         static const int patchOffsetMethodCheckProtoObj = 11;
         static const int patchOffsetMethodCheckProtoStruct = 18;
         static const int patchOffsetMethodCheckPutFunction = 29;
-#elif CPU(ARM_THUMB2)
+#elif (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
         // These architecture specific value are used to enable patching - see comment on op_put_by_id.
         static const int patchOffsetPutByIdStructure = 10;
         static const int patchOffsetPutByIdExternalLoad = 26;
@@ -637,7 +637,7 @@ namespace JSC {
         static const int patchLengthGetByIdExternalLoad = 12;
         static const int patchOffsetGetByIdPropertyMapOffset = 46;
         static const int patchOffsetGetByIdPutResult = 50;
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         static const int patchOffsetGetByIdSlowCaseCall = 0; // FIMXE
 #else
         static const int patchOffsetGetByIdSlowCaseCall = 28;
@@ -647,7 +647,7 @@ namespace JSC {
         static const int patchOffsetMethodCheckProtoObj = 24;
         static const int patchOffsetMethodCheckProtoStruct = 34;
         static const int patchOffsetMethodCheckPutFunction = 58;
-#elif CPU(ARM_TRADITIONAL)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
         // These architecture specific value are used to enable patching - see comment on op_put_by_id.
         static const int patchOffsetPutByIdStructure = 4;
         static const int patchOffsetPutByIdExternalLoad = 16;
@@ -660,7 +660,7 @@ namespace JSC {
         static const int patchLengthGetByIdExternalLoad = 4;
         static const int patchOffsetGetByIdPropertyMapOffset = 20;
         static const int patchOffsetGetByIdPutResult = 28;
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         #error "OPCODE_SAMPLING is not yet supported"
 #else
         static const int patchOffsetGetByIdSlowCaseCall = 28;
@@ -687,7 +687,7 @@ namespace JSC {
         static const int sequencePutByIdInstructionSpace = 28;
         static const int sequencePutByIdConstantSpace = 3;
 #endif
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 #if defined(ASSEMBLER_HAS_CONSTANT_POOL) && ASSEMBLER_HAS_CONSTANT_POOL
 #define BEGIN_UNINTERRUPTED_SEQUENCE(name) beginUninterruptedSequence(name ## InstructionSpace, name ## ConstantSpace)
@@ -850,7 +850,7 @@ namespace JSC {
 
         /* These functions are deprecated: Please use JITStubCall instead. */
         void emitPutJITStubArg(RegisterID src, unsigned argumentNumber);
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         void emitPutJITStubArg(RegisterID tag, RegisterID payload, unsigned argumentNumber);
         void emitPutJITStubArgFromVirtualRegister(unsigned src, unsigned argumentNumber, RegisterID scratch1, RegisterID scratch2);
 #else
@@ -897,20 +897,20 @@ namespace JSC {
         void printBytecodeOperandTypes(unsigned src1, unsigned src2);
 #endif
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
         void setSamplingFlag(int32_t);
         void clearSamplingFlag(int32_t);
 #endif
 
-#if ENABLE(SAMPLING_COUNTERS)
+#if (defined ENABLE_SAMPLING_COUNTERS && ENABLE_SAMPLING_COUNTERS)
         void emitCount(AbstractSamplingCounter&, uint32_t = 1);
 #endif
 
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
         void sampleInstruction(Instruction*, bool = false);
 #endif
 
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
         void sampleCodeBlock(CodeBlock*);
 #else
         void sampleCodeBlock(CodeBlock*) {}
@@ -936,7 +936,7 @@ namespace JSC {
         unsigned m_globalResolveInfoIndex;
         unsigned m_callLinkInfoIndex;
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         unsigned m_jumpTargetIndex;
         unsigned m_mappedBytecodeIndex;
         unsigned m_mappedVirtualRegisterIndex;
@@ -996,6 +996,6 @@ namespace JSC {
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
 
 #endif // JIT_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITArithmetic.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITArithmetic.cpp
index 927b192..6fe434d 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITArithmetic.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITArithmetic.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "JIT.h"
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 #include "CodeBlock.h"
 #include "JITInlineMethods.h"
@@ -45,7 +45,7 @@ using namespace std;
 
 namespace JSC {
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 void JIT::emit_op_negate(Instruction* currentInstruction)
 {
@@ -1116,7 +1116,7 @@ void JIT::emitSlow_op_div(Instruction* currentInstruction, Vector<SlowCaseEntry>
 
 /* ------------------------------ BEGIN: OP_MOD ------------------------------ */
 
-#if CPU(X86) || CPU(X86_64)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
 void JIT::emit_op_mod(Instruction* currentInstruction)
 {
@@ -1178,7 +1178,7 @@ void JIT::emitSlow_op_mod(Instruction* currentInstruction, Vector<SlowCaseEntry>
     stubCall.call(dst);
 }
 
-#else // CPU(X86) || CPU(X86_64)
+#else // (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
 void JIT::emit_op_mod(Instruction* currentInstruction)
 {
@@ -1196,11 +1196,11 @@ void JIT::emitSlow_op_mod(Instruction*, Vector<SlowCaseEntry>::iterator&)
 {
 }
 
-#endif // CPU(X86) || CPU(X86_64)
+#endif // (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
 /* ------------------------------ END: OP_MOD ------------------------------ */
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 void JIT::emit_op_lshift(Instruction* currentInstruction)
 {
@@ -1215,7 +1215,7 @@ void JIT::emit_op_lshift(Instruction* currentInstruction)
     emitFastArithImmToInt(regT0);
     emitFastArithImmToInt(regT2);
     lshift32(regT2, regT0);
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
     addSlowCase(branchAdd32(Overflow, regT0, regT0));
     signExtend32ToPtr(regT0, regT0);
 #endif
@@ -1229,7 +1229,7 @@ void JIT::emitSlow_op_lshift(Instruction* currentInstruction, Vector<SlowCaseEnt
     unsigned op1 = currentInstruction[2].u.operand;
     unsigned op2 = currentInstruction[3].u.operand;
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     UNUSED_PARAM(op1);
     UNUSED_PARAM(op2);
     linkSlowCase(iter);
@@ -1265,14 +1265,14 @@ void JIT::emit_op_rshift(Instruction* currentInstruction)
         emitGetVirtualRegisters(op1, regT0, op2, regT2);
         if (supportsFloatingPointTruncate()) {
             Jump lhsIsInt = emitJumpIfImmediateInteger(regT0);
-#if USE(JSVALUE64)
-            // supportsFloatingPoint() && USE(JSVALUE64) => 3 SlowCases
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
+            // supportsFloatingPoint() && (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64) => 3 SlowCases
             addSlowCase(emitJumpIfNotImmediateNumber(regT0));
             addPtr(tagTypeNumberRegister, regT0);
             movePtrToDouble(regT0, fpRegT0);
             addSlowCase(branchTruncateDoubleToInt32(fpRegT0, regT0));
 #else
-            // supportsFloatingPoint() && !USE(JSVALUE64) => 5 SlowCases (of which 1 IfNotJSCell)
+            // supportsFloatingPoint() && !(defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64) => 5 SlowCases (of which 1 IfNotJSCell)
             emitJumpSlowCaseIfNotJSCell(regT0, op1);
             addSlowCase(checkStructure(regT0, m_globalData->numberStructure.get()));
             loadDouble(Address(regT0, OBJECT_OFFSETOF(JSNumberCell, m_value)), fpRegT0);
@@ -1288,11 +1288,11 @@ void JIT::emit_op_rshift(Instruction* currentInstruction)
         }
         emitFastArithImmToInt(regT2);
         rshift32(regT2, regT0);
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         signExtend32ToPtr(regT0, regT0);
 #endif
     }
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     emitFastArithIntToImmNoCheck(regT0, regT0);
 #else
     orPtr(Imm32(JSImmediate::TagTypeNumber), regT0);
@@ -1314,7 +1314,7 @@ void JIT::emitSlow_op_rshift(Instruction* currentInstruction, Vector<SlowCaseEnt
         stubCall.addArgument(op2, regT2);
     } else {
         if (supportsFloatingPointTruncate()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             linkSlowCase(iter);
             linkSlowCase(iter);
             linkSlowCase(iter);
@@ -1355,7 +1355,7 @@ void JIT::emit_op_jnless(Instruction* currentInstruction)
     if (isOperandConstantImmediateInt(op2)) {
         emitGetVirtualRegister(op1, regT0);
         emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t op2imm = getConstantOperandImmediateInt(op2);
 #else
         int32_t op2imm = static_cast<int32_t>(JSImmediate::rawValue(getConstantOperand(op2)));
@@ -1364,7 +1364,7 @@ void JIT::emit_op_jnless(Instruction* currentInstruction)
     } else if (isOperandConstantImmediateInt(op1)) {
         emitGetVirtualRegister(op2, regT1);
         emitJumpSlowCaseIfNotImmediateInteger(regT1);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t op1imm = getConstantOperandImmediateInt(op1);
 #else
         int32_t op1imm = static_cast<int32_t>(JSImmediate::rawValue(getConstantOperand(op1)));
@@ -1394,7 +1394,7 @@ void JIT::emitSlow_op_jnless(Instruction* currentInstruction, Vector<SlowCaseEnt
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT0);
             addPtr(tagTypeNumberRegister, regT0);
             movePtrToDouble(regT0, fpRegT0);
@@ -1416,7 +1416,7 @@ void JIT::emitSlow_op_jnless(Instruction* currentInstruction, Vector<SlowCaseEnt
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnless));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
 #else
             if (!m_codeBlock->isKnownNotImmediate(op1))
@@ -1435,7 +1435,7 @@ void JIT::emitSlow_op_jnless(Instruction* currentInstruction, Vector<SlowCaseEnt
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT1);
             addPtr(tagTypeNumberRegister, regT1);
             movePtrToDouble(regT1, fpRegT1);
@@ -1457,7 +1457,7 @@ void JIT::emitSlow_op_jnless(Instruction* currentInstruction, Vector<SlowCaseEnt
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnless));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
 #else
             if (!m_codeBlock->isKnownNotImmediate(op2))
@@ -1476,7 +1476,7 @@ void JIT::emitSlow_op_jnless(Instruction* currentInstruction, Vector<SlowCaseEnt
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT0);
             Jump fail2 = emitJumpIfNotImmediateNumber(regT1);
             Jump fail3 = emitJumpIfImmediateInteger(regT1);
@@ -1503,7 +1503,7 @@ void JIT::emitSlow_op_jnless(Instruction* currentInstruction, Vector<SlowCaseEnt
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnless));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
             fail2.link(this);
             fail3.link(this);
@@ -1540,7 +1540,7 @@ void JIT::emit_op_jless(Instruction* currentInstruction)
     if (isOperandConstantImmediateInt(op2)) {
         emitGetVirtualRegister(op1, regT0);
         emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t op2imm = getConstantOperandImmediateInt(op2);
 #else
         int32_t op2imm = static_cast<int32_t>(JSImmediate::rawValue(getConstantOperand(op2)));
@@ -1549,7 +1549,7 @@ void JIT::emit_op_jless(Instruction* currentInstruction)
     } else if (isOperandConstantImmediateInt(op1)) {
         emitGetVirtualRegister(op2, regT1);
         emitJumpSlowCaseIfNotImmediateInteger(regT1);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t op1imm = getConstantOperandImmediateInt(op1);
 #else
         int32_t op1imm = static_cast<int32_t>(JSImmediate::rawValue(getConstantOperand(op1)));
@@ -1579,7 +1579,7 @@ void JIT::emitSlow_op_jless(Instruction* currentInstruction, Vector<SlowCaseEntr
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT0);
             addPtr(tagTypeNumberRegister, regT0);
             movePtrToDouble(regT0, fpRegT0);
@@ -1601,7 +1601,7 @@ void JIT::emitSlow_op_jless(Instruction* currentInstruction, Vector<SlowCaseEntr
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnless));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
 #else
             if (!m_codeBlock->isKnownNotImmediate(op1))
@@ -1620,7 +1620,7 @@ void JIT::emitSlow_op_jless(Instruction* currentInstruction, Vector<SlowCaseEntr
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT1);
             addPtr(tagTypeNumberRegister, regT1);
             movePtrToDouble(regT1, fpRegT1);
@@ -1642,7 +1642,7 @@ void JIT::emitSlow_op_jless(Instruction* currentInstruction, Vector<SlowCaseEntr
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnless));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
 #else
             if (!m_codeBlock->isKnownNotImmediate(op2))
@@ -1661,7 +1661,7 @@ void JIT::emitSlow_op_jless(Instruction* currentInstruction, Vector<SlowCaseEntr
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT0);
             Jump fail2 = emitJumpIfNotImmediateNumber(regT1);
             Jump fail3 = emitJumpIfImmediateInteger(regT1);
@@ -1688,7 +1688,7 @@ void JIT::emitSlow_op_jless(Instruction* currentInstruction, Vector<SlowCaseEntr
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnless));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
             fail2.link(this);
             fail3.link(this);
@@ -1725,7 +1725,7 @@ void JIT::emit_op_jnlesseq(Instruction* currentInstruction)
     if (isOperandConstantImmediateInt(op2)) {
         emitGetVirtualRegister(op1, regT0);
         emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t op2imm = getConstantOperandImmediateInt(op2);
 #else
         int32_t op2imm = static_cast<int32_t>(JSImmediate::rawValue(getConstantOperand(op2)));
@@ -1734,7 +1734,7 @@ void JIT::emit_op_jnlesseq(Instruction* currentInstruction)
     } else if (isOperandConstantImmediateInt(op1)) {
         emitGetVirtualRegister(op2, regT1);
         emitJumpSlowCaseIfNotImmediateInteger(regT1);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t op1imm = getConstantOperandImmediateInt(op1);
 #else
         int32_t op1imm = static_cast<int32_t>(JSImmediate::rawValue(getConstantOperand(op1)));
@@ -1764,7 +1764,7 @@ void JIT::emitSlow_op_jnlesseq(Instruction* currentInstruction, Vector<SlowCaseE
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT0);
             addPtr(tagTypeNumberRegister, regT0);
             movePtrToDouble(regT0, fpRegT0);
@@ -1786,7 +1786,7 @@ void JIT::emitSlow_op_jnlesseq(Instruction* currentInstruction, Vector<SlowCaseE
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnlesseq));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
 #else
             if (!m_codeBlock->isKnownNotImmediate(op1))
@@ -1805,7 +1805,7 @@ void JIT::emitSlow_op_jnlesseq(Instruction* currentInstruction, Vector<SlowCaseE
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT1);
             addPtr(tagTypeNumberRegister, regT1);
             movePtrToDouble(regT1, fpRegT1);
@@ -1827,7 +1827,7 @@ void JIT::emitSlow_op_jnlesseq(Instruction* currentInstruction, Vector<SlowCaseE
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnlesseq));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
 #else
             if (!m_codeBlock->isKnownNotImmediate(op2))
@@ -1846,7 +1846,7 @@ void JIT::emitSlow_op_jnlesseq(Instruction* currentInstruction, Vector<SlowCaseE
         linkSlowCase(iter);
 
         if (supportsFloatingPoint()) {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             Jump fail1 = emitJumpIfNotImmediateNumber(regT0);
             Jump fail2 = emitJumpIfNotImmediateNumber(regT1);
             Jump fail3 = emitJumpIfImmediateInteger(regT1);
@@ -1873,7 +1873,7 @@ void JIT::emitSlow_op_jnlesseq(Instruction* currentInstruction, Vector<SlowCaseE
 
             emitJumpSlowToHot(jump(), OPCODE_LENGTH(op_jnlesseq));
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             fail1.link(this);
             fail2.link(this);
             fail3.link(this);
@@ -1905,7 +1905,7 @@ void JIT::emit_op_bitand(Instruction* currentInstruction)
     if (isOperandConstantImmediateInt(op1)) {
         emitGetVirtualRegister(op2, regT0);
         emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t imm = getConstantOperandImmediateInt(op1);
         andPtr(Imm32(imm), regT0);
         if (imm >= 0)
@@ -1916,7 +1916,7 @@ void JIT::emit_op_bitand(Instruction* currentInstruction)
     } else if (isOperandConstantImmediateInt(op2)) {
         emitGetVirtualRegister(op1, regT0);
         emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t imm = getConstantOperandImmediateInt(op2);
         andPtr(Imm32(imm), regT0);
         if (imm >= 0)
@@ -1965,7 +1965,7 @@ void JIT::emit_op_post_inc(Instruction* currentInstruction)
     emitGetVirtualRegister(srcDst, regT0);
     move(regT0, regT1);
     emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     addSlowCase(branchAdd32(Overflow, Imm32(1), regT1));
     emitFastArithIntToImmNoCheck(regT1, regT1);
 #else
@@ -1997,7 +1997,7 @@ void JIT::emit_op_post_dec(Instruction* currentInstruction)
     emitGetVirtualRegister(srcDst, regT0);
     move(regT0, regT1);
     emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     addSlowCase(branchSub32(Zero, Imm32(1), regT1));
     emitFastArithIntToImmNoCheck(regT1, regT1);
 #else
@@ -2027,7 +2027,7 @@ void JIT::emit_op_pre_inc(Instruction* currentInstruction)
 
     emitGetVirtualRegister(srcDst, regT0);
     emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     addSlowCase(branchAdd32(Overflow, Imm32(1), regT0));
     emitFastArithIntToImmNoCheck(regT0, regT0);
 #else
@@ -2056,7 +2056,7 @@ void JIT::emit_op_pre_dec(Instruction* currentInstruction)
 
     emitGetVirtualRegister(srcDst, regT0);
     emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     addSlowCase(branchSub32(Zero, Imm32(1), regT0));
     emitFastArithIntToImmNoCheck(regT0, regT0);
 #else
@@ -2081,7 +2081,7 @@ void JIT::emitSlow_op_pre_dec(Instruction* currentInstruction, Vector<SlowCaseEn
 
 /* ------------------------------ BEGIN: OP_MOD ------------------------------ */
 
-#if CPU(X86) || CPU(X86_64)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
 void JIT::emit_op_mod(Instruction* currentInstruction)
 {
@@ -2092,7 +2092,7 @@ void JIT::emit_op_mod(Instruction* currentInstruction)
     emitGetVirtualRegisters(op1, X86Registers::eax, op2, X86Registers::ecx);
     emitJumpSlowCaseIfNotImmediateInteger(X86Registers::eax);
     emitJumpSlowCaseIfNotImmediateInteger(X86Registers::ecx);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     addSlowCase(branchPtr(Equal, X86Registers::ecx, ImmPtr(JSValue::encode(jsNumber(m_globalData, 0)))));
     m_assembler.cdq();
     m_assembler.idivl_r(X86Registers::ecx);
@@ -2111,7 +2111,7 @@ void JIT::emitSlow_op_mod(Instruction* currentInstruction, Vector<SlowCaseEntry>
 {
     unsigned result = currentInstruction[1].u.operand;
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     linkSlowCase(iter);
     linkSlowCase(iter);
     linkSlowCase(iter);
@@ -2130,7 +2130,7 @@ void JIT::emitSlow_op_mod(Instruction* currentInstruction, Vector<SlowCaseEntry>
     stubCall.call(result);
 }
 
-#else // CPU(X86) || CPU(X86_64)
+#else // (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
 void JIT::emit_op_mod(Instruction* currentInstruction)
 {
@@ -2149,13 +2149,13 @@ void JIT::emitSlow_op_mod(Instruction*, Vector<SlowCaseEntry>::iterator&)
     ASSERT_NOT_REACHED();
 }
 
-#endif // CPU(X86) || CPU(X86_64)
+#endif // (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
 /* ------------------------------ END: OP_MOD ------------------------------ */
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
 
-/* ------------------------------ BEGIN: USE(JSVALUE64) (OP_ADD, OP_SUB, OP_MUL) ------------------------------ */
+/* ------------------------------ BEGIN: (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64) (OP_ADD, OP_SUB, OP_MUL) ------------------------------ */
 
 void JIT::compileBinaryArithOp(OpcodeID opcodeID, unsigned, unsigned op1, unsigned op2, OperandTypes)
 {
@@ -2446,9 +2446,9 @@ void JIT::emitSlow_op_sub(Instruction* currentInstruction, Vector<SlowCaseEntry>
     compileBinaryArithOpSlowCase(op_sub, iter, result, op1, op2, types, false, false);
 }
 
-#else // USE(JSVALUE64)
+#else // (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
 
-/* ------------------------------ BEGIN: !USE(JSVALUE64) (OP_ADD, OP_SUB, OP_MUL) ------------------------------ */
+/* ------------------------------ BEGIN: !(defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64) (OP_ADD, OP_SUB, OP_MUL) ------------------------------ */
 
 void JIT::compileBinaryArithOp(OpcodeID opcodeID, unsigned dst, unsigned src1, unsigned src2, OperandTypes types)
 {
@@ -2745,12 +2745,12 @@ void JIT::emitSlow_op_sub(Instruction* currentInstruction, Vector<SlowCaseEntry>
     compileBinaryArithOpSlowCase(op_sub, iter, currentInstruction[1].u.operand, currentInstruction[2].u.operand, currentInstruction[3].u.operand, OperandTypes::fromInt(currentInstruction[4].u.operand));
 }
 
-#endif // USE(JSVALUE64)
+#endif // (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
 
 /* ------------------------------ END: OP_ADD, OP_SUB, OP_MUL ------------------------------ */
 
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITCall.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITCall.cpp
index 07253e1..54d8cb8 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITCall.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITCall.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "JIT.h"
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 #include "CodeBlock.h"
 #include "JITInlineMethods.h"
@@ -45,7 +45,7 @@ using namespace std;
 
 namespace JSC {
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 void JIT::compileOpCallInitializeCallFrame()
 {
@@ -231,9 +231,9 @@ void JIT::emit_op_construct(Instruction* currentInstruction)
     compileOpCall(op_construct, currentInstruction, m_callLinkInfoIndex++);
 }
 
-#if !ENABLE(JIT_OPTIMIZE_CALL)
+#if !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
-/* ------------------------------ BEGIN: !ENABLE(JIT_OPTIMIZE_CALL) ------------------------------ */
+/* ------------------------------ BEGIN: !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL) ------------------------------ */
 
 void JIT::compileOpCall(OpcodeID opcodeID, Instruction* instruction, unsigned)
 {
@@ -297,9 +297,9 @@ void JIT::compileOpCallSlowCase(Instruction* instruction, Vector<SlowCaseEntry>:
     sampleCodeBlock(m_codeBlock);
 }
 
-#else // !ENABLE(JIT_OPTIMIZE_CALL)
+#else // !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
-/* ------------------------------ BEGIN: ENABLE(JIT_OPTIMIZE_CALL) ------------------------------ */
+/* ------------------------------ BEGIN: (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL) ------------------------------ */
 
 void JIT::compileOpCall(OpcodeID opcodeID, Instruction* instruction, unsigned callLinkInfoIndex)
 {
@@ -430,11 +430,11 @@ void JIT::compileOpCallSlowCase(Instruction* instruction, Vector<SlowCaseEntry>:
     sampleCodeBlock(m_codeBlock);
 }
 
-/* ------------------------------ END: !ENABLE / ENABLE(JIT_OPTIMIZE_CALL) ------------------------------ */
+/* ------------------------------ END: !ENABLE / (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL) ------------------------------ */
 
-#endif // !ENABLE(JIT_OPTIMIZE_CALL)
+#endif // !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 void JIT::compileOpCallInitializeCallFrame()
 {
@@ -525,9 +525,9 @@ void JIT::compileOpCallVarargsSlowCase(Instruction* instruction, Vector<SlowCase
     sampleCodeBlock(m_codeBlock);
 }
     
-#if !ENABLE(JIT_OPTIMIZE_CALL)
+#if !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
-/* ------------------------------ BEGIN: !ENABLE(JIT_OPTIMIZE_CALL) ------------------------------ */
+/* ------------------------------ BEGIN: !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL) ------------------------------ */
 
 void JIT::compileOpCall(OpcodeID opcodeID, Instruction* instruction, unsigned)
 {
@@ -592,9 +592,9 @@ void JIT::compileOpCallSlowCase(Instruction* instruction, Vector<SlowCaseEntry>:
     sampleCodeBlock(m_codeBlock);
 }
 
-#else // !ENABLE(JIT_OPTIMIZE_CALL)
+#else // !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
-/* ------------------------------ BEGIN: ENABLE(JIT_OPTIMIZE_CALL) ------------------------------ */
+/* ------------------------------ BEGIN: (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL) ------------------------------ */
 
 void JIT::compileOpCall(OpcodeID opcodeID, Instruction* instruction, unsigned callLinkInfoIndex)
 {
@@ -721,12 +721,12 @@ void JIT::compileOpCallSlowCase(Instruction* instruction, Vector<SlowCaseEntry>:
     sampleCodeBlock(m_codeBlock);
 }
 
-/* ------------------------------ END: !ENABLE / ENABLE(JIT_OPTIMIZE_CALL) ------------------------------ */
+/* ------------------------------ END: !ENABLE / (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL) ------------------------------ */
 
-#endif // !ENABLE(JIT_OPTIMIZE_CALL)
+#endif // !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITCode.h b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITCode.h
index 69cf167..1ef7c6b 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITCode.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITCode.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 #include "CallFrame.h"
 #include "JSValue.h"
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITInlineMethods.h b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITInlineMethods.h
index 5af7565..3b3d3d3 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITInlineMethods.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITInlineMethods.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 namespace JSC {
 
@@ -89,7 +89,7 @@ ALWAYS_INLINE void JIT::emitPutImmediateToCallFrameHeader(void* value, RegisterF
 ALWAYS_INLINE void JIT::emitGetFromCallFrameHeaderPtr(RegisterFile::CallFrameHeaderEntry entry, RegisterID to, RegisterID from)
 {
     loadPtr(Address(from, entry * sizeof(Register)), to);
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     killLastResultRegister();
 #endif
 }
@@ -97,7 +97,7 @@ ALWAYS_INLINE void JIT::emitGetFromCallFrameHeaderPtr(RegisterFile::CallFrameHea
 ALWAYS_INLINE void JIT::emitGetFromCallFrameHeader32(RegisterFile::CallFrameHeaderEntry entry, RegisterID to, RegisterID from)
 {
     load32(Address(from, entry * sizeof(Register)), to);
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     killLastResultRegister();
 #endif
 }
@@ -115,7 +115,7 @@ ALWAYS_INLINE JIT::Call JIT::emitNakedCall(CodePtr function)
 
 ALWAYS_INLINE void JIT::beginUninterruptedSequence(int insnSpace, int constSpace)
 {
-#if CPU(ARM_TRADITIONAL)
+#if (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 #ifndef NDEBUG
     // Ensure the label after the sequence can also fit
     insnSpace += sizeof(ARMWord);
@@ -144,7 +144,7 @@ ALWAYS_INLINE void JIT::endUninterruptedSequence(int insnSpace, int constSpace)
 
 #endif
 
-#if CPU(ARM)
+#if (defined WTF_CPU_ARM && WTF_CPU_ARM)
 
 ALWAYS_INLINE void JIT::preserveReturnAddressAfterCall(RegisterID reg)
 {
@@ -161,7 +161,7 @@ ALWAYS_INLINE void JIT::restoreReturnAddressBeforeReturn(Address address)
     loadPtr(address, linkRegister);
 }
 
-#else // CPU(X86) || CPU(X86_64)
+#else // (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
 ALWAYS_INLINE void JIT::preserveReturnAddressAfterCall(RegisterID reg)
 {
@@ -180,7 +180,7 @@ ALWAYS_INLINE void JIT::restoreReturnAddressBeforeReturn(Address address)
 
 #endif
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
 ALWAYS_INLINE void JIT::restoreArgumentReference()
 {
     poke(callFrameRegister, OBJECT_OFFSETOF(struct JITStackFrame, callFrame) / sizeof (void*));
@@ -194,10 +194,10 @@ ALWAYS_INLINE void JIT::restoreArgumentReference()
 }
 ALWAYS_INLINE void JIT::restoreArgumentReferenceForTrampoline()
 {
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
     // Within a trampoline the return address will be on the stack at this point.
     addPtr(Imm32(sizeof(void*)), stackPointerRegister, firstArgumentRegister);
-#elif CPU(ARM)
+#elif (defined WTF_CPU_ARM && WTF_CPU_ARM)
     move(stackPointerRegister, firstArgumentRegister);
 #endif
     // In the trampoline on x86-64, the first argument register is not overwritten.
@@ -246,7 +246,7 @@ ALWAYS_INLINE void JIT::emitJumpSlowToHot(Jump jump, int relativeOffset)
     jump.linkTo(m_labels[m_bytecodeIndex + relativeOffset], this);
 }
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
 ALWAYS_INLINE void JIT::setSamplingFlag(int32_t flag)
 {
     ASSERT(flag >= 1);
@@ -262,12 +262,12 @@ ALWAYS_INLINE void JIT::clearSamplingFlag(int32_t flag)
 }
 #endif
 
-#if ENABLE(SAMPLING_COUNTERS)
+#if (defined ENABLE_SAMPLING_COUNTERS && ENABLE_SAMPLING_COUNTERS)
 ALWAYS_INLINE void JIT::emitCount(AbstractSamplingCounter& counter, uint32_t count)
 {
-#if CPU(X86_64) // Or any other 64-bit plattform.
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64) // Or any other 64-bit plattform.
     addPtr(Imm32(count), AbsoluteAddress(&counter.m_counter));
-#elif CPU(X86) // Or any other little-endian 32-bit plattform.
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) // Or any other little-endian 32-bit plattform.
     intptr_t hiWord = reinterpret_cast<intptr_t>(&counter.m_counter) + sizeof(int32_t);
     add32(Imm32(count), AbsoluteAddress(&counter.m_counter));
     addWithCarry32(Imm32(0), AbsoluteAddress(reinterpret_cast<void*>(hiWord)));
@@ -277,8 +277,8 @@ ALWAYS_INLINE void JIT::emitCount(AbstractSamplingCounter& counter, uint32_t cou
 }
 #endif
 
-#if ENABLE(OPCODE_SAMPLING)
-#if CPU(X86_64)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 ALWAYS_INLINE void JIT::sampleInstruction(Instruction* instruction, bool inHostFunction)
 {
     move(ImmPtr(m_interpreter->sampler()->sampleSlot()), X86Registers::ecx);
@@ -292,8 +292,8 @@ ALWAYS_INLINE void JIT::sampleInstruction(Instruction* instruction, bool inHostF
 #endif
 #endif
 
-#if ENABLE(CODEBLOCK_SAMPLING)
-#if CPU(X86_64)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 ALWAYS_INLINE void JIT::sampleCodeBlock(CodeBlock* codeBlock)
 {
     move(ImmPtr(m_interpreter->sampler()->codeBlockSlot()), X86Registers::ecx);
@@ -312,7 +312,7 @@ inline JIT::Address JIT::addressFor(unsigned index, RegisterID base)
     return Address(base, (index * sizeof(Register)));
 }
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 inline JIT::Address JIT::tagFor(unsigned index, RegisterID base)
 {
@@ -606,7 +606,7 @@ ALWAYS_INLINE void JIT::emitPutJITStubArgFromVirtualRegister(unsigned src, unsig
     }
 }
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 ALWAYS_INLINE void JIT::killLastResultRegister()
 {
@@ -681,7 +681,7 @@ ALWAYS_INLINE void JIT::emitInitRegister(unsigned dst)
 
 ALWAYS_INLINE JIT::Jump JIT::emitJumpIfJSCell(RegisterID reg)
 {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     return branchTestPtr(Zero, reg, tagMaskRegister);
 #else
     return branchTest32(Zero, reg, Imm32(JSImmediate::TagMask));
@@ -702,7 +702,7 @@ ALWAYS_INLINE void JIT::emitJumpSlowCaseIfJSCell(RegisterID reg)
 
 ALWAYS_INLINE JIT::Jump JIT::emitJumpIfNotJSCell(RegisterID reg)
 {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     return branchTestPtr(NonZero, reg, tagMaskRegister);
 #else
     return branchTest32(NonZero, reg, Imm32(JSImmediate::TagMask));
@@ -720,7 +720,7 @@ ALWAYS_INLINE void JIT::emitJumpSlowCaseIfNotJSCell(RegisterID reg, int vReg)
         emitJumpSlowCaseIfNotJSCell(reg);
 }
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
 ALWAYS_INLINE JIT::Jump JIT::emitJumpIfImmediateNumber(RegisterID reg)
 {
     return branchTestPtr(NonZero, reg, tagTypeNumberRegister);
@@ -751,7 +751,7 @@ inline void JIT::emitLoadInt32ToDouble(unsigned index, FPRegisterID value)
 
 ALWAYS_INLINE JIT::Jump JIT::emitJumpIfImmediateInteger(RegisterID reg)
 {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     return branchPtr(AboveOrEqual, reg, tagTypeNumberRegister);
 #else
     return branchTest32(NonZero, reg, Imm32(JSImmediate::TagTypeNumber));
@@ -760,7 +760,7 @@ ALWAYS_INLINE JIT::Jump JIT::emitJumpIfImmediateInteger(RegisterID reg)
 
 ALWAYS_INLINE JIT::Jump JIT::emitJumpIfNotImmediateInteger(RegisterID reg)
 {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     return branchPtr(Below, reg, tagTypeNumberRegister);
 #else
     return branchTest32(Zero, reg, Imm32(JSImmediate::TagTypeNumber));
@@ -789,7 +789,7 @@ ALWAYS_INLINE void JIT::emitJumpSlowCaseIfNotImmediateNumber(RegisterID reg)
     addSlowCase(emitJumpIfNotImmediateNumber(reg));
 }
 
-#if !USE(JSVALUE64)
+#if !(defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
 ALWAYS_INLINE void JIT::emitFastArithDeTagImmediate(RegisterID reg)
 {
     subPtr(Imm32(JSImmediate::TagTypeNumber), reg);
@@ -803,7 +803,7 @@ ALWAYS_INLINE JIT::Jump JIT::emitFastArithDeTagImmediateJumpIfZero(RegisterID re
 
 ALWAYS_INLINE void JIT::emitFastArithReTagImmediate(RegisterID src, RegisterID dest)
 {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     emitFastArithIntToImmNoCheck(src, dest);
 #else
     if (src != dest)
@@ -814,7 +814,7 @@ ALWAYS_INLINE void JIT::emitFastArithReTagImmediate(RegisterID src, RegisterID d
 
 ALWAYS_INLINE void JIT::emitFastArithImmToInt(RegisterID reg)
 {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     UNUSED_PARAM(reg);
 #else
     rshift32(Imm32(JSImmediate::IntegerPayloadShift), reg);
@@ -824,7 +824,7 @@ ALWAYS_INLINE void JIT::emitFastArithImmToInt(RegisterID reg)
 // operand is int32_t, must have been zero-extended if register is 64-bit.
 ALWAYS_INLINE void JIT::emitFastArithIntToImmNoCheck(RegisterID src, RegisterID dest)
 {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     if (src != dest)
         move(src, dest);
     orPtr(tagTypeNumberRegister, dest);
@@ -858,10 +858,10 @@ ALWAYS_INLINE void JIT::emitPutJITStubArgFromVirtualRegister(unsigned src, unsig
     killLastResultRegister();
 }
 
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
 
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITOpcodes.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITOpcodes.cpp
index 601f2d6..4573e5e 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITOpcodes.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITOpcodes.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "JIT.h"
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 #include "JITInlineMethods.h"
 #include "JITStubCall.h"
@@ -38,11 +38,11 @@
 
 namespace JSC {
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executablePool, JSGlobalData* globalData, CodePtr* ctiStringLengthTrampoline, CodePtr* ctiVirtualCallLink, CodePtr* ctiVirtualCall, CodePtr* ctiNativeCallThunk)
 {
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     // (1) This function provides fast property access for string length
     Label stringLengthBegin = align();
     
@@ -63,7 +63,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
 
     // (2) Trampolines for the slow cases of op_call / op_call_eval / op_construct.
 
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
     // VirtualCallLink Trampoline
     // regT0 holds callee, regT1 holds argCount.  regT2 will hold the FunctionExecutable.
     Label virtualCallLinkBegin = align();
@@ -101,7 +101,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     Call callLazyLinkCall = call();
     restoreReturnAddressBeforeReturn(regT3);
     jump(regT0);
-#endif // ENABLE(JIT_OPTIMIZE_CALL)
+#endif // (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
     // VirtualCall Trampoline
     // regT0 holds callee, regT1 holds argCount.  regT2 will hold the FunctionExecutable.
@@ -137,7 +137,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     loadPtr(Address(regT2, OBJECT_OFFSETOF(FunctionExecutable, m_jitCode)), regT0);
     jump(regT0);
 
-#if CPU(X86) || CPU(ARM_TRADITIONAL)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
     Label nativeCallThunk = align();
     preserveReturnAddressAfterCall(regT0);
     emitPutToCallFrameHeader(regT0, RegisterFile::ReturnPC); // Push return address
@@ -148,7 +148,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     emitGetFromCallFrameHeaderPtr(RegisterFile::ScopeChain, regT1, regT1);
     emitPutToCallFrameHeader(regT1, RegisterFile::ScopeChain);
     
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
     emitGetFromCallFrameHeader32(RegisterFile::ArgumentCount, regT0);
 
     /* We have two structs that we use to describe the stackframe we set up for our
@@ -160,11 +160,11 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
      * stack pointer by the right amount after the call.
      */
 
-#if COMPILER(MSVC) || OS(LINUX)
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_OS_LINUX && WTF_OS_LINUX)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma pack(push)
 #pragma pack(4)
-#endif // COMPILER(MSVC)
+#endif // (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     struct NativeCallFrameStructure {
       //  CallFrame* callFrame; // passed in EDX
         JSObject* callee;
@@ -178,9 +178,9 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
         JSValue thisValue;
         ArgList* argPointer;
     };
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma pack(pop)
-#endif // COMPILER(MSVC)
+#endif // (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #else
     struct NativeCallFrameStructure {
       //  CallFrame* callFrame; // passed in ECX
@@ -223,7 +223,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     storePtr(regT2, Address(stackPointerRegister, OBJECT_OFFSETOF(NativeCallFrameStructure, thisValue) + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
     storePtr(regT3, Address(stackPointerRegister, OBJECT_OFFSETOF(NativeCallFrameStructure, thisValue) + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 
-#if COMPILER(MSVC) || OS(LINUX)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_OS_LINUX && WTF_OS_LINUX)
     // ArgList is passed by reference so is stackPointerRegister + 4 * sizeof(Register)
     addPtr(Imm32(OBJECT_OFFSETOF(NativeCallFrameStructure, result)), stackPointerRegister, X86Registers::ecx);
 
@@ -248,7 +248,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     // so pull them off now
     addPtr(Imm32(NativeCallFrameSize - sizeof(NativeFunctionCalleeSignature)), stackPointerRegister);
 
-#elif CPU(ARM_TRADITIONAL)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
     emitGetFromCallFrameHeader32(RegisterFile::ArgumentCount, regT0);
 
     // Allocate stack space for our arglist
@@ -334,13 +334,13 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     restoreReturnAddressBeforeReturn(regT2);
     ret();
 
-#elif ENABLE(JIT_OPTIMIZE_NATIVE_CALL)
+#elif (defined ENABLE_JIT_OPTIMIZE_NATIVE_CALL && ENABLE_JIT_OPTIMIZE_NATIVE_CALL)
 #error "JIT_OPTIMIZE_NATIVE_CALL not yet supported on this platform."
 #else
     breakpoint();
 #endif
     
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     Call string_failureCases1Call = makeTailRecursiveCall(string_failureCases1);
     Call string_failureCases2Call = makeTailRecursiveCall(string_failureCases2);
     Call string_failureCases3Call = makeTailRecursiveCall(string_failureCases3);
@@ -349,14 +349,14 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     // All trampolines constructed! copy the code, link up calls, and set the pointers on the Machine object.
     LinkBuffer patchBuffer(this, m_globalData->executableAllocator.poolForSize(m_assembler.size()));
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     patchBuffer.link(string_failureCases1Call, FunctionPtr(cti_op_get_by_id_string_fail));
     patchBuffer.link(string_failureCases2Call, FunctionPtr(cti_op_get_by_id_string_fail));
     patchBuffer.link(string_failureCases3Call, FunctionPtr(cti_op_get_by_id_string_fail));
 #endif
     patchBuffer.link(callArityCheck1, FunctionPtr(cti_op_call_arityCheck));
     patchBuffer.link(callJSFunction1, FunctionPtr(cti_op_call_JSFunction));
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
     patchBuffer.link(callArityCheck2, FunctionPtr(cti_op_call_arityCheck));
     patchBuffer.link(callJSFunction2, FunctionPtr(cti_op_call_JSFunction));
     patchBuffer.link(callLazyLinkCall, FunctionPtr(cti_vm_lazyLinkCall));
@@ -367,12 +367,12 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
 
     *ctiVirtualCall = trampolineAt(finalCode, virtualCallBegin);
     *ctiNativeCallThunk = trampolineAt(finalCode, nativeCallThunk);
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     *ctiStringLengthTrampoline = trampolineAt(finalCode, stringLengthBegin);
 #else
     UNUSED_PARAM(ctiStringLengthTrampoline);
 #endif
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
     *ctiVirtualCallLink = trampolineAt(finalCode, virtualCallLinkBegin);
 #else
     UNUSED_PARAM(ctiVirtualCallLink);
@@ -1495,14 +1495,14 @@ void JIT::emit_op_profile_did_call(Instruction* currentInstruction)
     noProfiler.link(this);
 }
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 #define RECORD_JUMP_TARGET(targetOffset) \
    do { m_labels[m_bytecodeIndex + (targetOffset)].used(); } while (false)
 
 void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executablePool, JSGlobalData* globalData, CodePtr* ctiStringLengthTrampoline, CodePtr* ctiVirtualCallLink, CodePtr* ctiVirtualCall, CodePtr* ctiNativeCallThunk)
 {
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     // (2) The second function provides fast property access for string length
     Label stringLengthBegin = align();
 
@@ -1606,7 +1606,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     emitPutToCallFrameHeader(regT1, RegisterFile::ScopeChain);
     
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     emitGetFromCallFrameHeader32(RegisterFile::ArgumentCount, X86Registers::ecx);
 
     // Allocate stack space for our arglist
@@ -1642,7 +1642,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     call(Address(X86Registers::esi, OBJECT_OFFSETOF(JSFunction, m_data)));
     
     addPtr(Imm32(sizeof(ArgList)), stackPointerRegister);
-#elif CPU(X86)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86)
     emitGetFromCallFrameHeader32(RegisterFile::ArgumentCount, regT0);
 
     /* We have two structs that we use to describe the stackframe we set up for our
@@ -1653,7 +1653,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
      * not the rest of the callframe so we need a nice way to ensure we increment the
      * stack pointer by the right amount after the call.
      */
-#if COMPILER(MSVC) || OS(LINUX)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_OS_LINUX && WTF_OS_LINUX)
     struct NativeCallFrameStructure {
       //  CallFrame* callFrame; // passed in EDX
         JSObject* callee;
@@ -1706,7 +1706,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     loadPtr(Address(regT1, -(int)sizeof(Register)), regT1);
     storePtr(regT1, Address(stackPointerRegister, OBJECT_OFFSETOF(NativeCallFrameStructure, thisValue)));
 
-#if COMPILER(MSVC) || OS(LINUX)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_OS_LINUX && WTF_OS_LINUX)
     // ArgList is passed by reference so is stackPointerRegister + 4 * sizeof(Register)
     addPtr(Imm32(OBJECT_OFFSETOF(NativeCallFrameStructure, result)), stackPointerRegister, X86Registers::ecx);
 
@@ -1734,7 +1734,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     // so pull them off now
     addPtr(Imm32(NativeCallFrameSize - sizeof(NativeFunctionCalleeSignature)), stackPointerRegister);
 
-#elif CPU(ARM)
+#elif (defined WTF_CPU_ARM && WTF_CPU_ARM)
     emitGetFromCallFrameHeader32(RegisterFile::ArgumentCount, regT0);
 
     // Allocate stack space for our arglist
@@ -1774,7 +1774,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
 
     addPtr(Imm32(sizeof(ArgList)), stackPointerRegister);
 
-#elif ENABLE(JIT_OPTIMIZE_NATIVE_CALL)
+#elif (defined ENABLE_JIT_OPTIMIZE_NATIVE_CALL && ENABLE_JIT_OPTIMIZE_NATIVE_CALL)
 #error "JIT_OPTIMIZE_NATIVE_CALL not yet supported on this platform."
 #else
     breakpoint();
@@ -1807,7 +1807,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     ret();
     
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     Call string_failureCases1Call = makeTailRecursiveCall(string_failureCases1);
     Call string_failureCases2Call = makeTailRecursiveCall(string_failureCases2);
     Call string_failureCases3Call = makeTailRecursiveCall(string_failureCases3);
@@ -1816,14 +1816,14 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     // All trampolines constructed! copy the code, link up calls, and set the pointers on the Machine object.
     LinkBuffer patchBuffer(this, m_globalData->executableAllocator.poolForSize(m_assembler.size()));
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     patchBuffer.link(string_failureCases1Call, FunctionPtr(cti_op_get_by_id_string_fail));
     patchBuffer.link(string_failureCases2Call, FunctionPtr(cti_op_get_by_id_string_fail));
     patchBuffer.link(string_failureCases3Call, FunctionPtr(cti_op_get_by_id_string_fail));
 #endif
     patchBuffer.link(callArityCheck1, FunctionPtr(cti_op_call_arityCheck));
     patchBuffer.link(callJSFunction1, FunctionPtr(cti_op_call_JSFunction));
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
     patchBuffer.link(callArityCheck2, FunctionPtr(cti_op_call_arityCheck));
     patchBuffer.link(callJSFunction2, FunctionPtr(cti_op_call_JSFunction));
     patchBuffer.link(callLazyLinkCall, FunctionPtr(cti_vm_lazyLinkCall));
@@ -1835,7 +1835,7 @@ void JIT::privateCompileCTIMachineTrampolines(RefPtr<ExecutablePool>* executable
     *ctiVirtualCallLink = trampolineAt(finalCode, virtualCallLinkBegin);
     *ctiVirtualCall = trampolineAt(finalCode, virtualCallBegin);
     *ctiNativeCallThunk = trampolineAt(finalCode, nativeCallThunk);
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
     *ctiStringLengthTrampoline = trampolineAt(finalCode, stringLengthBegin);
 #else
     UNUSED_PARAM(ctiStringLengthTrampoline);
@@ -1890,7 +1890,7 @@ void JIT::emit_op_loop_if_lesseq(Instruction* currentInstruction)
     if (isOperandConstantImmediateInt(op2)) {
         emitGetVirtualRegister(op1, regT0);
         emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         int32_t op2imm = getConstantOperandImmediateInt(op2);
 #else
         int32_t op2imm = static_cast<int32_t>(JSImmediate::rawValue(getConstantOperand(op2)));
@@ -2279,7 +2279,7 @@ void JIT::emit_op_bitnot(Instruction* currentInstruction)
 {
     emitGetVirtualRegister(currentInstruction[2].u.operand, regT0);
     emitJumpSlowCaseIfNotImmediateInteger(regT0);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     not32(regT0);
     emitFastArithIntToImmNoCheck(regT0, regT0);
 #else
@@ -2427,7 +2427,7 @@ void JIT::emit_op_next_pname(Instruction* currentInstruction)
     loadPtr(addressFor(it), regT1);
     loadPtr(Address(regT1, OBJECT_OFFSETOF(JSPropertyNameIterator, m_jsStrings)), regT2);
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     loadPtr(BaseIndex(regT2, regT0, TimesEight), regT2);
 #else
     loadPtr(BaseIndex(regT2, regT0, TimesFour), regT2);
@@ -2991,8 +2991,8 @@ void JIT::emitSlow_op_to_jsnumber(Instruction* currentInstruction, Vector<SlowCa
     stubCall.call(currentInstruction[1].u.operand);
 }
 
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITPropertyAccess.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITPropertyAccess.cpp
index ef95f99..d3ff588 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITPropertyAccess.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITPropertyAccess.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "JIT.h"
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 #include "CodeBlock.h"
 #include "JITInlineMethods.h"
@@ -48,7 +48,7 @@ using namespace std;
 
 namespace JSC {
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 void JIT::emit_op_put_by_index(Instruction* currentInstruction)
 {
@@ -102,14 +102,14 @@ void JIT::emit_op_del_by_id(Instruction* currentInstruction)
 }
 
 
-#if !ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if !(defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
-/* ------------------------------ BEGIN: !ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
+/* ------------------------------ BEGIN: !(defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
 
 // Treat these as nops - the call will be handed as a regular get_by_id/op_call pair.
 void JIT::emit_op_method_check(Instruction*) {}
 void JIT::emitSlow_op_method_check(Instruction*, Vector<SlowCaseEntry>::iterator&) { ASSERT_NOT_REACHED(); }
-#if ENABLE(JIT_OPTIMIZE_METHOD_CALLS)
+#if (defined ENABLE_JIT_OPTIMIZE_METHOD_CALLS && ENABLE_JIT_OPTIMIZE_METHOD_CALLS)
 #error "JIT_OPTIMIZE_METHOD_CALLS requires JIT_OPTIMIZE_PROPERTY_ACCESS"
 #endif
 
@@ -189,11 +189,11 @@ void JIT::emitSlow_op_put_by_id(Instruction*, Vector<SlowCaseEntry>::iterator&)
     ASSERT_NOT_REACHED();
 }
 
-#else // !ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#else // !(defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
-/* ------------------------------ BEGIN: ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
+/* ------------------------------ BEGIN: (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
 
-#if ENABLE(JIT_OPTIMIZE_METHOD_CALLS)
+#if (defined ENABLE_JIT_OPTIMIZE_METHOD_CALLS && ENABLE_JIT_OPTIMIZE_METHOD_CALLS)
 
 void JIT::emit_op_method_check(Instruction* currentInstruction)
 {
@@ -260,7 +260,7 @@ void JIT::emitSlow_op_method_check(Instruction* currentInstruction, Vector<SlowC
     m_bytecodeIndex += OPCODE_LENGTH(op_get_by_id);
 }
 
-#else //!ENABLE(JIT_OPTIMIZE_METHOD_CALLS)
+#else //!(defined ENABLE_JIT_OPTIMIZE_METHOD_CALLS && ENABLE_JIT_OPTIMIZE_METHOD_CALLS)
 
 // Treat these as nops - the call will be handed as a regular get_by_id/op_call pair.
 void JIT::emit_op_method_check(Instruction*) {}
@@ -730,7 +730,7 @@ void JIT::privateCompileGetByIdProto(StructureStubInfo* stubInfo, Structure* str
 
     // Check the prototype object's Structure had not changed.
     Structure** prototypeStructureAddress = &(protoObject->m_structure);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     move(ImmPtr(prototypeStructure), regT3);
     Jump failureCases2 = branchPtr(NotEqual, AbsoluteAddress(prototypeStructureAddress), regT3);
 #else
@@ -810,7 +810,7 @@ void JIT::privateCompileGetByIdProtoList(StructureStubInfo* stubInfo, Polymorphi
 
     // Check the prototype object's Structure had not changed.
     Structure** prototypeStructureAddress = &(protoObject->m_structure);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     move(ImmPtr(prototypeStructure), regT3);
     Jump failureCases2 = branchPtr(NotEqual, AbsoluteAddress(prototypeStructureAddress), regT3);
 #else
@@ -863,7 +863,7 @@ void JIT::privateCompileGetByIdChainList(StructureStubInfo* stubInfo, Polymorphi
 
         // Check the prototype object's Structure had not changed.
         Structure** prototypeStructureAddress = &(protoObject->m_structure);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         move(ImmPtr(currStructure), regT3);
         bucketsOfFail.append(branchPtr(NotEqual, AbsoluteAddress(prototypeStructureAddress), regT3));
 #else
@@ -918,7 +918,7 @@ void JIT::privateCompileGetByIdChain(StructureStubInfo* stubInfo, Structure* str
 
         // Check the prototype object's Structure had not changed.
         Structure** prototypeStructureAddress = &(protoObject->m_structure);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         move(ImmPtr(currStructure), regT3);
         bucketsOfFail.append(branchPtr(NotEqual, AbsoluteAddress(prototypeStructureAddress), regT3));
 #else
@@ -951,9 +951,9 @@ void JIT::privateCompileGetByIdChain(StructureStubInfo* stubInfo, Structure* str
     repatchBuffer.relinkCallerToFunction(returnAddress, FunctionPtr(cti_op_get_by_id_proto_list));
 }
 
-/* ------------------------------ END: !ENABLE / ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
+/* ------------------------------ END: !ENABLE / (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
 
-#endif // !ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#endif // !(defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
 void JIT::compileGetDirectOffset(RegisterID base, RegisterID resultTag, RegisterID resultPayload, RegisterID structure, RegisterID offset)
 {
@@ -1018,7 +1018,7 @@ void JIT::emitSlow_op_get_by_pname(Instruction* currentInstruction, Vector<SlowC
     stubCall.call(dst);
 }
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 void JIT::emit_op_get_by_val(Instruction* currentInstruction)
 {
@@ -1028,7 +1028,7 @@ void JIT::emit_op_get_by_val(Instruction* currentInstruction)
 
     emitGetVirtualRegisters(base, regT0, property, regT1);
     emitJumpSlowCaseIfNotImmediateInteger(regT1);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     // This is technically incorrect - we're zero-extending an int32.  On the hot path this doesn't matter.
     // We check the value as if it was a uint32 against the m_vectorLength - which will always fail if
     // number was signed since m_vectorLength is always less than intmax (since the total allocation
@@ -1115,7 +1115,7 @@ void JIT::emit_op_put_by_val(Instruction* currentInstruction)
 
     emitGetVirtualRegisters(base, regT0, property, regT1);
     emitJumpSlowCaseIfNotImmediateInteger(regT1);
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     // See comment in op_get_by_val.
     zeroExtend32ToPtr(regT1, regT1);
 #else
@@ -1182,14 +1182,14 @@ void JIT::emit_op_del_by_id(Instruction* currentInstruction)
 }
 
 
-#if !ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if !(defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
-/* ------------------------------ BEGIN: !ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
+/* ------------------------------ BEGIN: !(defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
 
 // Treat these as nops - the call will be handed as a regular get_by_id/op_call pair.
 void JIT::emit_op_method_check(Instruction*) {}
 void JIT::emitSlow_op_method_check(Instruction*, Vector<SlowCaseEntry>::iterator&) { ASSERT_NOT_REACHED(); }
-#if ENABLE(JIT_OPTIMIZE_METHOD_CALLS)
+#if (defined ENABLE_JIT_OPTIMIZE_METHOD_CALLS && ENABLE_JIT_OPTIMIZE_METHOD_CALLS)
 #error "JIT_OPTIMIZE_METHOD_CALLS requires JIT_OPTIMIZE_PROPERTY_ACCESS"
 #endif
 
@@ -1235,11 +1235,11 @@ void JIT::emitSlow_op_put_by_id(Instruction*, Vector<SlowCaseEntry>::iterator&)
     ASSERT_NOT_REACHED();
 }
 
-#else // !ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#else // !(defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
-/* ------------------------------ BEGIN: ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
+/* ------------------------------ BEGIN: (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
 
-#if ENABLE(JIT_OPTIMIZE_METHOD_CALLS)
+#if (defined ENABLE_JIT_OPTIMIZE_METHOD_CALLS && ENABLE_JIT_OPTIMIZE_METHOD_CALLS)
 
 void JIT::emit_op_method_check(Instruction* currentInstruction)
 {
@@ -1305,7 +1305,7 @@ void JIT::emitSlow_op_method_check(Instruction* currentInstruction, Vector<SlowC
     m_bytecodeIndex += OPCODE_LENGTH(op_get_by_id);
 }
 
-#else //!ENABLE(JIT_OPTIMIZE_METHOD_CALLS)
+#else //!(defined ENABLE_JIT_OPTIMIZE_METHOD_CALLS && ENABLE_JIT_OPTIMIZE_METHOD_CALLS)
 
 // Treat these as nops - the call will be handed as a regular get_by_id/op_call pair.
 void JIT::emit_op_method_check(Instruction*) {}
@@ -1676,7 +1676,7 @@ void JIT::privateCompileGetByIdProto(StructureStubInfo* stubInfo, Structure* str
 
     // Check the prototype object's Structure had not changed.
     Structure** prototypeStructureAddress = &(protoObject->m_structure);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     move(ImmPtr(prototypeStructure), regT3);
     Jump failureCases2 = branchPtr(NotEqual, AbsoluteAddress(prototypeStructureAddress), regT3);
 #else
@@ -1751,7 +1751,7 @@ void JIT::privateCompileGetByIdProtoList(StructureStubInfo* stubInfo, Polymorphi
 
     // Check the prototype object's Structure had not changed.
     Structure** prototypeStructureAddress = &(protoObject->m_structure);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     move(ImmPtr(prototypeStructure), regT3);
     Jump failureCases2 = branchPtr(NotEqual, AbsoluteAddress(prototypeStructureAddress), regT3);
 #else
@@ -1804,7 +1804,7 @@ void JIT::privateCompileGetByIdChainList(StructureStubInfo* stubInfo, Polymorphi
 
         // Check the prototype object's Structure had not changed.
         Structure** prototypeStructureAddress = &(protoObject->m_structure);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         move(ImmPtr(currStructure), regT3);
         bucketsOfFail.append(branchPtr(NotEqual, AbsoluteAddress(prototypeStructureAddress), regT3));
 #else
@@ -1857,7 +1857,7 @@ void JIT::privateCompileGetByIdChain(StructureStubInfo* stubInfo, Structure* str
 
         // Check the prototype object's Structure had not changed.
         Structure** prototypeStructureAddress = &(protoObject->m_structure);
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         move(ImmPtr(currStructure), regT3);
         bucketsOfFail.append(branchPtr(NotEqual, AbsoluteAddress(prototypeStructureAddress), regT3));
 #else
@@ -1890,12 +1890,12 @@ void JIT::privateCompileGetByIdChain(StructureStubInfo* stubInfo, Structure* str
     repatchBuffer.relinkCallerToFunction(returnAddress, FunctionPtr(cti_op_get_by_id_proto_list));
 }
 
-/* ------------------------------ END: !ENABLE / ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
+/* ------------------------------ END: !ENABLE / (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS) ------------------------------ */
 
-#endif // !ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#endif // !(defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubCall.h b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubCall.h
index cfbd7dc..56bf34a 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubCall.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubCall.h
@@ -28,7 +28,7 @@
 
 #include "MacroAssemblerCodeRef.h"
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 namespace JSC {
 
@@ -82,7 +82,7 @@ namespace JSC {
         {
         }
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         JITStubCall(JIT* jit, EncodedJSValue (JIT_STUB *stub)(STUB_ARGS_DECLARATION))
             : m_jit(jit)
             , m_stub(stub)
@@ -131,7 +131,7 @@ namespace JSC {
             m_stackIndex += stackIndexStep;
         }
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         void addArgument(unsigned srcVirtualRegister)
         {
             if (m_jit->m_codeBlock->isConstantRegisterIndex(srcVirtualRegister)) {
@@ -164,7 +164,7 @@ namespace JSC {
 
         JIT::Call call()
         {
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
             if (m_jit->m_bytecodeIndex != (unsigned)-1)
                 m_jit->sampleInstruction(m_jit->m_codeBlock->instructions().begin() + m_jit->m_bytecodeIndex, true);
 #endif
@@ -173,12 +173,12 @@ namespace JSC {
             JIT::Call call = m_jit->call();
             m_jit->m_calls.append(CallRecord(call, m_jit->m_bytecodeIndex, m_stub.value()));
 
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
             if (m_jit->m_bytecodeIndex != (unsigned)-1)
                 m_jit->sampleInstruction(m_jit->m_codeBlock->instructions().begin() + m_jit->m_bytecodeIndex, false);
 #endif
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
             m_jit->unmap();
 #else
             m_jit->killLastResultRegister();
@@ -186,7 +186,7 @@ namespace JSC {
             return call;
         }
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         JIT::Call call(unsigned dst) // dst is a virtual register.
         {
             ASSERT(m_returnType == Value || m_returnType == Cell);
@@ -209,7 +209,7 @@ namespace JSC {
 
         JIT::Call call(JIT::RegisterID dst) // dst is a machine register.
         {
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
             ASSERT(m_returnType == Value || m_returnType == VoidPtr || m_returnType == Int || m_returnType == Cell);
 #else
             ASSERT(m_returnType == VoidPtr || m_returnType == Int || m_returnType == Cell);
@@ -230,6 +230,6 @@ namespace JSC {
     };
 }
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
 
 #endif // JITStubCall_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubs.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubs.cpp
index d8027ff..3dd838c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubs.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubs.cpp
@@ -30,7 +30,7 @@
 #include "config.h"
 #include "JITStubs.h"
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 #include "Arguments.h"
 #include "CallFrame.h"
@@ -68,46 +68,46 @@ using namespace std;
 
 namespace JSC {
 
-#if OS(DARWIN) || OS(WINDOWS)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN) || (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #define SYMBOL_STRING(name) "_" #name
 #else
 #define SYMBOL_STRING(name) #name
 #endif
 
-#if OS(IPHONE_OS)
+#if (defined WTF_OS_IPHONE_OS && WTF_OS_IPHONE_OS)
 #define THUMB_FUNC_PARAM(name) SYMBOL_STRING(name)
 #else
 #define THUMB_FUNC_PARAM(name)
 #endif
 
-#if OS(LINUX) && CPU(X86_64)
+#if (defined WTF_OS_LINUX && WTF_OS_LINUX) && (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 #define SYMBOL_STRING_RELOCATION(name) #name "@plt"
 #else
 #define SYMBOL_STRING_RELOCATION(name) SYMBOL_STRING(name)
 #endif
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     // Mach-O platform
 #define HIDE_SYMBOL(name) ".private_extern _" #name
-#elif OS(AIX)
+#elif (defined WTF_OS_AIX && WTF_OS_AIX)
     // IBM's own file format
 #define HIDE_SYMBOL(name) ".lglobl " #name
-#elif   OS(LINUX)               \
-     || OS(FREEBSD)             \
-     || OS(OPENBSD)             \
-     || OS(SOLARIS)             \
-     || (OS(HPUX) && CPU(IA64)) \
-     || OS(SYMBIAN)             \
-     || OS(NETBSD)
+#elif   (defined WTF_OS_LINUX && WTF_OS_LINUX)               \
+     || (defined WTF_OS_FREEBSD && WTF_OS_FREEBSD)             \
+     || (defined WTF_OS_OPENBSD && WTF_OS_OPENBSD)             \
+     || (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)             \
+     || ((defined WTF_OS_HPUX && WTF_OS_HPUX) && (defined WTF_CPU_IA64 && WTF_CPU_IA64)) \
+     || (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)             \
+     || (defined WTF_OS_NETBSD && WTF_OS_NETBSD)
     // ELF platform
 #define HIDE_SYMBOL(name) ".hidden " #name
 #else
 #define HIDE_SYMBOL(name)
 #endif
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
-#if COMPILER(GCC) && CPU(X86)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_X86 && WTF_CPU_X86)
 
 // These ASSERTs remind you that, if you change the layout of JITStackFrame, you
 // need to change the assembly trampolines below to match.
@@ -142,7 +142,7 @@ asm volatile (
 ".globl " SYMBOL_STRING(ctiVMThrowTrampoline) "\n"
 HIDE_SYMBOL(ctiVMThrowTrampoline) "\n"
 SYMBOL_STRING(ctiVMThrowTrampoline) ":" "\n"
-#if !USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if !(defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
     "movl %esp, %ecx" "\n"
 #endif
     "call " SYMBOL_STRING_RELOCATION(cti_vm_throw) "\n"
@@ -166,9 +166,9 @@ SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
     "ret" "\n"
 );
     
-#elif COMPILER(GCC) && CPU(X86_64)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
 #error "JIT_STUB_ARGUMENT_VA_LIST not supported on x86-64."
 #endif
 
@@ -236,9 +236,9 @@ SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
     "ret" "\n"
 );
 
-#elif COMPILER(GCC) && CPU(ARM_THUMB2)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
 #error "JIT_STUB_ARGUMENT_VA_LIST not supported on ARMv7."
 #endif
 
@@ -303,7 +303,7 @@ SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
     "bx lr" "\n"
 );
 
-#elif COMPILER(GCC) && CPU(ARM_TRADITIONAL)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 asm volatile (
 ".globl " SYMBOL_STRING(ctiTrampoline) "\n"
@@ -340,9 +340,9 @@ SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
     "mov pc, lr" "\n"
 );
 
-#elif COMPILER(MSVC) && CPU(X86)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && (defined WTF_CPU_X86 && WTF_CPU_X86)
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
 #error "JIT_STUB_ARGUMENT_VA_LIST configuration not supported on MSVC."
 #endif
 
@@ -408,9 +408,9 @@ extern "C" {
     #error "JIT not supported on this platform."
 #endif
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
-#if COMPILER(GCC) && CPU(X86)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_X86 && WTF_CPU_X86)
 
 // These ASSERTs remind you that, if you change the layout of JITStackFrame, you
 // need to change the assembly trampolines below to match.
@@ -444,7 +444,7 @@ asm volatile (
 ".globl " SYMBOL_STRING(ctiVMThrowTrampoline) "\n"
 HIDE_SYMBOL(ctiVMThrowTrampoline) "\n"
 SYMBOL_STRING(ctiVMThrowTrampoline) ":" "\n"
-#if !USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if !(defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
     "movl %esp, %ecx" "\n"
 #endif
     "call " SYMBOL_STRING_RELOCATION(cti_vm_throw) "\n"
@@ -468,9 +468,9 @@ SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
     "ret" "\n"
 );
     
-#elif COMPILER(GCC) && CPU(X86_64)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
 #error "JIT_STUB_ARGUMENT_VA_LIST not supported on x86-64."
 #endif
 
@@ -545,9 +545,9 @@ SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
     "ret" "\n"
 );
 
-#elif COMPILER(GCC) && CPU(ARM_THUMB2)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
 #error "JIT_STUB_ARGUMENT_VA_LIST not supported on ARMv7."
 #endif
 
@@ -612,7 +612,7 @@ SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
     "bx lr" "\n"
 );
 
-#elif COMPILER(GCC) && CPU(ARM_TRADITIONAL)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 asm volatile (
 ".text\n"
@@ -649,7 +649,7 @@ SYMBOL_STRING(ctiOpThrowNotCaught) ":" "\n"
     "mov pc, lr" "\n"
 );
 
-#elif COMPILER(RVCT) && CPU(ARM_TRADITIONAL)
+#elif (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT) && (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
 
 __asm EncodedJSValue ctiTrampoline(void*, RegisterFile*, CallFrame*, JSValue*, Profiler**, JSGlobalData*)
 {
@@ -688,9 +688,9 @@ __asm void ctiOpThrowNotCaught()
     bx lr
 }
 
-#elif COMPILER(MSVC) && CPU(X86)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && (defined WTF_CPU_X86 && WTF_CPU_X86)
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
 #error "JIT_STUB_ARGUMENT_VA_LIST configuration not supported on MSVC."
 #endif
 
@@ -755,9 +755,9 @@ extern "C" {
     #error "JIT not supported on this platform."
 #endif
 
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
-#if ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     #define CTI_SAMPLER stackFrame.globalData->interpreter->sampler()
 #else
     #define CTI_SAMPLER 0
@@ -767,7 +767,7 @@ JITThunks::JITThunks(JSGlobalData* globalData)
 {
     JIT::compileCTIMachineTrampolines(globalData, &m_executablePool, &m_ctiStringLengthTrampoline, &m_ctiVirtualCallLink, &m_ctiVirtualCall, &m_ctiNativeCallThunk);
 
-#if CPU(ARM_THUMB2)
+#if (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
     // Unfortunate the arm compiler does not like the use of offsetof on JITStackFrame (since it contains non POD types),
     // and the OBJECT_OFFSETOF macro does not appear constantish enough for it to be happy with its use in COMPILE_ASSERT
     // macros.
@@ -786,7 +786,7 @@ JITThunks::JITThunks(JSGlobalData* globalData)
 #endif
 }
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
 NEVER_INLINE void JITThunks::tryCachePutByID(CallFrame* callFrame, CodeBlock* codeBlock, ReturnAddressPtr returnAddress, JSValue baseValue, const PutPropertySlot& slot, StructureStubInfo* stubInfo)
 {
@@ -925,9 +925,9 @@ NEVER_INLINE void JITThunks::tryCacheGetByID(CallFrame* callFrame, CodeBlock* co
     JIT::compileGetByIdChain(callFrame->scopeChain()->globalData, callFrame, codeBlock, stubInfo, structure, prototypeChain, count, offset, returnAddress);
 }
 
-#endif // ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#endif // (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
 #define SETUP_VA_LISTL_ARGS va_list vl_args; va_start(vl_args, args)
 #else
 #define SETUP_VA_LISTL_ARGS
@@ -1018,7 +1018,7 @@ static NEVER_INLINE void throwStackOverflowError(CallFrame* callFrame, JSGlobalD
         } \
     } while (0)
 
-#if CPU(ARM_THUMB2)
+#if (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
 
 #define DEFINE_STUB_FUNCTION(rtype, op) \
     extern "C" { \
@@ -1039,9 +1039,9 @@ static NEVER_INLINE void throwStackOverflowError(CallFrame* callFrame, JSGlobalD
         ); \
     rtype JITStubThunked_##op(STUB_ARGS_DECLARATION) \
 
-#elif CPU(ARM_TRADITIONAL) && COMPILER(GCC)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL) && (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 #define THUNK_RETURN_ADDRESS_OFFSET 64
 #else
 #define THUNK_RETURN_ADDRESS_OFFSET 32
@@ -1064,7 +1064,7 @@ COMPILE_ASSERT(offsetof(struct JITStackFrame, thunkReturnAddress) == THUNK_RETUR
         ); \
     rtype JITStubThunked_##op(STUB_ARGS_DECLARATION)
 
-#elif CPU(ARM_TRADITIONAL) && COMPILER(RVCT)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL) && (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
 
 #define DEFINE_STUB_FUNCTION(rtype, op) rtype JITStubThunked_##op(STUB_ARGS_DECLARATION)
 
@@ -1094,7 +1094,7 @@ RVCT()
 #define DEFINE_STUB_FUNCTION(rtype, op) rtype JIT_STUB cti_##op(STUB_ARGS_DECLARATION)
 #endif
 
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #pragma GCC visibility push(hidden)
 #endif
 
@@ -1240,7 +1240,7 @@ DEFINE_STUB_FUNCTION(EncodedJSValue, op_get_by_id_generic)
     return JSValue::encode(result);
 }
 
-#if ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#if (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
 DEFINE_STUB_FUNCTION(void, op_put_by_id)
 {
@@ -1566,7 +1566,7 @@ DEFINE_STUB_FUNCTION(EncodedJSValue, op_get_by_id_string_fail)
     return JSValue::encode(result);
 }
 
-#endif // ENABLE(JIT_OPTIMIZE_PROPERTY_ACCESS)
+#endif // (defined ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS && ENABLE_JIT_OPTIMIZE_PROPERTY_ACCESS)
 
 DEFINE_STUB_FUNCTION(EncodedJSValue, op_instanceof)
 {
@@ -1714,7 +1714,7 @@ DEFINE_STUB_FUNCTION(VoidPtrPair, op_call_arityCheck)
     RETURN_POINTER_PAIR(callee, callFrame);
 }
 
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 DEFINE_STUB_FUNCTION(void*, vm_lazyLinkCall)
 {
     STUB_INIT_STACK_FRAME(stackFrame);
@@ -1734,7 +1734,7 @@ DEFINE_STUB_FUNCTION(void*, vm_lazyLinkCall)
 
     return jitCode.addressForCall().executableAddress();
 }
-#endif // !ENABLE(JIT_OPTIMIZE_CALL)
+#endif // !(defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
 
 DEFINE_STUB_FUNCTION(JSObject*, op_push_activation)
 {
@@ -2453,7 +2453,7 @@ DEFINE_STUB_FUNCTION(int, op_eq)
     JSValue src1 = stackFrame.args[0].jsValue();
     JSValue src2 = stackFrame.args[1].jsValue();
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     start:
     if (src2.isUndefined()) {
         return src1.isNull() || 
@@ -2540,16 +2540,16 @@ DEFINE_STUB_FUNCTION(int, op_eq)
     CHECK_FOR_EXCEPTION();
     goto start;
     
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     CallFrame* callFrame = stackFrame.callFrame;
     
     bool result = JSValue::equalSlowCaseInline(callFrame, src1, src2);
     CHECK_FOR_EXCEPTION_AT_END();
     return result;
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 }
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 DEFINE_STUB_FUNCTION(int, op_eq_strings)
 {
@@ -3218,10 +3218,10 @@ DEFINE_STUB_FUNCTION(EncodedJSValue, to_object)
     return JSValue::encode(stackFrame.args[0].jsValue().toObject(callFrame));
 }
 
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #pragma GCC visibility pop
 #endif
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubs.h b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubs.h
index da80133..c040c4c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubs.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jit/JITStubs.h
@@ -34,7 +34,7 @@
 #include "MacroAssemblerCodeRef.h"
 #include "Register.h"
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 namespace JSC {
 
@@ -75,7 +75,7 @@ namespace JSC {
         ReturnAddressPtr returnAddress() { return ReturnAddressPtr(asPointer); }
     };
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     struct JITStackFrame {
         void* reserved; // Unused
         JITStubArg args[6];
@@ -99,15 +99,15 @@ namespace JSC {
         // When JIT code makes a call, it pushes its return address just below the rest of the stack.
         ReturnAddressPtr* returnAddressSlot() { return reinterpret_cast<ReturnAddressPtr*>(this) - 1; }
     };
-#elif CPU(X86)
-#if COMPILER(MSVC)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma pack(push)
 #pragma pack(4)
-#endif // COMPILER(MSVC)
+#endif // (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     struct JITStackFrame {
         void* reserved; // Unused
         JITStubArg args[6];
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         void* padding[2]; // Maintain 16-byte stack alignment.
 #endif
 
@@ -127,14 +127,14 @@ namespace JSC {
         // When JIT code makes a call, it pushes its return address just below the rest of the stack.
         ReturnAddressPtr* returnAddressSlot() { return reinterpret_cast<ReturnAddressPtr*>(this) - 1; }
     };
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma pack(pop)
-#endif // COMPILER(MSVC)
-#elif CPU(ARM_THUMB2)
+#endif // (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
+#elif (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2)
     struct JITStackFrame {
         void* reserved; // Unused
         JITStubArg args[6];
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         void* padding[2]; // Maintain 16-byte stack alignment.
 #endif
 
@@ -158,7 +158,7 @@ namespace JSC {
         
         ReturnAddressPtr* returnAddressSlot() { return &thunkReturnAddress; }
     };
-#elif CPU(ARM_TRADITIONAL)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
     struct JITStackFrame {
         JITStubArg padding; // Unused
         JITStubArg args[7];
@@ -189,11 +189,11 @@ namespace JSC {
 
 #define JITSTACKFRAME_ARGS_INDEX (OBJECT_OFFSETOF(JITStackFrame, args) / sizeof(void*))
 
-#if USE(JIT_STUB_ARGUMENT_VA_LIST)
+#if (defined WTF_USE_JIT_STUB_ARGUMENT_VA_LIST && WTF_USE_JIT_STUB_ARGUMENT_VA_LIST)
     #define STUB_ARGS_DECLARATION void* args, ...
     #define STUB_ARGS (reinterpret_cast<void**>(vl_args) - 1)
 
-    #if COMPILER(MSVC)
+    #if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     #define JIT_STUB __cdecl
     #else
     #define JIT_STUB
@@ -202,16 +202,16 @@ namespace JSC {
     #define STUB_ARGS_DECLARATION void** args
     #define STUB_ARGS (args)
 
-    #if CPU(X86) && COMPILER(MSVC)
+    #if (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     #define JIT_STUB __fastcall
-    #elif CPU(X86) && COMPILER(GCC)
+    #elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
     #define JIT_STUB  __attribute__ ((fastcall))
     #else
     #define JIT_STUB
     #endif
 #endif
 
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     struct VoidPtrPair {
         void* first;
         void* second;
@@ -253,7 +253,7 @@ namespace JSC {
         MacroAssemblerCodePtr m_ctiNativeCallThunk;
     };
 
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #pragma GCC visibility push(hidden)
 #endif
 
@@ -332,7 +332,7 @@ extern "C" {
     JSPropertyNameIterator* JIT_STUB cti_op_get_pnames(STUB_ARGS_DECLARATION);
     VoidPtrPair JIT_STUB cti_op_call_arityCheck(STUB_ARGS_DECLARATION);
     int JIT_STUB cti_op_eq(STUB_ARGS_DECLARATION);
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     int JIT_STUB cti_op_eq_strings(STUB_ARGS_DECLARATION);
 #endif
     int JIT_STUB cti_op_jless(STUB_ARGS_DECLARATION);
@@ -373,12 +373,12 @@ extern "C" {
     void* JIT_STUB cti_vm_lazyLinkCall(STUB_ARGS_DECLARATION);
 } // extern "C"
 
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #pragma GCC visibility pop
 #endif
 
 } // namespace JSC
 
-#endif // ENABLE(JIT)
+#endif // (defined ENABLE_JIT && ENABLE_JIT)
 
 #endif // JITStubs_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/jsc.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/jsc.cpp
index 252fb96..f8acfa3 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/jsc.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/jsc.cpp
@@ -37,30 +37,30 @@
 #include <stdlib.h>
 #include <string.h>
 
-#if !OS(WINDOWS)
+#if !(defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #include <unistd.h>
 #endif
 
-#if HAVE(READLINE)
+#if (defined HAVE_READLINE && HAVE_READLINE)
 #include <readline/history.h>
 #include <readline/readline.h>
 #endif
 
-#if HAVE(SYS_TIME_H)
+#if (defined HAVE_SYS_TIME_H && HAVE_SYS_TIME_H)
 #include <sys/time.h>
 #endif
 
-#if HAVE(SIGNAL_H)
+#if (defined HAVE_SIGNAL_H && HAVE_SIGNAL_H)
 #include <signal.h>
 #endif
 
-#if COMPILER(MSVC) && !OS(WINCE)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && !(defined WTF_OS_WINCE && WTF_OS_WINCE)
 #include <crtdbg.h>
 #include <mmsystem.h>
 #include <windows.h>
 #endif
 
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #include <QCoreApplication>
 #include <QDateTime>
 #endif
@@ -81,7 +81,7 @@ static JSValue JSC_HOST_CALL functionCheckSyntax(ExecState*, JSObject*, JSValue,
 static JSValue JSC_HOST_CALL functionReadline(ExecState*, JSObject*, JSValue, const ArgList&);
 static NO_RETURN JSValue JSC_HOST_CALL functionQuit(ExecState*, JSObject*, JSValue, const ArgList&);
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
 static JSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState*, JSObject*, JSValue, const ArgList&);
 static JSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState*, JSObject*, JSValue, const ArgList&);
 #endif
@@ -160,7 +160,7 @@ GlobalObject::GlobalObject(const Vector<UString>& arguments)
     putDirectFunction(globalExec(), new (globalExec()) NativeFunctionWrapper(globalExec(), prototypeFunctionStructure(), 1, Identifier(globalExec(), "checkSyntax"), functionCheckSyntax));
     putDirectFunction(globalExec(), new (globalExec()) NativeFunctionWrapper(globalExec(), prototypeFunctionStructure(), 0, Identifier(globalExec(), "readline"), functionReadline));
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
     putDirectFunction(globalExec(), new (globalExec()) NativeFunctionWrapper(globalExec(), prototypeFunctionStructure(), 1, Identifier(globalExec(), "setSamplingFlags"), functionSetSamplingFlags));
     putDirectFunction(globalExec(), new (globalExec()) NativeFunctionWrapper(globalExec(), prototypeFunctionStructure(), 1, Identifier(globalExec(), "clearSamplingFlags"), functionClearSamplingFlags));
 #endif
@@ -254,7 +254,7 @@ JSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec, JSObject* o, JSValue
     return result.value();
 }
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
 JSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState* exec, JSObject*, JSValue, const ArgList& args)
 {
     for (unsigned i = 0; i < args.size(); ++i) {
@@ -300,7 +300,7 @@ JSValue JSC_HOST_CALL functionQuit(ExecState* exec, JSObject*, JSValue, const Ar
     cleanupGlobalData(&exec->globalData());
     exit(EXIT_SUCCESS);
 
-#if COMPILER(MSVC) && OS(WINCE)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && (defined WTF_OS_WINCE && WTF_OS_WINCE)
     // Without this, Visual Studio will complain that this method does not return a value.
     return jsUndefined();
 #endif
@@ -311,7 +311,7 @@ JSValue JSC_HOST_CALL functionQuit(ExecState* exec, JSObject*, JSValue, const Ar
 // be in a separate main function because the jscmain function requires object
 // unwinding.
 
-#if COMPILER(MSVC) && !defined(_DEBUG)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && !defined(_DEBUG)
 #define TRY       __try {
 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
 #else
@@ -323,7 +323,7 @@ int jscmain(int argc, char** argv, JSGlobalData*);
 
 int main(int argc, char** argv)
 {
-#if defined(_DEBUG) && OS(WINDOWS)
+#if defined(_DEBUG) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
     _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
@@ -332,11 +332,11 @@ int main(int argc, char** argv)
     _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
 #endif
 
-#if COMPILER(MSVC) && !OS(WINCE)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && !(defined WTF_OS_WINCE && WTF_OS_WINCE)
     timeBeginPeriod(1);
 #endif
 
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
     QCoreApplication app(argc, argv);
 #endif
 
@@ -373,7 +373,7 @@ static bool runWithScripts(GlobalObject* globalObject, const Vector<Script>& scr
 
     JSGlobalData* globalData = globalObject->globalData();
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
     SamplingFlags::start();
 #endif
 
@@ -404,11 +404,11 @@ static bool runWithScripts(GlobalObject* globalObject, const Vector<Script>& scr
         globalObject->globalExec()->clearException();
     }
 
-#if ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
     SamplingFlags::stop();
 #endif
     globalData->dumpSampleData(globalObject->globalExec());
-#if ENABLE(SAMPLING_COUNTERS)
+#if (defined ENABLE_SAMPLING_COUNTERS && ENABLE_SAMPLING_COUNTERS)
     AbstractSamplingCounter::dump();
 #endif
     return success;
@@ -419,7 +419,7 @@ static bool runWithScripts(GlobalObject* globalObject, const Vector<Script>& scr
 static void runInteractive(GlobalObject* globalObject)
 {
     while (true) {
-#if HAVE(READLINE) && !RUNNING_FROM_XCODE
+#if (defined HAVE_READLINE && HAVE_READLINE) && !RUNNING_FROM_XCODE
         char* line = readline(interactivePrompt);
         if (!line)
             break;
@@ -460,7 +460,7 @@ static NO_RETURN void printUsageStatement(JSGlobalData* globalData, bool help =
     fprintf(stderr, "  -f         Specifies a source file (deprecated)\n");
     fprintf(stderr, "  -h|--help  Prints this help message\n");
     fprintf(stderr, "  -i         Enables interactive mode (default if no files are specified)\n");
-#if HAVE(SIGNAL_H)
+#if (defined HAVE_SIGNAL_H && HAVE_SIGNAL_H)
     fprintf(stderr, "  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n");
 #endif
 
@@ -494,7 +494,7 @@ static void parseArguments(int argc, char** argv, Options& options, JSGlobalData
             continue;
         }
         if (!strcmp(arg, "-s")) {
-#if HAVE(SIGNAL_H)
+#if (defined HAVE_SIGNAL_H && HAVE_SIGNAL_H)
             signal(SIGILL, _exit);
             signal(SIGFPE, _exit);
             signal(SIGBUS, _exit);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/os-win32/stdbool.h b/src/3rdparty/javascriptcore/JavaScriptCore/os-win32/stdbool.h
index fc8ee28..1f037ee 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/os-win32/stdbool.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/os-win32/stdbool.h
@@ -21,7 +21,7 @@
 #ifndef STDBOOL_WIN32_H
 #define STDBOOL_WIN32_H
 
-#if !COMPILER(MSVC)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #error "This stdbool.h file should only be compiled with MSVC"
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/os-win32/stdint.h b/src/3rdparty/javascriptcore/JavaScriptCore/os-win32/stdint.h
index b5dff56..944d8c9 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/os-win32/stdint.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/os-win32/stdint.h
@@ -26,7 +26,7 @@
 /* This file emulates enough of stdint.h on Windows to make JavaScriptCore and WebCore
    compile using MSVC which does not ship with the stdint.h header. */
 
-#if !COMPILER(MSVC)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #error "This stdint.h file should only be compiled with MSVC"
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/pcre/pcre_exec.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/pcre/pcre_exec.cpp
index 8ca2eb4..78b9014 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/pcre/pcre_exec.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/pcre/pcre_exec.cpp
@@ -56,7 +56,7 @@ the JavaScript specification. There are also some supporting functions. */
 
 using namespace WTF;
 
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define USE_COMPUTED_GOTO_FOR_MATCH_RECURSION
 //#define USE_COMPUTED_GOTO_FOR_MATCH_OPCODE_LOOP
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/pcre/pcre_internal.h b/src/3rdparty/javascriptcore/JavaScriptCore/pcre/pcre_internal.h
index 0016bb5..3dfe478 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/pcre/pcre_internal.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/pcre/pcre_internal.h
@@ -74,7 +74,7 @@ total length. */
 
 #include "Assertions.h"
 
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma warning(disable: 4232)
 #pragma warning(disable: 4244)
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/profiler/ProfileNode.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/profiler/ProfileNode.cpp
index fb126b3..70e3242 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/profiler/ProfileNode.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/profiler/ProfileNode.cpp
@@ -33,7 +33,7 @@
 #include <stdio.h>
 #include <wtf/DateMath.h>
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #include <windows.h>
 #endif
 
@@ -43,7 +43,7 @@ namespace JSC {
 
 static double getCount()
 {
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     static LARGE_INTEGER frequency = {0};
     if (!frequency.QuadPart)
         QueryPerformanceFrequency(&frequency);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArgList.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArgList.h
index 8e1fdbe..a909cd7 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArgList.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArgList.h
@@ -105,7 +105,7 @@ namespace JSC {
         {
             ASSERT(!m_isReadOnly);
 
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
             ASSERT(!v.isZombie());
 #endif
 
@@ -191,7 +191,7 @@ namespace JSC {
             : m_args(args)
             , m_argCount(argCount)
         {
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
             for (size_t i = 0; i < argCount; i++)
                 ASSERT(!m_args[i].isZombie());
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArrayPrototype.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArrayPrototype.cpp
index e160364..4ccf3a5 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArrayPrototype.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArrayPrototype.cpp
@@ -72,7 +72,7 @@ static inline bool isNumericCompareFunction(ExecState* exec, CallType callType,
     if (callType != CallTypeJS)
         return false;
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     // If the JIT is enabled then we need to preserve the invariant that every
     // function with a CodeBlock also has JIT code.
     callData.js.functionExecutable->jitCode(exec, callData.js.scopeChain);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/CallData.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/CallData.h
index 32e1e52..b94479e 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/CallData.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/CallData.h
@@ -65,7 +65,7 @@ namespace JSC {
     };
 #endif
 
-#if defined(QT_BUILD_SCRIPT_LIB) && OS(SOLARIS)
+#if defined(QT_BUILD_SCRIPT_LIB) && (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)
     struct
 #else
     union
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp
index 6af1784..25e0c87 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp
@@ -45,7 +45,7 @@
 #include <wtf/UnusedParam.h>
 #include <wtf/VMTags.h>
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
 #include <mach/mach_init.h>
 #include <mach/mach_port.h>
@@ -53,34 +53,34 @@
 #include <mach/thread_act.h>
 #include <mach/vm_map.h>
 
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
 #include <windows.h>
 #include <malloc.h>
 
-#elif OS(HAIKU)
+#elif (defined WTF_OS_HAIKU && WTF_OS_HAIKU)
 
 #include <OS.h>
 
-#elif OS(UNIX)
+#elif (defined WTF_OS_UNIX && WTF_OS_UNIX)
 
 #include <stdlib.h>
-#if !OS(HAIKU)
+#if !(defined WTF_OS_HAIKU && WTF_OS_HAIKU)
 #include <sys/mman.h>
 #endif
 #include <unistd.h>
 
-#if OS(SOLARIS)
+#if (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)
 #include <thread.h>
 #else
 #include <pthread.h>
 #endif
 
-#if HAVE(PTHREAD_NP_H)
+#if (defined HAVE_PTHREAD_NP_H && HAVE_PTHREAD_NP_H)
 #include <pthread_np.h>
 #endif
 
-#if OS(QNX)
+#if (defined WTF_OS_QNX && WTF_OS_QNX)
 #include <fcntl.h>
 #include <sys/procfs.h>
 #include <stdio.h>
@@ -104,11 +104,11 @@ const size_t ALLOCATIONS_PER_COLLECTION = 3600;
 // a PIC branch in Mach-O binaries, see <rdar://problem/5971391>.
 #define MIN_ARRAY_SIZE (static_cast<size_t>(14))
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 typedef mach_port_t PlatformThread;
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 typedef HANDLE PlatformThread;
 #endif
 
@@ -131,11 +131,11 @@ public:
 
 Heap::Heap(JSGlobalData* globalData)
     : m_markListSet(0)
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     , m_registeredThreads(0)
     , m_currentThreadRegistrar(0)
 #endif
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     , m_blockallocator(WTF::AlignedBlockAllocator::instance(JSCCOLLECTOR_VIRTUALMEM_RESERVATION, BLOCK_SIZE))
 #endif
     , m_globalData(globalData)
@@ -170,7 +170,7 @@ void Heap::destroy()
 
     freeBlocks();
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     if (m_currentThreadRegistrar) {
         int error = pthread_key_delete(m_currentThreadRegistrar);
         ASSERT_UNUSED(error, !error);
@@ -188,28 +188,28 @@ void Heap::destroy()
 
 NEVER_INLINE CollectorBlock* Heap::allocateBlock()
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     vm_address_t address = 0;
     vm_map(current_task(), &address, BLOCK_SIZE, BLOCK_OFFSET_MASK, VM_FLAGS_ANYWHERE | VM_TAG_FOR_COLLECTOR_MEMORY, MEMORY_OBJECT_NULL, 0, FALSE, VM_PROT_DEFAULT, VM_PROT_DEFAULT, VM_INHERIT_DEFAULT);
-#elif OS(SYMBIAN)
+#elif (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     void* address = m_blockallocator.alloc();  
     if (!address)
         CRASH();
-#elif OS(WINCE)
+#elif (defined WTF_OS_WINCE && WTF_OS_WINCE)
     void* address = VirtualAlloc(NULL, BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
-#elif OS(WINDOWS)
-#if COMPILER(MINGW) && !COMPILER(MINGW64)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
+#if (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW) && !(defined WTF_COMPILER_MINGW64 && WTF_COMPILER_MINGW64)
     void* address = __mingw_aligned_malloc(BLOCK_SIZE, BLOCK_SIZE);
 #else
     void* address = _aligned_malloc(BLOCK_SIZE, BLOCK_SIZE);
 #endif
     memset(address, 0, BLOCK_SIZE);
-#elif HAVE(POSIX_MEMALIGN)
+#elif (defined HAVE_POSIX_MEMALIGN && HAVE_POSIX_MEMALIGN)
     void* address;
     posix_memalign(&address, BLOCK_SIZE, BLOCK_SIZE);
 #else
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 #error Need to initialize pagesize safely.
 #endif
     static size_t pagesize = getpagesize();
@@ -282,19 +282,19 @@ NEVER_INLINE void Heap::freeBlock(size_t block)
 
 NEVER_INLINE void Heap::freeBlockPtr(CollectorBlock* block)
 {
-#if OS(DARWIN)    
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)    
     vm_deallocate(current_task(), reinterpret_cast<vm_address_t>(block), BLOCK_SIZE);
-#elif OS(SYMBIAN)
+#elif (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     m_blockallocator.free(reinterpret_cast<void*>(block));
-#elif OS(WINCE)
+#elif (defined WTF_OS_WINCE && WTF_OS_WINCE)
     VirtualFree(block, 0, MEM_RELEASE);
-#elif OS(WINDOWS)
-#if COMPILER(MINGW) && !COMPILER(MINGW64)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
+#if (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW) && !(defined WTF_COMPILER_MINGW64 && WTF_COMPILER_MINGW64)
     __mingw_aligned_free(block);
 #else
     _aligned_free(block);
 #endif
-#elif HAVE(POSIX_MEMALIGN)
+#elif (defined HAVE_POSIX_MEMALIGN && HAVE_POSIX_MEMALIGN)
     free(block);
 #else
     munmap(reinterpret_cast<char*>(block), BLOCK_SIZE);
@@ -445,7 +445,7 @@ void Heap::shrinkBlocks(size_t neededBlocks)
         m_heap.blocks[i]->marked.set(HeapConstants::cellsPerBlock - 1);
 }
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 void* g_stackBase = 0;
 
 inline bool isPageWritable(void* page)
@@ -502,7 +502,7 @@ static void* getStackBase(void* previousFrame)
 }
 #endif
 
-#if OS(HPUX)
+#if (defined WTF_OS_HPUX && WTF_OS_HPUX)
 struct hpux_get_stack_base_data
 {
     pthread_t thread;
@@ -546,7 +546,7 @@ static void *hpux_get_stack_base()
 }
 #endif
 
-#if OS(QNX)
+#if (defined WTF_OS_QNX && WTF_OS_QNX)
 static inline void *currentThreadStackBaseQNX()
 {
     static void* stackBase = 0;
@@ -575,10 +575,10 @@ static inline void *currentThreadStackBaseQNX()
 
 static inline void* currentThreadStackBase()
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     pthread_t thread = pthread_self();
     return pthread_get_stackaddr_np(thread);
-#elif OS(WINCE)
+#elif (defined WTF_OS_WINCE && WTF_OS_WINCE)
     AtomicallyInitializedStatic(Mutex&, mutex = *new Mutex);
     MutexLocker locker(mutex);
     if (g_stackBase)
@@ -587,7 +587,7 @@ static inline void* currentThreadStackBase()
         int dummy;
         return getStackBase(&dummy);
     }
-#elif OS(WINDOWS) && CPU(X86) && COMPILER(MSVC)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     // offset 0x18 from the FS segment register gives a pointer to
     // the thread information block for the current thread
     NT_TIB* pTib;
@@ -596,11 +596,11 @@ static inline void* currentThreadStackBase()
         MOV pTib, EAX
     }
     return static_cast<void*>(pTib->StackBase);
-#elif OS(WINDOWS) && CPU(X86_64) && (COMPILER(MSVC) || COMPILER(GCC))
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && ((defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC))
     // FIXME: why only for MSVC?
     PNT_TIB64 pTib = reinterpret_cast<PNT_TIB64>(NtCurrentTeb());
     return reinterpret_cast<void*>(pTib->StackBase);
-#elif OS(WINDOWS) && CPU(X86) && COMPILER(GCC)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
     // offset 0x18 from the FS segment register gives a pointer to
     // the thread information block for the current thread
     NT_TIB* pTib;
@@ -608,17 +608,17 @@ static inline void* currentThreadStackBase()
           : "=r" (pTib)
         );
     return static_cast<void*>(pTib->StackBase);
-#elif OS(HPUX)
+#elif (defined WTF_OS_HPUX && WTF_OS_HPUX)
     return hpux_get_stack_base();
-#elif OS(QNX)
+#elif (defined WTF_OS_QNX && WTF_OS_QNX)
     AtomicallyInitializedStatic(Mutex&, mutex = *new Mutex);
     MutexLocker locker(mutex);
     return currentThreadStackBaseQNX();
-#elif OS(SOLARIS)
+#elif (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)
     stack_t s;
     thr_stksegment(&s);
     return s.ss_sp;
-#elif OS(AIX)
+#elif (defined WTF_OS_AIX && WTF_OS_AIX)
     pthread_t thread = pthread_self();
     struct __pthrdsinfo threadinfo;
     char regbuf[256];
@@ -630,21 +630,21 @@ static inline void* currentThreadStackBase()
         return threadinfo.__pi_stackaddr;
 
     return 0;
-#elif OS(OPENBSD)
+#elif (defined WTF_OS_OPENBSD && WTF_OS_OPENBSD)
     pthread_t thread = pthread_self();
     stack_t stack;
     pthread_stackseg_np(thread, &stack);
     return stack.ss_sp;
-#elif OS(SYMBIAN)
+#elif (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     TThreadStackInfo info;
     RThread thread;
     thread.StackInfo(info);
     return (void*)info.iBase;
-#elif OS(HAIKU)
+#elif (defined WTF_OS_HAIKU && WTF_OS_HAIKU)
     thread_info threadInfo;
     get_thread_info(find_thread(NULL), &threadInfo);
     return threadInfo.stack_end;
-#elif OS(UNIX)
+#elif (defined WTF_OS_UNIX && WTF_OS_UNIX)
     AtomicallyInitializedStatic(Mutex&, mutex = *new Mutex);
     MutexLocker locker(mutex);
     static void* stackBase = 0;
@@ -654,7 +654,7 @@ static inline void* currentThreadStackBase()
     if (stackBase == 0 || thread != stackThread) {
         pthread_attr_t sattr;
         pthread_attr_init(&sattr);
-#if HAVE(PTHREAD_NP_H) || OS(NETBSD)
+#if (defined HAVE_PTHREAD_NP_H && HAVE_PTHREAD_NP_H) || (defined WTF_OS_NETBSD && WTF_OS_NETBSD)
         // e.g. on FreeBSD 5.4, neundorf@kde.org
         pthread_attr_get_np(thread, &sattr);
 #else
@@ -673,13 +673,13 @@ static inline void* currentThreadStackBase()
 #endif
 }
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 
 static inline PlatformThread getCurrentPlatformThread()
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     return pthread_mach_thread_np(pthread_self());
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     return pthread_getw32threadhandle_np(pthread_self());
 #endif
 }
@@ -741,7 +741,7 @@ void Heap::unregisterThread()
     }
 }
 
-#else // ENABLE(JSC_MULTIPLE_THREADS)
+#else // (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 
 void Heap::registerThread()
 {
@@ -757,7 +757,7 @@ inline bool isPointerAligned(void* p)
 // Cell size needs to be a power of two for isPossibleCell to be valid.
 COMPILE_ASSERT(sizeof(CollectorCell) % 2 == 0, Collector_cell_size_is_power_of_two);
 
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
 static bool isHalfCellAligned(void *p)
 {
     return (((intptr_t)(p) & (CELL_MASK >> 1)) == 0);
@@ -779,7 +779,7 @@ static inline bool isPossibleCell(void* p)
 {
     return isCellAligned(p) && p;
 }
-#endif // USE(JSVALUE32)
+#endif // (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
 
 void Heap::markConservatively(MarkStack& markStack, void* start, void* end)
 {
@@ -829,7 +829,7 @@ void NEVER_INLINE Heap::markCurrentThreadConservativelyInternal(MarkStack& markS
     markConservatively(markStack, stackPointer, stackBase);
 }
 
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define REGISTER_BUFFER_ALIGNMENT __attribute__ ((aligned (sizeof(void*))))
 #else
 #define REGISTER_BUFFER_ALIGNMENT
@@ -839,25 +839,25 @@ void Heap::markCurrentThreadConservatively(MarkStack& markStack)
 {
     // setjmp forces volatile registers onto the stack
     jmp_buf registers REGISTER_BUFFER_ALIGNMENT;
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma warning(push)
 #pragma warning(disable: 4611)
 #endif
     setjmp(registers);
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma warning(pop)
 #endif
 
     markCurrentThreadConservativelyInternal(markStack);
 }
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 
 static inline void suspendThread(const PlatformThread& platformThread)
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     thread_suspend(platformThread);
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     SuspendThread(platformThread);
 #else
 #error Need a way to suspend threads on this platform
@@ -866,9 +866,9 @@ static inline void suspendThread(const PlatformThread& platformThread)
 
 static inline void resumeThread(const PlatformThread& platformThread)
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     thread_resume(platformThread);
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     ResumeThread(platformThread);
 #else
 #error Need a way to resume threads on this platform
@@ -877,23 +877,23 @@ static inline void resumeThread(const PlatformThread& platformThread)
 
 typedef unsigned long usword_t; // word size, assumed to be either 32 or 64 bit
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
 typedef i386_thread_state_t PlatformThreadRegisters;
-#elif CPU(X86_64)
+#elif (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 typedef x86_thread_state64_t PlatformThreadRegisters;
-#elif CPU(PPC)
+#elif (defined WTF_CPU_PPC && WTF_CPU_PPC)
 typedef ppc_thread_state_t PlatformThreadRegisters;
-#elif CPU(PPC64)
+#elif (defined WTF_CPU_PPC64 && WTF_CPU_PPC64)
 typedef ppc_thread_state64_t PlatformThreadRegisters;
-#elif CPU(ARM)
+#elif (defined WTF_CPU_ARM && WTF_CPU_ARM)
 typedef arm_thread_state_t PlatformThreadRegisters;
 #else
 #error Unknown Architecture
 #endif
 
-#elif OS(WINDOWS) && CPU(X86)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_CPU_X86 && WTF_CPU_X86)
 typedef CONTEXT PlatformThreadRegisters;
 #else
 #error Need a thread register struct for this platform
@@ -901,21 +901,21 @@ typedef CONTEXT PlatformThreadRegisters;
 
 static size_t getPlatformThreadRegisters(const PlatformThread& platformThread, PlatformThreadRegisters& regs)
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
     unsigned user_count = sizeof(regs)/sizeof(int);
     thread_state_flavor_t flavor = i386_THREAD_STATE;
-#elif CPU(X86_64)
+#elif (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     unsigned user_count = x86_THREAD_STATE64_COUNT;
     thread_state_flavor_t flavor = x86_THREAD_STATE64;
-#elif CPU(PPC) 
+#elif (defined WTF_CPU_PPC && WTF_CPU_PPC) 
     unsigned user_count = PPC_THREAD_STATE_COUNT;
     thread_state_flavor_t flavor = PPC_THREAD_STATE;
-#elif CPU(PPC64)
+#elif (defined WTF_CPU_PPC64 && WTF_CPU_PPC64)
     unsigned user_count = PPC_THREAD_STATE64_COUNT;
     thread_state_flavor_t flavor = PPC_THREAD_STATE64;
-#elif CPU(ARM)
+#elif (defined WTF_CPU_ARM && WTF_CPU_ARM)
     unsigned user_count = ARM_THREAD_STATE_COUNT;
     thread_state_flavor_t flavor = ARM_THREAD_STATE;
 #else
@@ -929,9 +929,9 @@ static size_t getPlatformThreadRegisters(const PlatformThread& platformThread, P
         CRASH();
     }
     return user_count * sizeof(usword_t);
-// end OS(DARWIN)
+// end (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
-#elif OS(WINDOWS) && CPU(X86)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_CPU_X86 && WTF_CPU_X86)
     regs.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_SEGMENTS;
     GetThreadContext(platformThread, &regs);
     return sizeof(CONTEXT);
@@ -942,17 +942,17 @@ static size_t getPlatformThreadRegisters(const PlatformThread& platformThread, P
 
 static inline void* otherThreadStackPointer(const PlatformThreadRegisters& regs)
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
 #if __DARWIN_UNIX03
 
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
     return reinterpret_cast<void*>(regs.__esp);
-#elif CPU(X86_64)
+#elif (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     return reinterpret_cast<void*>(regs.__rsp);
-#elif CPU(PPC) || CPU(PPC64)
+#elif (defined WTF_CPU_PPC && WTF_CPU_PPC) || (defined WTF_CPU_PPC64 && WTF_CPU_PPC64)
     return reinterpret_cast<void*>(regs.__r1);
-#elif CPU(ARM)
+#elif (defined WTF_CPU_ARM && WTF_CPU_ARM)
     return reinterpret_cast<void*>(regs.__sp);
 #else
 #error Unknown Architecture
@@ -960,11 +960,11 @@ static inline void* otherThreadStackPointer(const PlatformThreadRegisters& regs)
 
 #else // !__DARWIN_UNIX03
 
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
     return reinterpret_cast<void*>(regs.esp);
-#elif CPU(X86_64)
+#elif (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     return reinterpret_cast<void*>(regs.rsp);
-#elif CPU(PPC) || CPU(PPC64)
+#elif (defined WTF_CPU_PPC && WTF_CPU_PPC) || (defined WTF_CPU_PPC64 && WTF_CPU_PPC64)
     return reinterpret_cast<void*>(regs.r1);
 #else
 #error Unknown Architecture
@@ -972,8 +972,8 @@ static inline void* otherThreadStackPointer(const PlatformThreadRegisters& regs)
 
 #endif // __DARWIN_UNIX03
 
-// end OS(DARWIN)
-#elif CPU(X86) && OS(WINDOWS)
+// end (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     return reinterpret_cast<void*>((uintptr_t) regs.Esp);
 #else
 #error Need a way to get the stack pointer for another thread on this platform
@@ -1002,7 +1002,7 @@ void Heap::markStackObjectsConservatively(MarkStack& markStack)
 {
     markCurrentThreadConservatively(markStack);
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 
     if (m_currentThreadRegistrar) {
 
@@ -1094,7 +1094,7 @@ void Heap::sweep()
         CRASH();
     m_heap.operationInProgress = Collection;
     
-#if !ENABLE(JSC_ZOMBIES)
+#if !(defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
     Structure* dummyMarkableCellStructure = m_globalData->dummyMarkableCellStructure.get();
 #endif
 
@@ -1102,7 +1102,7 @@ void Heap::sweep()
     DeadObjectIterator end(m_heap, m_heap.usedBlocks);
     for ( ; it != end; ++it) {
         JSCell* cell = *it;
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         if (!cell->isZombie()) {
             const ClassInfo* info = cell->classInfo();
             cell->~JSCell();
@@ -1226,7 +1226,7 @@ static const char* typeName(JSCell* cell)
 {
     if (cell->isString())
         return "string";
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
     if (cell->isNumber())
         return "number";
 #endif
@@ -1269,7 +1269,7 @@ void Heap::reset()
     m_heap.nextBlock = 0;
     m_heap.nextNumber = 0;
     m_heap.extraCost = 0;
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
     sweep();
 #endif
     resizeBlocks();
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.h
index 9c6ffa7..6a63489 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.h
@@ -31,11 +31,11 @@
 #include <wtf/StdLibExtras.h>
 #include <wtf/Threading.h>
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 #include <pthread.h>
 #endif
 
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 #include <wtf/symbian/BlockAllocatorSymbian.h>
 #endif
 
@@ -160,7 +160,7 @@ namespace JSC {
 
         HashSet<MarkedArgumentBuffer*>* m_markListSet;
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
         void makeUsableFromMultipleThreads();
 
         static void unregisterThread(void*);
@@ -171,7 +171,7 @@ namespace JSC {
         pthread_key_t m_currentThreadRegistrar;
 #endif
 
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
         // Allocates collector blocks with correct alignment
         WTF::AlignedBlockAllocator& m_blockallocator;
 #endif
@@ -183,14 +183,14 @@ namespace JSC {
     template<size_t bytesPerWord> struct CellSize;
 
     // cell size needs to be a power of two for certain optimizations in collector.cpp
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
     template<> struct CellSize<sizeof(uint32_t)> { static const size_t m_value = 32; };
 #else
     template<> struct CellSize<sizeof(uint32_t)> { static const size_t m_value = 64; };
 #endif
     template<> struct CellSize<sizeof(uint64_t)> { static const size_t m_value = 64; };
 
-#if OS(WINCE) || OS(SYMBIAN)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE) || (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     const size_t BLOCK_SIZE = 64 * 1024; // 64k
 #else
     const size_t BLOCK_SIZE = 64 * 4096; // 256k
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ConstructData.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ConstructData.h
index 9298f51..da1825a 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ConstructData.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ConstructData.h
@@ -70,7 +70,7 @@ namespace JSC {
     };
 #endif
 
-#if defined(QT_BUILD_SCRIPT_LIB) && OS(SOLARIS)
+#if defined(QT_BUILD_SCRIPT_LIB) && (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)
     struct
 #else
     union
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/DateConstructor.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/DateConstructor.cpp
index e9a5c29..ee631ec 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/DateConstructor.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/DateConstructor.cpp
@@ -35,15 +35,15 @@
 #include <wtf/DateMath.h>
 #include <wtf/MathExtras.h>
 
-#if OS(WINCE) && !PLATFORM(QT)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 extern "C" time_t time(time_t* timer); // Provided by libce.
 #endif
 
-#if HAVE(SYS_TIME_H)
+#if (defined HAVE_SYS_TIME_H && HAVE_SYS_TIME_H)
 #include <sys/time.h>
 #endif
 
-#if HAVE(SYS_TIMEB_H)
+#if (defined HAVE_SYS_TIMEB_H && HAVE_SYS_TIMEB_H)
 #include <sys/timeb.h>
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/DatePrototype.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/DatePrototype.cpp
index ca9d4ea..d2de191 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/DatePrototype.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/DatePrototype.cpp
@@ -29,7 +29,7 @@
 #include "ObjectPrototype.h"
 #include "DateInstance.h"
 
-#if !PLATFORM(MAC) && HAVE(LANGINFO_H)
+#if !(defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) && (defined HAVE_LANGINFO_H && HAVE_LANGINFO_H)
 #include <langinfo.h>
 #endif
 
@@ -43,23 +43,23 @@
 #include <wtf/StringExtras.h>
 #include <wtf/UnusedParam.h>
 
-#if HAVE(SYS_PARAM_H)
+#if (defined HAVE_SYS_PARAM_H && HAVE_SYS_PARAM_H)
 #include <sys/param.h>
 #endif
 
-#if HAVE(SYS_TIME_H)
+#if (defined HAVE_SYS_TIME_H && HAVE_SYS_TIME_H)
 #include <sys/time.h>
 #endif
 
-#if HAVE(SYS_TIMEB_H)
+#if (defined HAVE_SYS_TIMEB_H && HAVE_SYS_TIMEB_H)
 #include <sys/timeb.h>
 #endif
 
-#if PLATFORM(MAC)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
 #include <CoreFoundation/CoreFoundation.h>
 #endif
 
-#if OS(WINCE) && !PLATFORM(QT)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 extern "C" size_t strftime(char * const s, const size_t maxsize, const char * const format, const struct tm * const t); //provided by libce
 #endif
 
@@ -124,10 +124,10 @@ namespace JSC {
 
 enum LocaleDateTimeFormat { LocaleDateAndTime, LocaleDate, LocaleTime };
  
-#if PLATFORM(MAC)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
 
-// FIXME: Since this is superior to the strftime-based version, why limit this to PLATFORM(MAC)?
-// Instead we should consider using this whenever PLATFORM(CF) is true.
+// FIXME: Since this is superior to the strftime-based version, why limit this to (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)?
+// Instead we should consider using this whenever (defined WTF_PLATFORM_CF && WTF_PLATFORM_CF) is true.
 
 static CFDateFormatterStyle styleFromArgString(const UString& string, CFDateFormatterStyle defaultStyle)
 {
@@ -191,13 +191,13 @@ static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMil
     return jsNontrivialString(exec, UString(buffer, length));
 }
 
-#else // !PLATFORM(MAC)
+#else // !(defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
 
 static JSCell* formatLocaleDate(ExecState* exec, const GregorianDateTime& gdt, LocaleDateTimeFormat format)
 {
-#if HAVE(LANGINFO_H)
+#if (defined HAVE_LANGINFO_H && HAVE_LANGINFO_H)
     static const nl_item formats[] = { D_T_FMT, D_FMT, T_FMT };
-#elif (OS(WINCE) && !PLATFORM(QT)) || OS(SYMBIAN)
+#elif ((defined WTF_OS_WINCE && WTF_OS_WINCE) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)) || (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
      // strftime() does not support '#' on WinCE or Symbian
     static const char* const formatStrings[] = { "%c", "%x", "%X" };
 #else
@@ -211,7 +211,7 @@ static JSCell* formatLocaleDate(ExecState* exec, const GregorianDateTime& gdt, L
     if (yearNeedsOffset)
         localTM.tm_year = equivalentYearForDST(year) - 1900;
  
-#if HAVE(LANGINFO_H)
+#if (defined HAVE_LANGINFO_H && HAVE_LANGINFO_H)
     // We do not allow strftime to generate dates with 2-digits years,
     // both to avoid ambiguity, and a crash in strncpy, for years that
     // need offset.
@@ -225,7 +225,7 @@ static JSCell* formatLocaleDate(ExecState* exec, const GregorianDateTime& gdt, L
     const int bufsize = 128;
     char timebuffer[bufsize];
 
-#if HAVE(LANGINFO_H)
+#if (defined HAVE_LANGINFO_H && HAVE_LANGINFO_H)
     size_t ret = strftime(timebuffer, bufsize, formatString, &localTM);
     free(formatString);
 #else
@@ -258,7 +258,7 @@ static JSCell* formatLocaleDate(ExecState* exec, DateInstance* dateObject, doubl
     return formatLocaleDate(exec, *gregorianDateTime, format);
 }
 
-#endif // !PLATFORM(MAC)
+#endif // !(defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
 
 // Converts a list of arguments sent to a Date member function into milliseconds, updating
 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Executable.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Executable.cpp
index bc18cc9..d087c8f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Executable.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Executable.cpp
@@ -35,7 +35,7 @@
 
 namespace JSC {
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 NativeExecutable::~NativeExecutable()
 {
 }
@@ -135,14 +135,14 @@ void FunctionExecutable::compile(ExecState*, ScopeChainNode* scopeChainNode)
     body->destroyData();
 }
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 
 void EvalExecutable::generateJITCode(ExecState* exec, ScopeChainNode* scopeChainNode)
 {
     CodeBlock* codeBlock = &bytecode(exec, scopeChainNode);
     m_jitCode = JIT::compile(scopeChainNode->globalData, codeBlock);
 
-#if !ENABLE(OPCODE_SAMPLING)
+#if !(defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     if (!BytecodeGenerator::dumpsGeneratedCode())
         codeBlock->discardBytecode();
 #endif
@@ -153,7 +153,7 @@ void ProgramExecutable::generateJITCode(ExecState* exec, ScopeChainNode* scopeCh
     CodeBlock* codeBlock = &bytecode(exec, scopeChainNode);
     m_jitCode = JIT::compile(scopeChainNode->globalData, codeBlock);
 
-#if !ENABLE(OPCODE_SAMPLING)
+#if !(defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     if (!BytecodeGenerator::dumpsGeneratedCode())
         codeBlock->discardBytecode();
 #endif
@@ -164,7 +164,7 @@ void FunctionExecutable::generateJITCode(ExecState* exec, ScopeChainNode* scopeC
     CodeBlock* codeBlock = &bytecode(exec, scopeChainNode);
     m_jitCode = JIT::compile(scopeChainNode->globalData, codeBlock);
 
-#if !ENABLE(OPCODE_SAMPLING)
+#if !(defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
     if (!BytecodeGenerator::dumpsGeneratedCode())
         codeBlock->discardBytecode();
 #endif
@@ -197,7 +197,7 @@ ExceptionInfo* FunctionExecutable::reparseExceptionInfo(JSGlobalData* globalData
 
     ASSERT(newCodeBlock->instructionCount() == codeBlock->instructionCount());
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     JITCode newJITCode = JIT::compile(globalData, newCodeBlock.get());
     ASSERT(newJITCode.size() == generatedJITCode().size());
 #endif
@@ -222,7 +222,7 @@ ExceptionInfo* EvalExecutable::reparseExceptionInfo(JSGlobalData* globalData, Sc
 
     ASSERT(newCodeBlock->instructionCount() == codeBlock->instructionCount());
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     JITCode newJITCode = JIT::compile(globalData, newCodeBlock.get());
     ASSERT(newJITCode.size() == generatedJITCode().size());
 #endif
@@ -235,7 +235,7 @@ void FunctionExecutable::recompile(ExecState*)
     delete m_codeBlock;
     m_codeBlock = 0;
     m_numParameters = NUM_PARAMETERS_NOT_COMPILED;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     m_jitCode = JITCode();
 #endif
 }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Executable.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Executable.h
index d1d38de..51d02f3 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Executable.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Executable.h
@@ -61,7 +61,7 @@ namespace JSC {
     protected:
         int m_numParameters;
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     public:
         JITCode& generatedJITCode()
         {
@@ -79,7 +79,7 @@ namespace JSC {
 #endif
     };
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     class NativeExecutable : public ExecutableBase {
     public:
         NativeExecutable(ExecState* exec)
@@ -109,7 +109,7 @@ namespace JSC {
             , m_source(source)
             , m_features(0)
         {
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
             if (SamplingTool* sampler = globalData->interpreter->sampler())
                 sampler->notifyOfScope(this);
 #else
@@ -122,7 +122,7 @@ namespace JSC {
             , m_source(source)
             , m_features(0)
         {
-#if ENABLE(CODEBLOCK_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING)
             if (SamplingTool* sampler = exec->globalData().interpreter->sampler())
                 sampler->notifyOfScope(this);
 #else
@@ -183,7 +183,7 @@ namespace JSC {
         }
         EvalCodeBlock* m_evalCodeBlock;
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     public:
         JITCode& jitCode(ExecState* exec, ScopeChainNode* scopeChainNode)
         {
@@ -229,7 +229,7 @@ namespace JSC {
         }
         ProgramCodeBlock* m_programCodeBlock;
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     public:
         JITCode& jitCode(ExecState* exec, ScopeChainNode* scopeChainNode)
         {
@@ -328,7 +328,7 @@ namespace JSC {
         Identifier m_name;
         size_t m_numVariables;
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     public:
         JITCode& jitCode(ExecState* exec, ScopeChainNode* scopeChainNode)
         {
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Identifier.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Identifier.cpp
index 747c4ac..f762646 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Identifier.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Identifier.cpp
@@ -265,7 +265,7 @@ void Identifier::checkSameIdentifierTable(JSGlobalData*, UString::Rep*)
 
 ThreadSpecific<ThreadIdentifierTableData>* g_identifierTableSpecific = 0;
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 
 pthread_once_t createIdentifierTableSpecificOnce = PTHREAD_ONCE_INIT;
 static void createIdentifierTableSpecificCallback()
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/InitializeThreading.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/InitializeThreading.cpp
index 2605a9a..959f766 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/InitializeThreading.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/InitializeThreading.cpp
@@ -41,7 +41,7 @@ using namespace WTF;
 
 namespace JSC {
 
-#if OS(DARWIN) && ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN) && (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 static pthread_once_t initializeThreadingKeyOnce = PTHREAD_ONCE_INIT;
 #endif
 
@@ -50,7 +50,7 @@ static void initializeThreadingOnce()
     WTF::initializeThreading();
     initializeUString();
     JSGlobalData::storeVPtrs();
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     s_dtoaP5Mutex = new Mutex;
     initializeDates();
 #endif
@@ -58,7 +58,7 @@ static void initializeThreadingOnce()
 
 void initializeThreading()
 {
-#if OS(DARWIN) && ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN) && (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     pthread_once(&initializeThreadingKeyOnce, initializeThreadingOnce);
 #else
     static bool initializedThreading = false;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSArray.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSArray.cpp
index 2be7371..3849eb8 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSArray.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSArray.cpp
@@ -726,7 +726,7 @@ void JSArray::sort(ExecState* exec)
     // FIXME: Since we sort by string value, a fast algorithm might be to use a radix sort. That would be O(N) rather
     // than O(N log N).
 
-#if HAVE(MERGESORT)
+#if (defined HAVE_MERGESORT && HAVE_MERGESORT)
     mergesort(values.begin(), values.size(), sizeof(ValueStringPair), compareByStringPairForQSort);
 #else
     // FIXME: The qsort library function is likely to not be a stable sort.
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSCell.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSCell.cpp
index 869fbfc..50931eb 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSCell.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSCell.cpp
@@ -59,10 +59,10 @@ static const union {
     } doubles;
     
 } NaNInf = { {
-#if CPU(BIG_ENDIAN)
+#if (defined WTF_CPU_BIG_ENDIAN && WTF_CPU_BIG_ENDIAN)
     { 0x7f, 0xf8, 0, 0, 0, 0, 0, 0 },
     { 0x7f, 0xf0, 0, 0, 0, 0, 0, 0 }
-#elif CPU(MIDDLE_ENDIAN)
+#elif (defined WTF_CPU_MIDDLE_ENDIAN && WTF_CPU_MIDDLE_ENDIAN)
     { 0, 0, 0xf8, 0x7f, 0, 0, 0, 0 },
     { 0, 0, 0xf0, 0x7f, 0, 0, 0, 0 }
 #else
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSCell.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSCell.h
index 36bfd66..725474e 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSCell.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSCell.h
@@ -56,7 +56,7 @@ namespace JSC {
         }
 
         // Querying the type.
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         bool isNumber() const;
 #endif
         bool isString() const;
@@ -95,7 +95,7 @@ namespace JSC {
         void* operator new(size_t, void* placementNewDestination) { return placementNewDestination; }
 
         virtual void markChildren(MarkStack&);
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         virtual bool isZombie() const { return false; }
 #endif
 
@@ -131,7 +131,7 @@ namespace JSC {
     {
     }
 
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
     inline bool JSCell::isNumber() const
     {
         return m_structure->typeInfo().type() == NumberType;
@@ -224,13 +224,13 @@ namespace JSC {
         return false;
     }
 
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     ALWAYS_INLINE JSCell* JSValue::asCell() const
     {
         ASSERT(isCell());
         return m_ptr;
     }
-#endif // !USE(JSVALUE32_64)
+#endif // !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
     inline JSValue JSValue::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const
     {
@@ -352,7 +352,7 @@ namespace JSC {
         return cellBlock(c)->heap;
     }
     
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
     inline bool JSValue::isZombie() const
     {
         return isCell() && asCell() && asCell()->isZombie();
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSFunction.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSFunction.cpp
index d213b4a..0bbc048 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSFunction.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSFunction.cpp
@@ -58,11 +58,11 @@ JSFunction::JSFunction(NonNullPassRefPtr<Structure> structure)
 
 JSFunction::JSFunction(ExecState* exec, NonNullPassRefPtr<Structure> structure, int length, const Identifier& name, NativeFunction func)
     : Base(&exec->globalData(), structure, name)
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     , m_executable(adoptRef(new NativeExecutable(exec)))
 #endif
 {
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     setNativeFunction(func);
     putDirect(exec->propertyNames().length, jsNumber(exec, length), DontDelete | ReadOnly | DontEnum);
 #else
@@ -87,7 +87,7 @@ JSFunction::~JSFunction()
     // are based on a check for the this pointer value for this JSFunction - which will no longer be valid once
     // this memory is freed and may be reused (potentially for another, different JSFunction).
     if (!isHostFunction()) {
-#if ENABLE(JIT_OPTIMIZE_CALL)
+#if (defined ENABLE_JIT_OPTIMIZE_CALL && ENABLE_JIT_OPTIMIZE_CALL)
         ASSERT(m_executable);
         if (jsExecutable()->isGenerated())
             jsExecutable()->generatedBytecode().unlinkCallers();
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalData.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalData.cpp
index 1c25c16..43c5c32 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalData.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalData.cpp
@@ -50,11 +50,11 @@
 #include "Nodes.h"
 #include "Parser.h"
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 #include <wtf/Threading.h>
 #endif
 
-#if PLATFORM(MAC)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
 #include "ProfilerServer.h"
 #endif
 
@@ -123,7 +123,7 @@ JSGlobalData::JSGlobalData(bool isShared)
     , getterSetterStructure(GetterSetter::createStructure(jsNull()))
     , apiWrapperStructure(JSAPIValueWrapper::createStructure(jsNull()))
     , dummyMarkableCellStructure(JSCell::createDummyStructure())
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
     , numberStructure(JSNumberCell::createStructure(jsNull()))
 #endif
     , identifierTable(createIdentifierTable())
@@ -132,7 +132,7 @@ JSGlobalData::JSGlobalData(bool isShared)
     , lexer(new Lexer(this))
     , parser(new Parser)
     , interpreter(new Interpreter)
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
     , jitStubs(this)
 #endif
     , timeoutChecker(new TimeoutChecker)
@@ -148,7 +148,7 @@ JSGlobalData::JSGlobalData(bool isShared)
     , mainThreadOnly(false)
 #endif
 {
-#if PLATFORM(MAC)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
     startProfilerServerIfNeeded();
 #endif
 }
@@ -226,7 +226,7 @@ JSGlobalData& JSGlobalData::sharedInstance()
     JSGlobalData*& instance = sharedInstanceInternal();
     if (!instance) {
         instance = new JSGlobalData(true);
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
         instance->makeUsableFromMultipleThreads();
 #endif
     }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalData.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalData.h
index dcd3289..2e6043f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalData.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalData.h
@@ -100,7 +100,7 @@ namespace JSC {
         static PassRefPtr<JSGlobalData> createNonDefault();
         ~JSGlobalData();
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
         // Will start tracking threads that use the heap, which is resource-heavy.
         void makeUsableFromMultipleThreads() { heap.makeUsableFromMultipleThreads(); }
 #endif
@@ -128,7 +128,7 @@ namespace JSC {
         RefPtr<Structure> apiWrapperStructure;
         RefPtr<Structure> dummyMarkableCellStructure;
 
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         RefPtr<Structure> numberStructure;
 #endif
 
@@ -145,21 +145,21 @@ namespace JSC {
         NumericStrings numericStrings;
         DateInstanceCache dateInstanceCache;
         
-#if ENABLE(ASSEMBLER)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
         ExecutableAllocator executableAllocator;
 #endif
 
         Lexer* lexer;
         Parser* parser;
         Interpreter* interpreter;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         JITThunks jitStubs;
 #endif
         TimeoutChecker* timeoutChecker;
         Heap heap;
 
         JSValue exception;
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
         ReturnAddressPtr exceptionLocation;
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalObject.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalObject.h
index 9eb86e7..73ee3bb 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalObject.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSGlobalObject.h
@@ -365,7 +365,7 @@ namespace JSC {
         if (typeInfo().type() == ObjectType)
             return m_prototype;
 
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         if (typeInfo().type() == StringType)
             return exec->lexicalGlobalObject()->stringPrototype();
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSImmediate.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSImmediate.h
index 053b4c0..988275c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSImmediate.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSImmediate.h
@@ -24,7 +24,7 @@
 
 #include <wtf/Platform.h>
 
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 #include <wtf/Assertions.h>
 #include <wtf/AlwaysInline.h>
@@ -46,7 +46,7 @@ namespace JSC {
     class JSObject;
     class UString;
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     inline intptr_t reinterpretDoubleToIntptr(double value)
     {
         return WTF::bitwise_cast<intptr_t>(value);
@@ -102,7 +102,7 @@ namespace JSC {
 
     /*
      * On 64-bit platforms, we support an alternative encoding form for immediates, if
-     * USE(JSVALUE64) is defined.  When this format is used, double precision
+     * (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64) is defined.  When this format is used, double precision
      * floating point values may also be encoded as JSImmediates.
      *
      * The encoding makes use of unused NaN space in the IEEE754 representation.  Any value
@@ -163,7 +163,7 @@ namespace JSC {
         friend JSValue jsNumber(JSGlobalData* globalData, long long i);
         friend JSValue jsNumber(JSGlobalData* globalData, unsigned long long i);
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         // If all bits in the mask are set, this indicates an integer number,
         // if any but not all are set this value is a double precision number.
         static const intptr_t TagTypeNumber = 0xffff000000000000ll;
@@ -185,7 +185,7 @@ namespace JSC {
         static const intptr_t FullTagTypeUndefined = TagBitTypeOther | ExtendedTagBitUndefined;
         static const intptr_t FullTagTypeNull      = TagBitTypeOther;
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         static const int32_t IntegerPayloadShift  = 0;
 #else
         static const int32_t IntegerPayloadShift  = 1;
@@ -208,14 +208,14 @@ namespace JSC {
 
         static ALWAYS_INLINE bool isIntegerNumber(JSValue v)
         {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             return (rawValue(v) & TagTypeNumber) == TagTypeNumber;
 #else
             return isNumber(v);
 #endif
         }
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         static ALWAYS_INLINE bool isDouble(JSValue v)
         {
             return isNumber(v) && !isIntegerNumber(v);
@@ -264,7 +264,7 @@ namespace JSC {
 
         static ALWAYS_INLINE bool areBothImmediateIntegerNumbers(JSValue v1, JSValue v2)
         {
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             return (rawValue(v1) & rawValue(v2) & TagTypeNumber) == TagTypeNumber;
 #else
             return rawValue(v1) & rawValue(v2) & TagTypeNumber;
@@ -289,7 +289,7 @@ namespace JSC {
         static JSValue oneImmediate();
 
     private:
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         static const int minImmediateInt = ((-INT_MAX) - 1);
         static const int maxImmediateInt = INT_MAX;
 #else
@@ -303,10 +303,10 @@ namespace JSC {
             return JSValue::makeImmediate(integer);
         }
 
-        // With USE(JSVALUE64) we want the argument to be zero extended, so the
+        // With (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64) we want the argument to be zero extended, so the
         // integer doesn't interfere with the tag bits in the upper word.  In the default encoding,
         // if intptr_t id larger then int32_t we sign extend the value through the upper word.
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         static ALWAYS_INLINE JSValue makeInt(uint32_t value)
 #else
         static ALWAYS_INLINE JSValue makeInt(int32_t value)
@@ -315,7 +315,7 @@ namespace JSC {
             return makeValue((static_cast<intptr_t>(value) << IntegerPayloadShift) | TagTypeNumber);
         }
         
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         static ALWAYS_INLINE JSValue makeDouble(double value)
         {
             return makeValue(reinterpretDoubleToIntptr(value) + DoubleEncodeOffset);
@@ -340,7 +340,7 @@ namespace JSC {
         template<typename T>
         static JSValue fromNumberOutsideIntegerRange(T);
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         static ALWAYS_INLINE double doubleValue(JSValue v)
         {
             return reinterpretIntptrToDouble(rawValue(v) - DoubleEncodeOffset);
@@ -375,7 +375,7 @@ namespace JSC {
     ALWAYS_INLINE JSValue JSImmediate::zeroImmediate() { return makeInt(0); }
     ALWAYS_INLINE JSValue JSImmediate::oneImmediate() { return makeInt(1); }
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     inline bool doubleToBoolean(double value)
     {
         return value < 0.0 || value > 0.0;
@@ -402,7 +402,7 @@ namespace JSC {
         return intValue(v);
     }
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     template<typename T>
     inline JSValue JSImmediate::fromNumberOutsideIntegerRange(T value)
     {
@@ -443,7 +443,7 @@ namespace JSC {
 
     ALWAYS_INLINE JSValue JSImmediate::from(int i)
     {
-#if !USE(JSVALUE64)
+#if !(defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         if ((i < minImmediateInt) | (i > maxImmediateInt))
             return fromNumberOutsideIntegerRange(i);
 #endif
@@ -509,7 +509,7 @@ namespace JSC {
         if (isIntegerNumber(v))
             return intValue(v);
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
         if (isNumber(v)) {
             ASSERT(isDouble(v));
             return doubleValue(v);
@@ -674,7 +674,7 @@ namespace JSC {
         static ALWAYS_INLINE JSValue rightShiftImmediateNumbers(JSValue val, JSValue shift)
         {
             ASSERT(canDoFastRshift(val, shift) || canDoFastUrshift(val, shift));
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
             return JSImmediate::makeValue(static_cast<intptr_t>(static_cast<uint32_t>(static_cast<int32_t>(JSImmediate::rawValue(val)) >> ((JSImmediate::rawValue(shift) >> JSImmediate::IntegerPayloadShift) & 0x1f))) | JSImmediate::TagTypeNumber);
 #else
             return JSImmediate::makeValue((JSImmediate::rawValue(val) >> ((JSImmediate::rawValue(shift) >> JSImmediate::IntegerPayloadShift) & 0x1f)) | JSImmediate::TagTypeNumber);
@@ -722,6 +722,6 @@ namespace JSC {
 
 } // namespace JSC
 
-#endif // !USE(JSVALUE32_64)
+#endif // !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 #endif // JSImmediate_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSLock.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSLock.cpp
index 8f056c8..d0c1c95 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSLock.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSLock.cpp
@@ -24,13 +24,13 @@
 #include "Collector.h"
 #include "CallFrame.h"
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 #include <pthread.h>
 #endif
 
 namespace JSC {
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 
 // Acquire this mutex before accessing lock-related data.
 static pthread_mutex_t JSMutex = PTHREAD_MUTEX_INITIALIZER;
@@ -249,6 +249,6 @@ JSLock::DropAllLocks::~DropAllLocks()
 {
 }
 
-#endif // USE(MULTIPLE_THREADS)
+#endif // (defined WTF_USE_MULTIPLE_THREADS && WTF_USE_MULTIPLE_THREADS)
 
 } // namespace JSC
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSNumberCell.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSNumberCell.cpp
index f1009b9..d0eb2f5 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSNumberCell.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSNumberCell.cpp
@@ -23,7 +23,7 @@
 #include "config.h"
 #include "JSNumberCell.h"
 
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
 
 #include "NumberObject.h"
 #include "UString.h"
@@ -95,7 +95,7 @@ JSValue jsNumberCell(JSGlobalData* globalData, double d)
 
 } // namespace JSC
 
-#else // USE(JSVALUE32)
+#else // (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
 
 // Keep our exported symbols lists happy.
 namespace JSC {
@@ -110,4 +110,4 @@ JSValue jsNumberCell(ExecState*, double)
 
 } // namespace JSC
 
-#endif // USE(JSVALUE32)
+#endif // (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSNumberCell.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSNumberCell.h
index e9e2470..964268f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSNumberCell.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSNumberCell.h
@@ -35,7 +35,7 @@ namespace JSC {
     extern const double NaN;
     extern const double Inf;
 
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
     JSValue jsNumberCell(ExecState*, double);
 
     class Identifier;
@@ -195,9 +195,9 @@ namespace JSC {
         return JSImmediate::isImmediate(asValue()) ? JSImmediate::toDouble(asValue()) : asDouble();
     }
 
-#endif // USE(JSVALUE32)
+#endif // (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
 
-#if USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
     ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, ExecState*, double d)
     {
         *this = JSImmediate::fromNumberOutsideIntegerRange(d);
@@ -294,9 +294,9 @@ namespace JSC {
         return JSImmediate::toDouble(asValue());
     }
 
-#endif // USE(JSVALUE64)
+#endif // (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
 
-#if USE(JSVALUE32) || USE(JSVALUE64)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32) || (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
 
     inline JSValue::JSValue(ExecState*, char i)
     {
@@ -352,7 +352,7 @@ namespace JSC {
         return true;
     }
 
-#endif // USE(JSVALUE32) || USE(JSVALUE64)
+#endif // (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32) || (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64)
 
 } // namespace JSC
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSObject.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSObject.h
index 21dbfe9..8234816 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSObject.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSObject.h
@@ -239,7 +239,7 @@ namespace JSC {
         void getString(ExecState* exec);
         void isObject();
         void isString();
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         void isNumber();
 #endif
 
@@ -290,7 +290,7 @@ inline JSObject::JSObject(NonNullPassRefPtr<Structure> structure)
     ASSERT(m_structure->propertyStorageCapacity() == inlineStorageCapacity);
     ASSERT(m_structure->isEmpty());
     ASSERT(prototype().isNull() || Heap::heap(this) == Heap::heap(prototype()));
-#if USE(JSVALUE64) || USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE64 && WTF_USE_JSVALUE64) || (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     ASSERT(OBJECT_OFFSETOF(JSObject, m_inlineStorage) % sizeof(double) == 0);
 #endif
 }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSString.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSString.h
index e1c6aba..a29b7b8 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSString.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSString.h
@@ -379,7 +379,7 @@ namespace JSC {
     // see <http://groups.google.com/group/microsoft.public.vc.language/msg/55cdcefeaf770212>.
     // This breaks isJSString(), and we don't need that hack anyway, so we change vptr back to primary one.
     // The below function must be called by any inline function that invokes a JSString constructor.
-#if COMPILER(MSVC) && !defined(BUILDING_JavaScriptCore)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && !defined(BUILDING_JavaScriptCore)
     inline JSString* fixupVPtr(JSGlobalData* globalData, JSString* string) { string->setVPtr(globalData->jsStringVPtr); return string; }
 #else
     inline JSString* fixupVPtr(JSGlobalData*, JSString* string) { return string; }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.cpp
index 502312c..25a94f1 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.cpp
@@ -174,7 +174,7 @@ uint32_t toUInt32SlowCase(double d, bool& ok)
 
 NEVER_INLINE double nonInlineNaN()
 {
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     return nanval();
 #else
     return std::numeric_limits<double>::quiet_NaN();
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.h
index 6da921f..d7fe160 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSValue.h
@@ -50,7 +50,7 @@ namespace JSC {
 
     enum PreferredPrimitiveType { NoPreference, PreferNumber, PreferString };
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     typedef int64_t EncodedJSValue;
 #else
     typedef void* EncodedJSValue;
@@ -70,7 +70,7 @@ namespace JSC {
     public:
         static EncodedJSValue encode(JSValue value);
         static JSValue decode(EncodedJSValue ptr);
-#if !USE(JSVALUE32_64)
+#if !(defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     private:
         static JSValue makeImmediate(intptr_t value);
         intptr_t immediateValue();
@@ -169,7 +169,7 @@ namespace JSC {
         uint32_t toUInt32(ExecState*) const;
         uint32_t toUInt32(ExecState*, bool& ok) const;
 
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         bool isZombie() const;
 #endif
 
@@ -231,11 +231,11 @@ namespace JSC {
         JSObject* synthesizePrototype(ExecState*) const;
         JSObject* synthesizeObject(ExecState*) const;
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         union {
             EncodedJSValue asEncodedJSValue;
             double asDouble;
-#if CPU(BIG_ENDIAN)
+#if (defined WTF_CPU_BIG_ENDIAN && WTF_CPU_BIG_ENDIAN)
             struct {
                 int32_t tag;
                 int32_t payload;
@@ -247,12 +247,12 @@ namespace JSC {
             } asBits;
 #endif
         } u;
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
         JSCell* m_ptr;
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     };
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     typedef IntHash<EncodedJSValue> EncodedJSValueHash;
 
     struct EncodedJSValueHashTraits : HashTraits<EncodedJSValue> {
@@ -427,7 +427,7 @@ namespace JSC {
         return toUInt32SlowCase(toNumber(exec), ok);
     }
 
-#if USE(JSVALUE32_64)
+#if (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
     inline JSValue jsNaN(ExecState* exec)
     {
         return JSValue(exec, nonInlineNaN());
@@ -443,7 +443,7 @@ namespace JSC {
     {
         JSValue v;
         v.u.asEncodedJSValue = encodedJSValue;
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         ASSERT(!v.isZombie());
 #endif
         return v;
@@ -492,7 +492,7 @@ namespace JSC {
         else
             u.asBits.tag = EmptyValueTag;
         u.asBits.payload = reinterpret_cast<int32_t>(ptr);
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         ASSERT(!isZombie());
 #endif
     }
@@ -504,7 +504,7 @@ namespace JSC {
         else
             u.asBits.tag = EmptyValueTag;
         u.asBits.payload = reinterpret_cast<int32_t>(const_cast<JSCell*>(ptr));
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         ASSERT(!isZombie());
 #endif
     }
@@ -769,7 +769,7 @@ namespace JSC {
         return false;
     }
 
-#else // USE(JSVALUE32_64)
+#else // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
     // JSValue member functions.
     inline EncodedJSValue JSValue::encode(JSValue value)
@@ -807,7 +807,7 @@ namespace JSC {
     inline JSValue::JSValue(JSCell* ptr)
         : m_ptr(ptr)
     {
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         ASSERT(!isZombie());
 #endif
     }
@@ -815,7 +815,7 @@ namespace JSC {
     inline JSValue::JSValue(const JSCell* ptr)
         : m_ptr(const_cast<JSCell*>(ptr))
     {
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
         ASSERT(!isZombie());
 #endif
     }
@@ -844,7 +844,7 @@ namespace JSC {
     {
         return asValue() == jsNull();
     }
-#endif // USE(JSVALUE32_64)
+#endif // (defined WTF_USE_JSVALUE32_64 && WTF_USE_JSVALUE32_64)
 
 } // namespace JSC
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSZombie.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSZombie.cpp
index 072d29b..aad01f6 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSZombie.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSZombie.cpp
@@ -27,7 +27,7 @@
 #include "JSZombie.h"
 #include "ClassInfo.h"
 
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
 
 namespace JSC {
 
@@ -45,4 +45,4 @@ Structure* JSZombie::leakedZombieStructure() {
 
 }
 
-#endif // ENABLE(JSC_ZOMBIES)
+#endif // (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSZombie.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSZombie.h
index 8b33ea6..4dab748 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSZombie.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/JSZombie.h
@@ -28,7 +28,7 @@
 
 #include "JSCell.h"
 
-#if ENABLE(JSC_ZOMBIES)
+#if (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
 namespace JSC {
 
 class JSZombie : public JSCell {
@@ -73,6 +73,6 @@ private:
 
 }
 
-#endif // ENABLE(JSC_ZOMBIES)
+#endif // (defined ENABLE_JSC_ZOMBIES && ENABLE_JSC_ZOMBIES)
 
 #endif // JSZombie_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Lookup.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Lookup.h
index e673c09..66b792a 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Lookup.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Lookup.h
@@ -30,7 +30,7 @@
 #include <wtf/Assertions.h>
 
 // Bug #26843: Work around Metrowerks compiler bug
-#if COMPILER(WINSCW)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
 #define JSC_CONST_HASHTABLE
 #else
 #define JSC_CONST_HASHTABLE const
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStack.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStack.h
index c551bac..7316fd5 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStack.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStack.h
@@ -153,7 +153,7 @@ namespace JSC {
                 ASSERT(0 == (size % MarkStack::pageSize()));
                 if (size == m_allocated)
                     return;
-#if OS(WINDOWS) || OS(SYMBIAN) || PLATFORM(BREWMP)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) || (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN) || (defined WTF_PLATFORM_BREWMP && WTF_PLATFORM_BREWMP)
                 // We cannot release a part of a region with VirtualFree.  To get around this,
                 // we'll release the entire region and reallocate the size that we want.
                 releaseStack(m_data, m_allocated);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackPosix.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackPosix.cpp
index de5e8ba..5686b1e 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackPosix.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackPosix.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "MarkStack.h"
 
-#if OS(UNIX) && !OS(SYMBIAN)
+#if (defined WTF_OS_UNIX && WTF_OS_UNIX) && !(defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 
 #include <unistd.h>
 #include <sys/mman.h>
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackSymbian.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackSymbian.cpp
index bda14ac..fead184 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackSymbian.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackSymbian.cpp
@@ -20,7 +20,7 @@
 #include "config.h"
 #include "MarkStack.h"
 
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 
 #include <e32hal.h>
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackWin.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackWin.cpp
index a171c78..a85b54c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackWin.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/MarkStackWin.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "MarkStack.h"
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
 #include "windows.h"
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/NativeFunctionWrapper.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/NativeFunctionWrapper.h
index d4eeb3b..ee3ea98 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/NativeFunctionWrapper.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/NativeFunctionWrapper.h
@@ -27,7 +27,7 @@
 #define NativeFunctionWrapper_h
 
 namespace JSC {
-#if ENABLE(JIT) && ENABLE(JIT_OPTIMIZE_NATIVE_CALL)
+#if (defined ENABLE_JIT && ENABLE_JIT) && (defined ENABLE_JIT_OPTIMIZE_NATIVE_CALL && ENABLE_JIT_OPTIMIZE_NATIVE_CALL)
     class JSFunction;
     typedef JSFunction NativeFunctionWrapper;
 #else
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/NumberObject.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/NumberObject.h
index 8223a90..5109e1f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/NumberObject.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/NumberObject.h
@@ -37,7 +37,7 @@ namespace JSC {
         }
 
     protected:
-#if USE(JSVALUE32)
+#if (defined WTF_USE_JSVALUE32 && WTF_USE_JSVALUE32)
         static const unsigned StructureFlags = OverridesMarkChildren | JSWrapperObject::StructureFlags;
 #else
         static const unsigned StructureFlags = JSWrapperObject::StructureFlags;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/RegExp.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/RegExp.cpp
index b0ac400..aa4b0f7 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/RegExp.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/RegExp.cpp
@@ -29,10 +29,10 @@
 #include <wtf/OwnArrayPtr.h>
 
 
-#if ENABLE(YARR)
+#if (defined ENABLE_YARR && ENABLE_YARR)
 
 #include "yarr/RegexCompiler.h"
-#if ENABLE(YARR_JIT)
+#if (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT)
 #include "yarr/RegexJIT.h"
 #else
 #include "yarr/RegexInterpreter.h"
@@ -40,7 +40,7 @@
 
 #else
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 #include "JIT.h"
 #include "WRECGenerator.h"
 #endif
@@ -50,7 +50,7 @@
 
 namespace JSC {
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 using namespace WREC;
 #endif
 
@@ -93,7 +93,7 @@ inline RegExp::RegExp(JSGlobalData* globalData, const UString& pattern, const US
             break;
         default:
             m_constructionError = flagError;
-#if !ENABLE(YARR)
+#if !(defined ENABLE_YARR && ENABLE_YARR)
             m_regExp = 0;
 #endif
             return;
@@ -104,7 +104,7 @@ inline RegExp::RegExp(JSGlobalData* globalData, const UString& pattern, const US
     compile(globalData);
 }
 
-#if !ENABLE(YARR)
+#if !(defined ENABLE_YARR && ENABLE_YARR)
 RegExp::~RegExp()
 {
     jsRegExpFree(m_regExp);
@@ -121,11 +121,11 @@ PassRefPtr<RegExp> RegExp::create(JSGlobalData* globalData, const UString& patte
     return adoptRef(new RegExp(globalData, pattern, flags));
 }
 
-#if ENABLE(YARR)
+#if (defined ENABLE_YARR && ENABLE_YARR)
 
 void RegExp::compile(JSGlobalData* globalData)
 {
-#if ENABLE(YARR_JIT)
+#if (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT)
     Yarr::jitCompileRegex(globalData, m_regExpJITCode, m_pattern, m_numSubpatterns, m_constructionError, ignoreCase(), multiline());
 #else
     UNUSED_PARAM(globalData);
@@ -143,7 +143,7 @@ int RegExp::match(const UString& s, int startOffset, Vector<int, 32>* ovector)
     if (startOffset > s.size() || s.isNull())
         return -1;
 
-#if ENABLE(YARR_JIT)
+#if (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT)
     if (!!m_regExpJITCode) {
 #else
     if (m_regExpBytecode) {
@@ -164,7 +164,7 @@ int RegExp::match(const UString& s, int startOffset, Vector<int, 32>* ovector)
             offsetVector[j] = -1;
 
 
-#if ENABLE(YARR_JIT)
+#if (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT)
         int result = Yarr::executeRegex(m_regExpJITCode, s.data(), startOffset, s.size(), offsetVector, offsetVectorSize);
 #else
         int result = Yarr::interpretRegex(m_regExpBytecode.get(), s.data(), startOffset, s.size(), offsetVector);
@@ -190,7 +190,7 @@ int RegExp::match(const UString& s, int startOffset, Vector<int, 32>* ovector)
 void RegExp::compile(JSGlobalData* globalData)
 {
     m_regExp = 0;
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
     m_wrecFunction = Generator::compileRegExp(globalData, m_pattern, &m_numSubpatterns, &m_constructionError, m_executablePool, ignoreCase(), multiline());
     if (m_wrecFunction || m_constructionError)
         return;
@@ -214,7 +214,7 @@ int RegExp::match(const UString& s, int startOffset, Vector<int, 32>* ovector)
     if (static_cast<unsigned>(startOffset) > s.size() || s.isNull())
         return -1;
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
     if (m_wrecFunction) {
         int offsetVectorSize = (m_numSubpatterns + 1) * 2;
         int* offsetVector;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/RegExp.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/RegExp.h
index 61ab0bc..e004762 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/RegExp.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/RegExp.h
@@ -40,7 +40,7 @@ namespace JSC {
     public:
         static PassRefPtr<RegExp> create(JSGlobalData* globalData, const UString& pattern);
         static PassRefPtr<RegExp> create(JSGlobalData* globalData, const UString& pattern, const UString& flags);
-#if !ENABLE(YARR)
+#if !(defined ENABLE_YARR && ENABLE_YARR)
         ~RegExp();
 #endif
 
@@ -69,12 +69,12 @@ namespace JSC {
         const char* m_constructionError;
         unsigned m_numSubpatterns;
 
-#if ENABLE(YARR_JIT)
+#if (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT)
         Yarr::RegexCodeBlock m_regExpJITCode;
-#elif ENABLE(YARR)
+#elif (defined ENABLE_YARR && ENABLE_YARR)
         OwnPtr<Yarr::BytecodePattern> m_regExpBytecode;
 #else
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
         WREC::CompiledRegExp m_wrecFunction;
         RefPtr<ExecutablePool> m_executablePool;
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StringPrototype.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StringPrototype.cpp
index d002e07..1a87e9f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StringPrototype.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StringPrototype.cpp
@@ -478,7 +478,7 @@ JSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState* exec, JSObject*, JSV
         dpos = 0;
     else if (!(dpos <= len)) // true for NaN
         dpos = len;
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     // Work around for broken NaN compare operator
     else if (isnan(dpos))
         dpos = len;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Structure.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Structure.cpp
index 499c53a..3da65a4 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Structure.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Structure.cpp
@@ -35,7 +35,7 @@
 #include <wtf/RefCountedLeakCounter.h>
 #include <wtf/RefPtr.h>
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 #include <wtf/Threading.h>
 #endif
 
@@ -64,7 +64,7 @@ static const unsigned newTableSize = 16;
 #ifndef NDEBUG
 static WTF::RefCountedLeakCounter structureCounter("Structure");
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 static Mutex& ignoreSetMutex = *(new Mutex);
 #endif
 
@@ -139,7 +139,7 @@ Structure::Structure(JSValue prototype, const TypeInfo& typeInfo)
     ASSERT(m_prototype.isObject() || m_prototype.isNull());
 
 #ifndef NDEBUG
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     MutexLocker protect(ignoreSetMutex);
 #endif
     if (shouldIgnoreLeaks)
@@ -178,7 +178,7 @@ Structure::~Structure()
     }
 
 #ifndef NDEBUG
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     MutexLocker protect(ignoreSetMutex);
 #endif
     HashSet<Structure*>::iterator it = ignoreSet.find(this);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Structure.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Structure.h
index 7571efc..d4e2b66 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Structure.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Structure.h
@@ -210,7 +210,7 @@ namespace JSC {
         bool m_isPinnedPropertyTable : 1;
         bool m_hasGetterSetterProperties : 1;
         bool m_hasNonEnumerableProperties : 1;
-#if COMPILER(WINSCW)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
         // Workaround for Symbian WINSCW compiler that cannot resolve unsigned type of the declared 
         // bitfield, when used as argument in make_pair() function calls in structure.ccp.
         // This bitfield optimization is insignificant for the Symbian emulator target.
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StructureChain.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StructureChain.cpp
index 76e5518..822cce0 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StructureChain.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StructureChain.cpp
@@ -46,7 +46,7 @@ StructureChain::StructureChain(Structure* head)
     m_vector[i] = 0;
 }
 
-#if OS(HPUX)
+#if (defined WTF_OS_HPUX && WTF_OS_HPUX)
 PassRefPtr<StructureChain> StructureChain::create(Structure* head)
 {
     return adoptRef(new StructureChain(head));
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StructureChain.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StructureChain.h
index 3496400..7a16f49 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StructureChain.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/StructureChain.h
@@ -39,7 +39,7 @@ namespace JSC {
         friend class JIT;
 
     public:
-#if OS(HPUX)
+#if (defined WTF_OS_HPUX && WTF_OS_HPUX)
         static PassRefPtr<StructureChain> create(Structure* head);
 #else
         static PassRefPtr<StructureChain> create(Structure* head) { return adoptRef(new StructureChain(head)); }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/TimeoutChecker.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/TimeoutChecker.cpp
index fd259ff..75bb44b 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/TimeoutChecker.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/TimeoutChecker.cpp
@@ -33,9 +33,9 @@
 #include "CallFrame.h"
 #include "JSGlobalObject.h"
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #include <mach/mach.h>
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #include <windows.h>
 #else
 #include "CurrentTime.h"
@@ -54,7 +54,7 @@ static const int defaultIntervalBetweenChecks = 1000;
 // Returns the time the current thread has spent executing, in milliseconds.
 static inline unsigned getCPUTime()
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     mach_msg_type_number_t infoCount = THREAD_BASIC_INFO_COUNT;
     thread_basic_info_data_t info;
 
@@ -67,7 +67,7 @@ static inline unsigned getCPUTime()
     time += info.system_time.seconds * 1000 + info.system_time.microseconds / 1000;
     
     return time;
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     union {
         FILETIME fileTime;
         unsigned long long fileTimeAsLong;
@@ -80,7 +80,7 @@ static inline unsigned getCPUTime()
     GetThreadTimes(GetCurrentThread(), &creationTime, &exitTime, &kernelTime.fileTime, &userTime.fileTime);
     
     return userTime.fileTimeAsLong / 10000 + kernelTime.fileTimeAsLong / 10000;
-#elif OS(SYMBIAN)
+#elif (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     RThread current;
     TTimeIntervalMicroSeconds cpuTime;
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Tracing.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Tracing.h
index c28c85f..0036347 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Tracing.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Tracing.h
@@ -26,7 +26,7 @@
 #ifndef Tracing_h
 #define Tracing_h
 
-#if HAVE(DTRACE)
+#if (defined HAVE_DTRACE && HAVE_DTRACE)
 #include "TracingDtrace.h"
 #else
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UString.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UString.cpp
index a6b66cb..ee273b7 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UString.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UString.cpp
@@ -44,7 +44,7 @@
 #include <wtf/unicode/UTF8.h>
 #include <wtf/StringExtras.h>
 
-#if HAVE(STRINGS_H)
+#if (defined HAVE_STRINGS_H && HAVE_STRINGS_H)
 #include <strings.h>
 #endif
 
@@ -268,7 +268,7 @@ UString UString::from(long long i)
         *--p = '0';
     else if (i == std::numeric_limits<long long>::min()) {
         char minBuf[1 + sizeof(i) * 3];
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
         snprintf(minBuf, sizeof(minBuf) - 1, "%I64d", std::numeric_limits<long long>::min());
 #else
         snprintf(minBuf, sizeof(minBuf) - 1, "%lld", std::numeric_limits<long long>::min());
@@ -858,7 +858,7 @@ int compare(const UString& s1, const UString& s2)
     return (l1 > l2) ? 1 : -1;
 }
 
-#if OS(SOLARIS) && COMPILER(SUNCC)
+#if (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS) && (defined WTF_COMPILER_SUNCC && WTF_COMPILER_SUNCC)
 // Signature must match that of UStringImpl.h, otherwise the linker complains about undefined symbol.
 bool equal(const UStringImpl* r, const UStringImpl* b)
 #else
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UString.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UString.h
index c1f32db..c62a713 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UString.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UString.h
@@ -36,7 +36,7 @@
 #include <wtf/Vector.h>
 #include <wtf/unicode/Unicode.h>
 
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #include <QtCore/qstring.h>
 #endif
 
@@ -82,7 +82,7 @@ namespace JSC {
         friend class JIT;
 
     public:
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
         operator QT_PREPEND_NAMESPACE(QString)() const
         {
             return QT_PREPEND_NAMESPACE(QString)(reinterpret_cast<const QT_PREPEND_NAMESPACE(QChar)*>(this->data()), this->size());
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UStringImpl.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UStringImpl.h
index e6d1a8a..65c7565 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UStringImpl.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/UStringImpl.h
@@ -219,15 +219,15 @@ private:
         checkConsistency();
     }
 
-#if OS(SOLARIS) && COMPILER(SUNCC)
+#if (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS) && (defined WTF_COMPILER_SUNCC && WTF_COMPILER_SUNCC)
 public: // Otherwise the compiler complains about operator new not being accessible.
 #endif
-#if COMPILER(WINSCW) || COMPILER(XLC)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW) || (defined WTF_COMPILER_XLC && WTF_COMPILER_XLC)
     void* operator new(size_t size) { return Noncopyable::operator new(size); }
 #else
     using Noncopyable::operator new;
 #endif
-#if OS(SOLARIS) && COMPILER(SUNCC)
+#if (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS) && (defined WTF_COMPILER_SUNCC && WTF_COMPILER_SUNCC)
 private:
 #endif
     void* operator new(size_t, void* p) { return p; }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/WeakGCPtr.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/WeakGCPtr.h
index 8653721..acfb2da 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/WeakGCPtr.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/WeakGCPtr.h
@@ -52,7 +52,7 @@ public:
     bool operator!() const { return !get(); }
 
     // This conversion operator allows implicit conversion to bool but not to other integer types.
-#if COMPILER(WINSCW)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
     operator bool() const { return m_ptr; }
 #else
     typedef T* WeakGCPtr::*UnspecifiedBoolType;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClass.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClass.cpp
index e3f12f2..1916dd1 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClass.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClass.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "CharacterClass.h"
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 using namespace WTF;
 
@@ -137,4 +137,4 @@ const CharacterClass& CharacterClass::nonwordchar() {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClass.h b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClass.h
index 8a9d2fc..fd6c798 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClass.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClass.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include <wtf/unicode/Unicode.h>
 
@@ -63,6 +63,6 @@ namespace JSC { namespace WREC {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
 
 #endif // CharacterClass_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClassConstructor.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClassConstructor.cpp
index 06f4262..b8448a9 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClassConstructor.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClassConstructor.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "CharacterClassConstructor.h"
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "pcre_internal.h"
 #include <wtf/ASCIICType.h>
@@ -254,4 +254,4 @@ void CharacterClassConstructor::append(const CharacterClass& other)
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClassConstructor.h b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClassConstructor.h
index 581733d..e14956e 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClassConstructor.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/CharacterClassConstructor.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "CharacterClass.h"
 #include <wtf/AlwaysInline.h>
@@ -94,6 +94,6 @@ namespace JSC { namespace WREC {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
 
 #endif // CharacterClassConstructor_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/Escapes.h b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/Escapes.h
index 16c1d6f..e96caab 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/Escapes.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/Escapes.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include <wtf/Assertions.h>
 
@@ -145,6 +145,6 @@ namespace JSC { namespace WREC {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
 
 #endif // Escapes_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/Quantifier.h b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/Quantifier.h
index 3da74cd..7e52b4e 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/Quantifier.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/Quantifier.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include <wtf/Assertions.h>
 #include <limits.h>
@@ -61,6 +61,6 @@ namespace JSC { namespace WREC {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
 
 #endif // Quantifier_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WREC.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WREC.cpp
index 145a1ce..e9caed4 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WREC.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WREC.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "WREC.h"
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "CharacterClassConstructor.h"
 #include "Interpreter.h"
@@ -83,4 +83,4 @@ CompiledRegExp Generator::compileRegExp(JSGlobalData* globalData, const UString&
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WREC.h b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WREC.h
index 13324e7..4655be7 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WREC.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WREC.h
@@ -28,11 +28,11 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include <wtf/unicode/Unicode.h>
 
-#if COMPILER(GCC) && CPU(X86)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_CPU_X86 && WTF_CPU_X86)
 #define WREC_CALL __attribute__ ((regparm (3)))
 #else
 #define WREC_CALL
@@ -49,6 +49,6 @@ namespace JSC { namespace WREC {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
 
 #endif // WREC_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECFunctors.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECFunctors.cpp
index 5f1674e..dfa238a 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECFunctors.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECFunctors.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "WRECFunctors.h"
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "WRECGenerator.h"
 
@@ -77,4 +77,4 @@ void GenerateParenthesesNonGreedyFunctor::backtrack(Generator*)
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECFunctors.h b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECFunctors.h
index 610ce55..b36ea0a 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECFunctors.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECFunctors.h
@@ -25,7 +25,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "WRECGenerator.h"
 #include <wtf/unicode/Unicode.h>
@@ -106,4 +106,4 @@ namespace JSC { namespace WREC {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECGenerator.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECGenerator.cpp
index 7105984..ceef0cf 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECGenerator.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECGenerator.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "WREC.h"
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "CharacterClassConstructor.h"
 #include "Interpreter.h"
@@ -40,12 +40,12 @@ namespace JSC { namespace WREC {
 
 void Generator::generateEnter()
 {
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
     // On x86 edi & esi are callee preserved registers.
     push(X86Registers::edi);
     push(X86Registers::esi);
     
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     // Move the arguments into registers.
     peek(input, 3);
     peek(index, 4);
@@ -71,7 +71,7 @@ void Generator::generateReturnSuccess()
     store32(index, Address(output, 4)); // match end
     
     // Restore callee save registers.
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
     pop(X86Registers::esi);
     pop(X86Registers::edi);
 #endif
@@ -110,7 +110,7 @@ void Generator::generateReturnFailure()
     pop();
     move(Imm32(-1), returnRegister);
 
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
     pop(X86Registers::esi);
     pop(X86Registers::edi);
 #endif
@@ -650,4 +650,4 @@ void Generator::terminateDisjunction(JumpList& successes)
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECGenerator.h b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECGenerator.h
index d707a6e..b04e9e7 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECGenerator.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECGenerator.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "Quantifier.h"
 #include "MacroAssembler.h"
@@ -62,7 +62,7 @@ namespace JSC {
         {
         }
 
-#if CPU(X86)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86)
         static const RegisterID input = X86Registers::eax;
         static const RegisterID index = X86Registers::edx;
         static const RegisterID length = X86Registers::ecx;
@@ -73,7 +73,7 @@ namespace JSC {
 
         static const RegisterID returnRegister = X86Registers::eax;
 #endif
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         static const RegisterID input = X86Registers::edi;
         static const RegisterID index = X86Registers::esi;
         static const RegisterID length = X86Registers::edx;
@@ -123,6 +123,6 @@ namespace JSC {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
 
 #endif // WRECGenerator_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECParser.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECParser.cpp
index 1709bf9..2e88fbd 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECParser.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECParser.cpp
@@ -26,7 +26,7 @@
 #include "config.h"
 #include "WRECParser.h"
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "CharacterClassConstructor.h"
 #include "WRECFunctors.h"
@@ -640,4 +640,4 @@ Generator::ParenthesesType Parser::consumeParenthesesType()
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECParser.h b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECParser.h
index a3e151b..71a42d9 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECParser.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wrec/WRECParser.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(WREC)
+#if (defined ENABLE_WREC && ENABLE_WREC)
 
 #include "Escapes.h"
 #include "Quantifier.h"
@@ -209,6 +209,6 @@ namespace JSC { namespace WREC {
 
 } } // namespace JSC::WREC
 
-#endif // ENABLE(WREC)
+#endif // (defined ENABLE_WREC && ENABLE_WREC)
 
 #endif // Parser_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ASCIICType.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ASCIICType.h
index 0c3c29f..cedaa4d 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ASCIICType.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ASCIICType.h
@@ -46,56 +46,56 @@ namespace WTF {
 
     inline bool isASCII(char c) { return !(c & ~0x7F); }
     inline bool isASCII(unsigned short c) { return !(c & ~0x7F); }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCII(wchar_t c) { return !(c & ~0x7F); }
 #endif
     inline bool isASCII(int c) { return !(c & ~0x7F); }
 
     inline bool isASCIIAlpha(char c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
     inline bool isASCIIAlpha(unsigned short c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIIAlpha(wchar_t c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
 #endif
     inline bool isASCIIAlpha(int c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
 
     inline bool isASCIIAlphanumeric(char c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }
     inline bool isASCIIAlphanumeric(unsigned short c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIIAlphanumeric(wchar_t c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }
 #endif
     inline bool isASCIIAlphanumeric(int c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }
 
     inline bool isASCIIDigit(char c) { return (c >= '0') & (c <= '9'); }
     inline bool isASCIIDigit(unsigned short c) { return (c >= '0') & (c <= '9'); }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIIDigit(wchar_t c) { return (c >= '0') & (c <= '9'); }
 #endif
     inline bool isASCIIDigit(int c) { return (c >= '0') & (c <= '9'); }
 
     inline bool isASCIIHexDigit(char c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }
     inline bool isASCIIHexDigit(unsigned short c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIIHexDigit(wchar_t c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }
 #endif
     inline bool isASCIIHexDigit(int c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }
 
     inline bool isASCIIOctalDigit(char c) { return (c >= '0') & (c <= '7'); }
     inline bool isASCIIOctalDigit(unsigned short c) { return (c >= '0') & (c <= '7'); }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIIOctalDigit(wchar_t c) { return (c >= '0') & (c <= '7'); }
 #endif
     inline bool isASCIIOctalDigit(int c) { return (c >= '0') & (c <= '7'); }
 
     inline bool isASCIILower(char c) { return c >= 'a' && c <= 'z'; }
     inline bool isASCIILower(unsigned short c) { return c >= 'a' && c <= 'z'; }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIILower(wchar_t c) { return c >= 'a' && c <= 'z'; }
 #endif
     inline bool isASCIILower(int c) { return c >= 'a' && c <= 'z'; }
 
     inline bool isASCIIUpper(char c) { return c >= 'A' && c <= 'Z'; }
     inline bool isASCIIUpper(unsigned short c) { return c >= 'A' && c <= 'Z'; }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIIUpper(wchar_t c) { return c >= 'A' && c <= 'Z'; }
 #endif
     inline bool isASCIIUpper(int c) { return c >= 'A' && c <= 'Z'; }
@@ -115,35 +115,35 @@ namespace WTF {
     */
     inline bool isASCIISpace(char c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
     inline bool isASCIISpace(unsigned short c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIISpace(wchar_t c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
 #endif
     inline bool isASCIISpace(int c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
 
     inline char toASCIILower(char c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
     inline unsigned short toASCIILower(unsigned short c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline wchar_t toASCIILower(wchar_t c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
 #endif
     inline int toASCIILower(int c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
 
     inline char toASCIIUpper(char c) { return static_cast<char>(c & ~((c >= 'a' && c <= 'z') << 5)); }
     inline unsigned short toASCIIUpper(unsigned short c) { return static_cast<unsigned short>(c & ~((c >= 'a' && c <= 'z') << 5)); }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline wchar_t toASCIIUpper(wchar_t c) { return static_cast<wchar_t>(c & ~((c >= 'a' && c <= 'z') << 5)); }
 #endif
     inline int toASCIIUpper(int c) { return static_cast<int>(c & ~((c >= 'a' && c <= 'z') << 5)); }
 
     inline int toASCIIHexValue(char c) { ASSERT(isASCIIHexDigit(c)); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
     inline int toASCIIHexValue(unsigned short c) { ASSERT(isASCIIHexDigit(c)); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline int toASCIIHexValue(wchar_t c) { ASSERT(isASCIIHexDigit(c)); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
 #endif
     inline int toASCIIHexValue(int c) { ASSERT(isASCIIHexDigit(c)); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
 
     inline bool isASCIIPrintable(char c) { return c >= ' ' && c <= '~'; }
     inline bool isASCIIPrintable(unsigned short c) { return c >= ' ' && c <= '~'; }
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     inline bool isASCIIPrintable(wchar_t c) { return c >= ' ' && c <= '~'; }
 #endif
     inline bool isASCIIPrintable(int c) { return c >= ' ' && c <= '~'; }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/AlwaysInline.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/AlwaysInline.h
index ce27df6..a5ac600 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/AlwaysInline.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/AlwaysInline.h
@@ -21,9 +21,9 @@
 #include "Platform.h"
 
 #ifndef ALWAYS_INLINE
-#if COMPILER(GCC) && defined(NDEBUG) && !COMPILER(MINGW)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && defined(NDEBUG) && !(defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW)
 #define ALWAYS_INLINE inline __attribute__((__always_inline__))
-#elif (COMPILER(MSVC) || COMPILER(RVCT)) && defined(NDEBUG)
+#elif ((defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)) && defined(NDEBUG)
 #define ALWAYS_INLINE __forceinline
 #else
 #define ALWAYS_INLINE inline
@@ -31,9 +31,9 @@
 #endif
 
 #ifndef NEVER_INLINE
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define NEVER_INLINE __attribute__((__noinline__))
-#elif COMPILER(RVCT)
+#elif (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
 #define NEVER_INLINE __declspec(noinline)
 #else
 #define NEVER_INLINE
@@ -41,7 +41,7 @@
 #endif
 
 #ifndef UNLIKELY
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define UNLIKELY(x) __builtin_expect((x), 0)
 #else
 #define UNLIKELY(x) (x)
@@ -49,7 +49,7 @@
 #endif
 
 #ifndef LIKELY
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define LIKELY(x) __builtin_expect((x), 1)
 #else
 #define LIKELY(x) (x)
@@ -57,9 +57,9 @@
 #endif
 
 #ifndef NO_RETURN
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define NO_RETURN __attribute((__noreturn__))
-#elif COMPILER(RVCT)
+#elif (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
 #define NO_RETURN __declspec(noreturn)
 #else
 #define NO_RETURN
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Assertions.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Assertions.cpp
index 4615810..309f21b 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Assertions.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Assertions.cpp
@@ -31,11 +31,11 @@
 #include <stdarg.h>
 #include <string.h>
 
-#if PLATFORM(MAC)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
 #include <CoreFoundation/CFString.h>
 #endif
 
-#if COMPILER(MSVC) && !OS(WINCE)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && !(defined WTF_OS_WINCE && WTF_OS_WINCE)
 #ifndef WINVER
 #define WINVER 0x0500
 #endif
@@ -46,7 +46,7 @@
 #include <crtdbg.h>
 #endif
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 #include <winbase.h>
 #endif
 
@@ -55,7 +55,7 @@ extern "C" {
 WTF_ATTRIBUTE_PRINTF(1, 0)
 static void vprintf_stderr_common(const char* format, va_list args)
 {
-#if PLATFORM(MAC)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
     if (strstr(format, "%@")) {
         CFStringRef cfFormat = CFStringCreateWithCString(NULL, format, kCFStringEncodingUTF8);
         CFStringRef str = CFStringCreateWithFormatAndArguments(NULL, NULL, cfFormat, args);
@@ -71,7 +71,7 @@ static void vprintf_stderr_common(const char* format, va_list args)
         CFRelease(str);
         CFRelease(cfFormat);
     } else
-#elif COMPILER(MSVC) && !defined(WINCEBASIC)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && !defined(WINCEBASIC)
 # if !defined(_WIN32_WCE) || (_WIN32_WCE >= 0x600)
     if (IsDebuggerPresent())
 # endif
@@ -85,7 +85,7 @@ static void vprintf_stderr_common(const char* format, va_list args)
                 break;
 
             if (_vsnprintf(buffer, size, format, args) != -1) {
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
                 // WinCE only supports wide chars
                 wchar_t* wideBuffer = (wchar_t*)malloc(size * sizeof(wchar_t));
                 if (wideBuffer == NULL)
@@ -108,7 +108,7 @@ static void vprintf_stderr_common(const char* format, va_list args)
         } while (size > 1024);
     }
 #endif
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
     vfprintf(stdout, format, args);
 #else
     vfprintf(stderr, format, args);
@@ -126,7 +126,7 @@ static void printf_stderr_common(const char* format, ...)
 
 static void printCallSite(const char* file, int line, const char* function)
 {
-#if OS(WIN) && !OS(WINCE) && defined _DEBUG
+#if (defined WTF_OS_WIN && WTF_OS_WIN) && !(defined WTF_OS_WINCE && WTF_OS_WINCE) && defined _DEBUG
     _CrtDbgReport(_CRT_WARN, file, line, NULL, "%s\n", function);
 #else
     printf_stderr_common("(%s:%d %s)\n", file, line, function);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Assertions.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Assertions.h
index 352a74b..7d3e913 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Assertions.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Assertions.h
@@ -44,13 +44,13 @@
 
 #include "Platform.h"
 
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || ((defined WTF_COMPILER_INTEL && WTF_COMPILER_INTEL) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS))
 #include <stddef.h>
 #else
 #include <inttypes.h>
 #endif
 
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 #include <e32def.h>
 #include <e32debug.h>
 #endif
@@ -61,7 +61,7 @@
 #define ASSERTIONS_DISABLED_DEFAULT 0
 #endif
 
-#if COMPILER(MSVC7) || COMPILER(WINSCW)
+#if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7) || (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
 #define HAVE_VARIADIC_MACRO 0
 #else
 #define HAVE_VARIADIC_MACRO 1
@@ -72,7 +72,7 @@
 #endif
 
 #ifndef ASSERT_MSG_DISABLED
-#if HAVE(VARIADIC_MACRO)
+#if (defined HAVE_VARIADIC_MACRO && HAVE_VARIADIC_MACRO)
 #define ASSERT_MSG_DISABLED ASSERTIONS_DISABLED_DEFAULT
 #else
 #define ASSERT_MSG_DISABLED 1
@@ -84,7 +84,7 @@
 #endif
 
 #ifndef FATAL_DISABLED
-#if HAVE(VARIADIC_MACRO)
+#if (defined HAVE_VARIADIC_MACRO && HAVE_VARIADIC_MACRO)
 #define FATAL_DISABLED ASSERTIONS_DISABLED_DEFAULT
 #else
 #define FATAL_DISABLED 1
@@ -92,7 +92,7 @@
 #endif
 
 #ifndef ERROR_DISABLED
-#if HAVE(VARIADIC_MACRO)
+#if (defined HAVE_VARIADIC_MACRO && HAVE_VARIADIC_MACRO)
 #define ERROR_DISABLED ASSERTIONS_DISABLED_DEFAULT
 #else
 #define ERROR_DISABLED 1
@@ -100,14 +100,14 @@
 #endif
 
 #ifndef LOG_DISABLED
-#if HAVE(VARIADIC_MACRO)
+#if (defined HAVE_VARIADIC_MACRO && HAVE_VARIADIC_MACRO)
 #define LOG_DISABLED ASSERTIONS_DISABLED_DEFAULT
 #else
 #define LOG_DISABLED 1
 #endif
 #endif
 
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define WTF_PRETTY_FUNCTION __PRETTY_FUNCTION__
 #else
 #define WTF_PRETTY_FUNCTION __FUNCTION__
@@ -116,7 +116,7 @@
 /* WTF logging functions can process %@ in the format string to log a NSObject* but the printf format attribute
    emits a warning when %@ is used in the format string.  Until <rdar://problem/5195437> is resolved we can't include
    the attribute when being used from Objective-C code in case it decides to use %@. */
-#if COMPILER(GCC) && !defined(__OBJC__)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && !defined(__OBJC__)
 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments) __attribute__((__format__(printf, formatStringArgument, extraArguments)))
 #else
 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments) 
@@ -151,7 +151,7 @@ void WTFLogVerbose(const char* file, int line, const char* function, WTFLogChann
 /* CRASH -- gets us into the debugger or the crash reporter -- signals are ignored by the crash reporter so we must do better */
 
 #ifndef CRASH
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 #define CRASH() do { \
     __DEBUGGER(); \
     User::Panic(_L("Webkit CRASH"),0); \
@@ -166,7 +166,7 @@ void WTFLogVerbose(const char* file, int line, const char* function, WTFLogChann
 
 /* ASSERT, ASSERT_NOT_REACHED, ASSERT_UNUSED */
 
-#if OS(WINCE) && !PLATFORM(TORCHMOBILE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE) && !(defined WTF_PLATFORM_TORCHMOBILE && WTF_PLATFORM_TORCHMOBILE)
 /* FIXME: We include this here only to avoid a conflict with the ASSERT macro. */
 #include <windows.h>
 #undef min
@@ -174,7 +174,7 @@ void WTFLogVerbose(const char* file, int line, const char* function, WTFLogChann
 #undef ERROR
 #endif
 
-#if OS(WINDOWS) || OS(SYMBIAN)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) || (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 /* FIXME: Change to use something other than ASSERT to avoid this conflict with the underlying platform */
 #undef ASSERT
 #endif
@@ -205,9 +205,9 @@ while (0)
 
 /* ASSERT_WITH_MESSAGE */
 
-#if COMPILER(MSVC7)
+#if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7)
 #define ASSERT_WITH_MESSAGE(assertion) ((void)0)
-#elif COMPILER(WINSCW)
+#elif (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
 #define ASSERT_WITH_MESSAGE(assertion, arg...) ((void)0)
 #elif ASSERT_MSG_DISABLED
 #define ASSERT_WITH_MESSAGE(assertion, ...) ((void)0)
@@ -245,9 +245,9 @@ while (0)
 
 /* FATAL */
 
-#if COMPILER(MSVC7)
+#if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7)
 #define FATAL() ((void)0)
-#elif COMPILER(WINSCW)
+#elif (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
 #define FATAL(arg...) ((void)0)
 #elif FATAL_DISABLED
 #define FATAL(...) ((void)0)
@@ -260,9 +260,9 @@ while (0)
 
 /* LOG_ERROR */
 
-#if COMPILER(MSVC7)
+#if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7)
 #define LOG_ERROR() ((void)0)
-#elif COMPILER(WINSCW)
+#elif (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
 #define LOG_ERROR(arg...)  ((void)0)
 #elif ERROR_DISABLED
 #define LOG_ERROR(...) ((void)0)
@@ -272,9 +272,9 @@ while (0)
 
 /* LOG */
 
-#if COMPILER(MSVC7)
+#if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7)
 #define LOG() ((void)0)
-#elif COMPILER(WINSCW)
+#elif (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
 #define LOG(arg...) ((void)0)
 #elif LOG_DISABLED
 #define LOG(channel, ...) ((void)0)
@@ -286,9 +286,9 @@ while (0)
 
 /* LOG_VERBOSE */
 
-#if COMPILER(MSVC7)
+#if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7)
 #define LOG_VERBOSE(channel) ((void)0)
-#elif COMPILER(WINSCW)
+#elif (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
 #define LOG_VERBOSE(channel, arg...) ((void)0)
 #elif LOG_DISABLED
 #define LOG_VERBOSE(channel, ...) ((void)0)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/CurrentTime.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/CurrentTime.cpp
index b272874..84c22c5 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/CurrentTime.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/CurrentTime.cpp
@@ -33,9 +33,9 @@
 #include "config.h"
 #include "CurrentTime.h"
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
-// Windows is first since we want to use hires timers, despite PLATFORM(CF)
+// Windows is first since we want to use hires timers, despite (defined WTF_PLATFORM_CF && WTF_PLATFORM_CF)
 // being defined.
 // If defined, WIN32_LEAN_AND_MEAN disables timeBeginPeriod/timeEndPeriod.
 #undef WIN32_LEAN_AND_MEAN
@@ -44,8 +44,8 @@
 #include <stdint.h>
 #include <time.h>
 
-#if USE(QUERY_PERFORMANCE_COUNTER)
-#if OS(WINCE)
+#if (defined WTF_USE_QUERY_PERFORMANCE_COUNTER && WTF_USE_QUERY_PERFORMANCE_COUNTER)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 extern "C" time_t mktime(struct tm *t);
 #else
 #include <sys/timeb.h>
@@ -53,17 +53,17 @@ extern "C" time_t mktime(struct tm *t);
 #endif
 #endif
 
-#elif PLATFORM(CF)
+#elif (defined WTF_PLATFORM_CF && WTF_PLATFORM_CF)
 #include <CoreFoundation/CFDate.h>
-#elif PLATFORM(GTK)
+#elif (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK)
 #include <glib.h>
-#elif PLATFORM(WX)
+#elif (defined WTF_PLATFORM_WX && WTF_PLATFORM_WX)
 #include <wx/datetime.h>
 #else // Posix systems relying on the gettimeofday()
 #include <sys/time.h>
 #endif
 
-#if PLATFORM(CHROMIUM)
+#if (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM)
 #error Chromium uses a different timer implementation
 #endif
 
@@ -71,9 +71,9 @@ namespace WTF {
 
 const double msPerSecond = 1000.0;
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
-#if USE(QUERY_PERFORMANCE_COUNTER)
+#if (defined WTF_USE_QUERY_PERFORMANCE_COUNTER && WTF_USE_QUERY_PERFORMANCE_COUNTER)
 
 static LARGE_INTEGER qpcFrequency;
 static bool syncedTime;
@@ -99,7 +99,7 @@ static double highResUpTime()
         if (tickCount >= tickCountLast)
             tickCountElapsed = (tickCount - tickCountLast);
         else {
-#if COMPILER(MINGW)
+#if (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW)
             __int64 tickCountLarge = tickCount + 0x100000000ULL;
 #else
             __int64 tickCountLarge = tickCount + 0x100000000I64;
@@ -123,7 +123,7 @@ static double highResUpTime()
 
 static double lowResUTCTime()
 {
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
     SYSTEMTIME systemTime;
     GetSystemTime(&systemTime);
     struct tm tmtime;
@@ -247,18 +247,18 @@ double currentTime()
     return timeNow;
 }
 
-#endif // USE(QUERY_PERFORMANCE_COUNTER)
+#endif // (defined WTF_USE_QUERY_PERFORMANCE_COUNTER && WTF_USE_QUERY_PERFORMANCE_COUNTER)
 
-#elif PLATFORM(CF)
+#elif (defined WTF_PLATFORM_CF && WTF_PLATFORM_CF)
 
 double currentTime()
 {
     return CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970;
 }
 
-#elif PLATFORM(GTK)
+#elif (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK)
 
-// Note: GTK on Windows will pick up the PLATFORM(WIN) implementation above which provides
+// Note: GTK on Windows will pick up the (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN) implementation above which provides
 // better accuracy compared with Windows implementation of g_get_current_time:
 // (http://www.google.com/codesearch/p?hl=en#HHnNRjks1t0/glib-2.5.2/glib/gmain.c&q=g_get_current_time).
 // Non-Windows GTK builds could use gettimeofday() directly but for the sake of consistency lets use GTK function.
@@ -269,7 +269,7 @@ double currentTime()
     return static_cast<double>(now.tv_sec) + static_cast<double>(now.tv_usec / 1000000.0);
 }
 
-#elif PLATFORM(WX)
+#elif (defined WTF_PLATFORM_WX && WTF_PLATFORM_WX)
 
 double currentTime()
 {
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/CurrentTime.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/CurrentTime.h
index 334a6e9..51c1c00 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/CurrentTime.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/CurrentTime.h
@@ -49,9 +49,9 @@ namespace WTF {
 
     inline void getLocalTime(const time_t* localTime, struct tm* localTM)
     {
-    #if COMPILER(MSVC7) || COMPILER(MINGW) || OS(WINCE)
+    #if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7) || (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW) || (defined WTF_OS_WINCE && WTF_OS_WINCE)
         *localTM = *localtime(localTime);
-    #elif COMPILER(MSVC)
+    #elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
         localtime_s(localTM, localTime);
     #else
         localtime_r(localTime, localTM);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/DateMath.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/DateMath.cpp
index b9a0207..093cf82 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/DateMath.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/DateMath.cpp
@@ -84,24 +84,24 @@
 #include <time.h>
 
 
-#if HAVE(ERRNO_H)
+#if (defined HAVE_ERRNO_H && HAVE_ERRNO_H)
 #include <errno.h>
 #endif
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 extern "C" size_t strftime(char * const s, const size_t maxsize, const char * const format, const struct tm * const t);
 extern "C" struct tm * localtime(const time_t *timer);
 #endif
 
-#if HAVE(SYS_TIME_H)
+#if (defined HAVE_SYS_TIME_H && HAVE_SYS_TIME_H)
 #include <sys/time.h>
 #endif
 
-#if HAVE(SYS_TIMEB_H)
+#if (defined HAVE_SYS_TIMEB_H && HAVE_SYS_TIMEB_H)
 #include <sys/timeb.h>
 #endif
 
-#if USE(JSC)
+#if (defined WTF_USE_JSC && WTF_USE_JSC)
 #include "CallFrame.h"
 #endif
 
@@ -379,7 +379,7 @@ int equivalentYearForDST(int year)
 
 static int32_t calculateUTCOffset()
 {
-#if PLATFORM(BREWMP)
+#if (defined WTF_PLATFORM_BREWMP && WTF_PLATFORM_BREWMP)
     time_t localTime = static_cast<time_t>(currentTime());
 #else
     time_t localTime = time(0);
@@ -397,14 +397,14 @@ static int32_t calculateUTCOffset()
     localt.tm_wday = 0;
     localt.tm_yday = 0;
     localt.tm_isdst = 0;
-#if HAVE(TM_GMTOFF)
+#if (defined HAVE_TM_GMTOFF && HAVE_TM_GMTOFF)
     localt.tm_gmtoff = 0;
 #endif
-#if HAVE(TM_ZONE)
+#if (defined HAVE_TM_ZONE && HAVE_TM_ZONE)
     localt.tm_zone = 0;
 #endif
     
-#if HAVE(TIMEGM)
+#if (defined HAVE_TIMEGM && HAVE_TIMEGM)
     time_t utcOffset = timegm(&localt) - mktime(&localt);
 #else
     // Using a canned date of 01/01/2009 on platforms with weaker date-handling foo.
@@ -492,7 +492,7 @@ static inline double ymdhmsToSeconds(long year, int mon, int day, int hour, int
 // We follow the recommendation of RFC 2822 to consider all
 // obsolete time zones not listed here equivalent to "-0000".
 static const struct KnownZone {
-#if !OS(WINDOWS)
+#if !(defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     const
 #endif
         char tzName[4];
@@ -856,7 +856,7 @@ double timeClip(double t)
 }
 } // namespace WTF
 
-#if USE(JSC)
+#if (defined WTF_USE_JSC && WTF_USE_JSC)
 namespace JSC {
 
 // Get the DST offset for the time passed in.
@@ -993,4 +993,4 @@ double parseDateFromNullTerminatedCharacters(ExecState* exec, const char* dateSt
 }
 
 } // namespace JSC
-#endif // USE(JSC)
+#endif // (defined WTF_USE_JSC && WTF_USE_JSC)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/DateMath.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/DateMath.h
index 033d25e..bef6dfb 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/DateMath.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/DateMath.h
@@ -95,7 +95,7 @@ using WTF::msPerSecond;
 using WTF::msToYear;
 using WTF::secondsPerMinute;
 
-#if USE(JSC)
+#if (defined WTF_USE_JSC && WTF_USE_JSC)
 namespace JSC {
 class ExecState;
 struct GregorianDateTime;
@@ -140,13 +140,13 @@ struct GregorianDateTime : Noncopyable {
         , isDST(inTm.tm_isdst)
     {
         UNUSED_PARAM(exec);
-#if HAVE(TM_GMTOFF)
+#if (defined HAVE_TM_GMTOFF && HAVE_TM_GMTOFF)
         utcOffset = static_cast<int>(inTm.tm_gmtoff);
 #else
         utcOffset = static_cast<int>(getUTCOffset(exec) / WTF::msPerSecond + (isDST ? WTF::secondsPerHour : 0));
 #endif
 
-#if HAVE(TM_ZONE)
+#if (defined HAVE_TM_ZONE && HAVE_TM_ZONE)
         int inZoneSize = strlen(inTm.tm_zone) + 1;
         timeZone = new char[inZoneSize];
         strncpy(timeZone, inTm.tm_zone, inZoneSize);
@@ -170,10 +170,10 @@ struct GregorianDateTime : Noncopyable {
         ret.tm_year  =  year;
         ret.tm_isdst =  isDST;
 
-#if HAVE(TM_GMTOFF)
+#if (defined HAVE_TM_GMTOFF && HAVE_TM_GMTOFF)
         ret.tm_gmtoff = static_cast<long>(utcOffset);
 #endif
-#if HAVE(TM_ZONE)
+#if (defined HAVE_TM_ZONE && HAVE_TM_ZONE)
         ret.tm_zone = timeZone;
 #endif
 
@@ -218,6 +218,6 @@ static inline int gmtoffset(const GregorianDateTime& t)
     return t.utcOffset;
 }
 } // namespace JSC
-#endif // USE(JSC)
+#endif // (defined WTF_USE_JSC && WTF_USE_JSC)
 
 #endif // DateMath_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.cpp
index d95f078..f431acc 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.cpp
@@ -79,7 +79,7 @@
 
 #include "Assertions.h"
 #include <limits>
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 #include <pthread.h>
 #endif
 
@@ -111,7 +111,7 @@
 #ifndef NDEBUG
 namespace WTF {
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 static pthread_key_t isForbiddenKey;
 static pthread_once_t isForbiddenKeyOnce = PTHREAD_ONCE_INIT;
 static void initializeIsForbiddenKey()
@@ -156,7 +156,7 @@ void fastMallocAllow()
 {
     staticIsForbidden = false;
 }
-#endif // ENABLE(JSC_MULTIPLE_THREADS)
+#endif // (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 
 } // namespace WTF
 #endif // NDEBUG
@@ -165,7 +165,7 @@ void fastMallocAllow()
 
 namespace WTF {
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
 
 namespace Internal {
 
@@ -215,7 +215,7 @@ TryMallocReturnValue tryFastMalloc(size_t n)
 {
     ASSERT(!isForbidden());
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     if (std::numeric_limits<size_t>::max() - sizeof(AllocAlignmentInteger) <= n)  // If overflow would occur...
         return 0;
 
@@ -236,7 +236,7 @@ void* fastMalloc(size_t n)
 {
     ASSERT(!isForbidden());
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     TryMallocReturnValue returnValue = tryFastMalloc(n);
     void* result;
     returnValue.getValue(result);
@@ -253,7 +253,7 @@ TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size)
 {
     ASSERT(!isForbidden());
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     size_t totalBytes = n_elements * element_size;
     if (n_elements > 1 && element_size && (totalBytes / element_size) != n_elements || (std::numeric_limits<size_t>::max() - sizeof(AllocAlignmentInteger) <= totalBytes))
         return 0;
@@ -276,7 +276,7 @@ void* fastCalloc(size_t n_elements, size_t element_size)
 {
     ASSERT(!isForbidden());
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     TryMallocReturnValue returnValue = tryFastCalloc(n_elements, element_size);
     void* result;
     returnValue.getValue(result);
@@ -293,7 +293,7 @@ void fastFree(void* p)
 {
     ASSERT(!isForbidden());
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     if (!p)
         return;
 
@@ -310,7 +310,7 @@ TryMallocReturnValue tryFastRealloc(void* p, size_t n)
 {
     ASSERT(!isForbidden());
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     if (p) {
         if (std::numeric_limits<size_t>::max() - sizeof(AllocAlignmentInteger) <= n)  // If overflow would occur...
             return 0;
@@ -337,7 +337,7 @@ void* fastRealloc(void* p, size_t n)
 {
     ASSERT(!isForbidden());
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     TryMallocReturnValue returnValue = tryFastRealloc(p, n);
     void* result;
     returnValue.getValue(result);
@@ -360,7 +360,7 @@ FastMallocStatistics fastMallocStatistics()
 
 } // namespace WTF
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 // This symbol is present in the JavaScriptCore exports file even when FastMalloc is disabled.
 // It will never be used in this case, so it's type and value are less interesting than its presence.
 extern "C" const int jscore_fastmalloc_introspection = 0;
@@ -368,9 +368,9 @@ extern "C" const int jscore_fastmalloc_introspection = 0;
 
 #else // FORCE_SYSTEM_MALLOC
 
-#if HAVE(STDINT_H)
+#if (defined HAVE_STDINT_H && HAVE_STDINT_H)
 #include <stdint.h>
-#elif HAVE(INTTYPES_H)
+#elif (defined HAVE_INTTYPES_H && HAVE_INTTYPES_H)
 #include <inttypes.h>
 #else
 #include <sys/types.h>
@@ -390,10 +390,10 @@ extern "C" const int jscore_fastmalloc_introspection = 0;
 #include <stdarg.h>
 #include <stddef.h>
 #include <stdio.h>
-#if OS(UNIX)
+#if (defined WTF_OS_UNIX && WTF_OS_UNIX)
 #include <unistd.h>
 #endif
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #ifndef WIN32_LEAN_AND_MEAN
 #define WIN32_LEAN_AND_MEAN
 #endif
@@ -402,12 +402,12 @@ extern "C" const int jscore_fastmalloc_introspection = 0;
 
 #if WTF_CHANGES
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #include "MallocZoneSupport.h"
 #include <wtf/HashSet.h>
 #include <wtf/Vector.h>
 #endif
-#if HAVE(DISPATCH_H)
+#if (defined HAVE_DISPATCH_H && HAVE_DISPATCH_H)
 #include <dispatch/dispatch.h>
 #endif
 
@@ -420,7 +420,7 @@ extern "C" const int jscore_fastmalloc_introspection = 0;
 // call to the function on Mac OS X, and it's used in performance-critical code. So we
 // use a function pointer. But that's not necessarily faster on other platforms, and we had
 // problems with this technique on Windows, so we'll do this only on Mac OS X.
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 static void* (*pthread_getspecific_function_pointer)(pthread_key_t) = pthread_getspecific;
 #define pthread_getspecific(key) pthread_getspecific_function_pointer(key)
 #endif
@@ -448,7 +448,7 @@ namespace WTF {
 #define MESSAGE LOG_ERROR
 #define CHECK_CONDITION ASSERT
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 class Span;
 class TCMalloc_Central_FreeListPadded;
 class TCMalloc_PageHeap;
@@ -1005,7 +1005,7 @@ class PageHeapAllocator {
 
   int inuse() const { return inuse_; }
 
-#if defined(WTF_CHANGES) && OS(DARWIN)
+#if defined(WTF_CHANGES) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
   template <class Recorder>
   void recordAdministrativeRegions(Recorder& recorder, const RemoteMemoryReader& reader)
   {
@@ -1187,7 +1187,7 @@ template <int BITS> class MapSelector {
 };
 
 #if defined(WTF_CHANGES)
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 // On all known X86-64 platforms, the upper 16 bits are always unused and therefore 
 // can be excluded from the PageMap key.
 // See http://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details
@@ -1238,7 +1238,7 @@ static const int kScavengeTimerDelayInSeconds = 5;
 static const size_t kMinimumFreeCommittedPageCount = 512;
 
 // During a scavenge, we'll release up to a fraction of the free committed pages.
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 // We are slightly less aggressive in releasing memory on Windows due to performance reasons.
 static const int kMaxScavengeAmountFactor = 3;
 #else
@@ -1387,7 +1387,7 @@ class TCMalloc_PageHeap {
   // Index of last free list we scavenged
   size_t scavenge_index_;
   
-#if defined(WTF_CHANGES) && OS(DARWIN)
+#if defined(WTF_CHANGES) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
   friend class FastMallocZone;
 #endif
 
@@ -1397,7 +1397,7 @@ class TCMalloc_PageHeap {
   void scavenge();
   ALWAYS_INLINE bool shouldContinueScavenging() const;
 
-#if !HAVE(DISPATCH_H)
+#if !(defined HAVE_DISPATCH_H && HAVE_DISPATCH_H)
   static NO_RETURN void* runScavengerThread(void*);
   NO_RETURN void scavengerThread();
 
@@ -1407,7 +1407,7 @@ class TCMalloc_PageHeap {
 
   pthread_mutex_t m_scavengeMutex;
   pthread_cond_t m_scavengeCondition;
-#else // !HAVE(DISPATCH_H)
+#else // !(defined HAVE_DISPATCH_H && HAVE_DISPATCH_H)
   void periodicScavenge();
 
   dispatch_queue_t m_scavengeQueue;
@@ -1448,7 +1448,7 @@ void TCMalloc_PageHeap::init()
 
 #if USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY
 
-#if !HAVE(DISPATCH_H)
+#if !(defined HAVE_DISPATCH_H && HAVE_DISPATCH_H)
 
 void TCMalloc_PageHeap::initializeScavenger()
 {
@@ -1462,7 +1462,7 @@ void TCMalloc_PageHeap::initializeScavenger()
 void* TCMalloc_PageHeap::runScavengerThread(void* context)
 {
   static_cast<TCMalloc_PageHeap*>(context)->scavengerThread();
-#if COMPILER(MSVC) || OS(SOLARIS)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)
   // Without this, Visual Studio will complain that this method does not return a value.
   return 0;
 #endif
@@ -1474,7 +1474,7 @@ ALWAYS_INLINE void TCMalloc_PageHeap::signalScavenger()
     pthread_cond_signal(&m_scavengeCondition);
 }
 
-#else // !HAVE(DISPATCH_H)
+#else // !(defined HAVE_DISPATCH_H && HAVE_DISPATCH_H)
 
 void TCMalloc_PageHeap::initializeScavenger()
 {
@@ -2110,7 +2110,7 @@ class TCMalloc_ThreadCache_FreeList {
 class TCMalloc_ThreadCache {
  private:
   typedef TCMalloc_ThreadCache_FreeList FreeList;
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
   typedef DWORD ThreadIdentifier;
 #else
   typedef pthread_t ThreadIdentifier;
@@ -2337,8 +2337,8 @@ static inline TCMalloc_PageHeap* getPageHeap()
 
 #if USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY
 
-#if !HAVE(DISPATCH_H)
-#if OS(WINDOWS)
+#if !(defined HAVE_DISPATCH_H && HAVE_DISPATCH_H)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 static void sleep(unsigned seconds)
 {
     ::Sleep(seconds * 1000);
@@ -2347,7 +2347,7 @@ static void sleep(unsigned seconds)
 
 void TCMalloc_PageHeap::scavengerThread()
 {
-#if HAVE(PTHREAD_SETNAME_NP)
+#if (defined HAVE_PTHREAD_SETNAME_NP && HAVE_PTHREAD_SETNAME_NP)
   pthread_setname_np("JavaScriptCore: FastMalloc scavenger");
 #endif
 
@@ -2382,7 +2382,7 @@ void TCMalloc_PageHeap::periodicScavenge()
     dispatch_suspend(m_scavengeTimer);
   }
 }
-#endif // HAVE(DISPATCH_H)
+#endif // (defined HAVE_DISPATCH_H && HAVE_DISPATCH_H)
 
 #endif
 
@@ -2403,7 +2403,7 @@ static __thread TCMalloc_ThreadCache *threadlocal_heap;
 // Until then, we use a slow path to get the heap object.
 static bool tsd_inited = false;
 static pthread_key_t heap_key;
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 DWORD tlsIndex = TLS_OUT_OF_INDEXES;
 #endif
 
@@ -2412,7 +2412,7 @@ static ALWAYS_INLINE void setThreadHeap(TCMalloc_ThreadCache* heap)
     // still do pthread_setspecific when using MSVC fast TLS to
     // benefit from the delete callback.
     pthread_setspecific(heap_key, heap);
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     TlsSetValue(tlsIndex, heap);
 #endif
 }
@@ -2893,7 +2893,7 @@ void TCMalloc_ThreadCache::InitModule() {
     }
     pageheap->init();
     phinited = 1;
-#if defined(WTF_CHANGES) && OS(DARWIN)
+#if defined(WTF_CHANGES) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     FastMallocZone::init();
 #endif
   }
@@ -2917,7 +2917,7 @@ inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::GetThreadHeap() {
     // __thread is faster, but only when the kernel supports it
   if (KernelSupportsTLS())
     return threadlocal_heap;
-#elif COMPILER(MSVC)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     return static_cast<TCMalloc_ThreadCache*>(TlsGetValue(tlsIndex));
 #else
     return static_cast<TCMalloc_ThreadCache*>(pthread_getspecific(heap_key));
@@ -2947,12 +2947,12 @@ inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::GetCacheIfPresent() {
 void TCMalloc_ThreadCache::InitTSD() {
   ASSERT(!tsd_inited);
   pthread_key_create(&heap_key, DestroyThreadCache);
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
   tlsIndex = TlsAlloc();
 #endif
   tsd_inited = true;
     
-#if !COMPILER(MSVC)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
   // We may have used a fake pthread_t for the main thread.  Fix it.
   pthread_t zero;
   memset(&zero, 0, sizeof(zero));
@@ -2963,7 +2963,7 @@ void TCMalloc_ThreadCache::InitTSD() {
   ASSERT(pageheap_lock.IsHeld());
 #endif
   for (TCMalloc_ThreadCache* h = thread_heaps; h != NULL; h = h->next_) {
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     if (h->tid_ == 0) {
       h->tid_ = GetCurrentThreadId();
     }
@@ -2981,7 +2981,7 @@ TCMalloc_ThreadCache* TCMalloc_ThreadCache::CreateCacheIfNecessary() {
   {
     SpinLockHolder lockholder(&pageheap_lock);
 
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     DWORD me;
     if (!tsd_inited) {
       me = 0;
@@ -3002,7 +3002,7 @@ TCMalloc_ThreadCache* TCMalloc_ThreadCache::CreateCacheIfNecessary() {
     // In that case, the heap for this thread has already been created
     // and added to the linked list.  So we search for that first.
     for (TCMalloc_ThreadCache* h = thread_heaps; h != NULL; h = h->next_) {
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
       if (h->tid_ == me) {
 #else
       if (pthread_equal(h->tid_, me)) {
@@ -3676,7 +3676,7 @@ template <bool crashOnFailure>
 ALWAYS_INLINE
 #endif
 void* malloc(size_t size) {
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     if (std::numeric_limits<size_t>::max() - sizeof(AllocAlignmentInteger) <= size)  // If overflow would occur...
         return 0;
     size += sizeof(AllocAlignmentInteger);
@@ -3704,7 +3704,7 @@ void free(void* ptr) {
   MallocHook::InvokeDeleteHook(ptr);
 #endif
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     if (!ptr)
         return;
 
@@ -3743,7 +3743,7 @@ void* calloc(size_t n, size_t elem_size) {
   if (n > 1 && elem_size && (totalBytes / elem_size) != n)
     return 0;
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     if (std::numeric_limits<size_t>::max() - sizeof(AllocAlignmentInteger) <= totalBytes)  // If overflow would occur...
         return 0;
 
@@ -3802,7 +3802,7 @@ ALWAYS_INLINE
 #endif
 void* realloc(void* old_ptr, size_t new_size) {
   if (old_ptr == NULL) {
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     void* result = malloc(new_size);
 #else
     void* result = do_malloc(new_size);
@@ -3820,7 +3820,7 @@ void* realloc(void* old_ptr, size_t new_size) {
     return NULL;
   }
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     if (std::numeric_limits<size_t>::max() - sizeof(AllocAlignmentInteger) <= new_size)  // If overflow would occur...
         return 0;
     new_size += sizeof(AllocAlignmentInteger);
@@ -3866,12 +3866,12 @@ void* realloc(void* old_ptr, size_t new_size) {
     // that we already know the sizeclass of old_ptr.  The benefit
     // would be small, so don't bother.
     do_free(old_ptr);
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     new_ptr = static_cast<AllocAlignmentInteger*>(new_ptr) + 1;
 #endif
     return new_ptr;
   } else {
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
     old_ptr = static_cast<AllocAlignmentInteger*>(old_ptr) + 1; // Set old_ptr back to the user pointer.
 #endif
     return old_ptr;
@@ -4043,7 +4043,7 @@ extern "C" struct mallinfo mallinfo(void) {
 
 #if defined(__GLIBC__)
 extern "C" {
-#if COMPILER(GCC) && !defined(__MACH__) && defined(HAVE___ATTRIBUTE__)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && !defined(__MACH__) && defined(HAVE___ATTRIBUTE__)
   // Potentially faster variants that use the gcc alias extension.
   // Mach-O (Darwin) does not support weak aliases, hence the __MACH__ check.
 # define ALIAS(x) __attribute__ ((weak, alias (x)))
@@ -4091,7 +4091,7 @@ void *(*__memalign_hook)(size_t, size_t, const void *) = MemalignOverride;
 
 #endif
 
-#if defined(WTF_CHANGES) && OS(DARWIN)
+#if defined(WTF_CHANGES) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
 class FreeObjectFinder {
     const RemoteMemoryReader& m_reader;
@@ -4374,7 +4374,7 @@ extern "C" {
 malloc_introspection_t jscore_fastmalloc_introspection = { &FastMallocZone::enumerate, &FastMallocZone::goodSize, &FastMallocZone::check, &FastMallocZone::print,
     &FastMallocZone::log, &FastMallocZone::forceLock, &FastMallocZone::forceUnlock, &FastMallocZone::statistics
 
-#if !defined(BUILDING_ON_TIGER) && !defined(BUILDING_ON_LEOPARD) && !OS(IPHONE_OS)
+#if !defined(BUILDING_ON_TIGER) && !defined(BUILDING_ON_LEOPARD) && !(defined WTF_OS_IPHONE_OS && WTF_OS_IPHONE_OS)
     , 0 // zone_locked will not be called on the zone unless it advertises itself as version five or higher.
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.h
index 74d4307..a2a0f1f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.h
@@ -105,7 +105,7 @@ namespace WTF {
         };
     }
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
 
     // Malloc validation is a scheme whereby a tag is attached to an
     // allocation which identifies how it was originally allocated.
@@ -196,11 +196,11 @@ using WTF::fastMallocForbid;
 using WTF::fastMallocAllow;
 #endif
 
-#if COMPILER(GCC) && OS(DARWIN)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #define WTF_PRIVATE_INLINE __private_extern__ inline __attribute__((always_inline))
-#elif COMPILER(GCC)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define WTF_PRIVATE_INLINE inline __attribute__((always_inline))
-#elif COMPILER(MSVC) || COMPILER(RVCT)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
 #define WTF_PRIVATE_INLINE __forceinline
 #else
 #define WTF_PRIVATE_INLINE inline
@@ -216,9 +216,9 @@ using WTF::fastMallocAllow;
 // new by accident.
 
 // We musn't customize the global operator new and delete for the Qt port.
-#if !PLATFORM(QT)
+#if !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma warning(push)
 #pragma warning(disable: 4290) // Disable the C++ exception specification ignored warning.
 #endif
@@ -230,7 +230,7 @@ WTF_PRIVATE_INLINE void* operator new[](size_t size) throw (std::bad_alloc) { re
 WTF_PRIVATE_INLINE void* operator new[](size_t size, const std::nothrow_t&) throw() { return fastMalloc(size); }
 WTF_PRIVATE_INLINE void operator delete[](void* p) throw() { fastFree(p); }
 WTF_PRIVATE_INLINE void operator delete[](void* p, const std::nothrow_t&) throw() { fastFree(p); }
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma warning(pop)
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashFunctions.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashFunctions.h
index 2c66a2d..df1dd34 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashFunctions.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashFunctions.h
@@ -111,12 +111,12 @@ namespace WTF {
     template<typename T> struct PtrHash {
         static unsigned hash(T key)
         {
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma warning(push)
 #pragma warning(disable: 4244) // work around what seems to be a bug in MSVC's conversion warnings
 #endif
             return IntHash<uintptr_t>::hash(reinterpret_cast<uintptr_t>(key));
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma warning(pop)
 #endif
         }
@@ -160,7 +160,7 @@ namespace WTF {
     template<> struct DefaultHash<long long> { typedef IntHash<unsigned long long> Hash; };
     template<> struct DefaultHash<unsigned long long> { typedef IntHash<unsigned long long> Hash; };
 
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     template<> struct DefaultHash<wchar_t> { typedef IntHash<wchar_t> Hash; };
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashTable.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashTable.h
index bea9daa..ccb2a16 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashTable.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/HashTable.h
@@ -257,7 +257,7 @@ namespace WTF {
 
     using std::swap;
 
-#if !COMPILER(MSVC) && !OS(QNX)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && !(defined WTF_OS_QNX && WTF_OS_QNX)
     // The Dinkumware C++ library (used by MSVC and QNX) has a swap for pairs defined.
 
     // swap pairs by component, in case of pair members that specialize swap
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ListRefPtr.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ListRefPtr.h
index 8bf6447..8c75745 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ListRefPtr.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ListRefPtr.h
@@ -48,7 +48,7 @@ namespace WTF {
     // T::ref() in RefPtr<T>'s copy constructor.  The bug is reported at:
     // https://xdabug001.ext.nokia.com/bugzilla/show_bug.cgi?id=9812.
     template <typename T> 
-#if !COMPILER(WINSCW)
+#if !(defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
     inline
 #endif
     ListRefPtr<T>::~ListRefPtr()
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/MathExtras.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/MathExtras.h
index a18949e..3d7c8bb 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/MathExtras.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/MathExtras.h
@@ -30,17 +30,17 @@
 #include <math.h>
 #include <stdlib.h>
 
-#if OS(SOLARIS)
+#if (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)
 #include <ieeefp.h>
 #endif
 
-#if OS(OPENBSD)
+#if (defined WTF_OS_OPENBSD && WTF_OS_OPENBSD)
 #include <sys/types.h>
 #include <machine/ieee.h>
 #endif
 
-#if COMPILER(MSVC)
-#if OS(WINCE)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 #include <stdlib.h>
 #endif
 #include <limits>
@@ -62,7 +62,7 @@ const double piOverFourDouble = M_PI_4;
 const float piOverFourFloat = static_cast<float>(M_PI_4);
 #endif
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
 // Work around a bug in the Mac OS X libc where ceil(-0.1) return +0.
 inline double wtf_ceil(double x) { return copysign(ceil(x), x); }
@@ -71,7 +71,7 @@ inline double wtf_ceil(double x) { return copysign(ceil(x), x); }
 
 #endif
 
-#if OS(SOLARIS)
+#if (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)
 
 #ifndef isfinite
 inline bool isfinite(double x) { return finite(x) && !isnand(x); }
@@ -85,7 +85,7 @@ inline bool signbit(double x) { return x < 0.0; } // FIXME: Wrong for negative 0
 
 #endif
 
-#if OS(OPENBSD)
+#if (defined WTF_OS_OPENBSD && WTF_OS_OPENBSD)
 
 #ifndef isfinite
 inline bool isfinite(double x) { return finite(x); }
@@ -96,7 +96,7 @@ inline bool signbit(double x) { struct ieee_double *p = (struct ieee_double *)&x
 
 #endif
 
-#if COMPILER(MSVC) || COMPILER(RVCT)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
 
 // We must not do 'num + 0.5' or 'num - 0.5' because they can cause precision loss.
 static double round(double num)
@@ -121,7 +121,7 @@ inline double trunc(double num) { return num > 0 ? floor(num) : ceil(num); }
 
 #endif
 
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 
 inline bool isinf(double num) { return !_finite(num) && !_isnan(num); }
 inline bool isnan(double num) { return !!_isnan(num); }
@@ -166,7 +166,7 @@ inline double wtf_pow(double x, double y) { return y == 0 ? 1 : pow(x, y); }
 #define fmod(x, y) wtf_fmod(x, y)
 #define pow(x, y) wtf_pow(x, y)
 
-#endif // COMPILER(MSVC)
+#endif // (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 
 inline double deg2rad(double d)  { return d * piDouble / 180.0; }
 inline double rad2deg(double r)  { return r * 180.0 / piDouble; }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/OwnArrayPtr.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/OwnArrayPtr.h
index 61375c7..871c083 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/OwnArrayPtr.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/OwnArrayPtr.h
@@ -46,7 +46,7 @@ namespace WTF {
         bool operator!() const { return !m_ptr; }
 
         // This conversion operator allows implicit conversion to bool but not to other integer types.
-#if COMPILER(WINSCW)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
         operator bool() const { return m_ptr; }
 #else
         typedef T* OwnArrayPtr::*UnspecifiedBoolType;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/OwnPtrCommon.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/OwnPtrCommon.h
index 6d91a54..4fde5a3 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/OwnPtrCommon.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/OwnPtrCommon.h
@@ -27,7 +27,7 @@
 #ifndef WTF_OwnPtrCommon_h
 #define WTF_OwnPtrCommon_h
 
-#if PLATFORM(WIN)
+#if (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN)
 typedef struct HBITMAP__* HBITMAP;
 typedef struct HBRUSH__* HBRUSH;
 typedef struct HDC__* HDC;
@@ -46,7 +46,7 @@ namespace WTF {
             delete ptr;
     }
 
-#if PLATFORM(WIN)
+#if (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN)
     void deleteOwnedPtr(HBITMAP);
     void deleteOwnedPtr(HBRUSH);
     void deleteOwnedPtr(HDC);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/PassRefPtr.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/PassRefPtr.h
index 36ba78e..7c3331f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/PassRefPtr.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/PassRefPtr.h
@@ -33,7 +33,7 @@ namespace WTF {
     // T::deref(), which will fail compiling when PassRefPtr<T> is used as class member 
     // or function arguments before T is defined.
     template<typename T> 
-#if !COMPILER(WINSCW)
+#if !(defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
     inline 
 #endif
     void derefIfNotNull(T* ptr)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Platform.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Platform.h
index 17c06bf..34b3901 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Platform.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Platform.h
@@ -57,8 +57,8 @@
 
 /* ==== COMPILER() - the compiler being used to build the project ==== */
 
-/* COMPILER(MSVC) Microsoft Visual C++ */
-/* COMPILER(MSVC7) Microsoft Visual C++ v7 or lower*/
+/* (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) Microsoft Visual C++ */
+/* (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7) Microsoft Visual C++ v7 or lower*/
 #if defined(_MSC_VER)
 #define WTF_COMPILER_MSVC 1
 #if _MSC_VER < 1400
@@ -66,20 +66,20 @@
 #endif
 #endif
 
-/* COMPILER(RVCT)  - ARM RealView Compilation Tools */
+/* (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)  - ARM RealView Compilation Tools */
 #if defined(__CC_ARM) || defined(__ARMCC__)
 #define WTF_COMPILER_RVCT 1
 #endif
 
-/* COMPILER(GCC) - GNU Compiler Collection */
+/* (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) - GNU Compiler Collection */
 /* --gnu option of the RVCT compiler also defines __GNUC__ */
-#if defined(__GNUC__) && !COMPILER(RVCT)
+#if defined(__GNUC__) && !(defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
 #define WTF_COMPILER_GCC 1
 #define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
 #endif
 
-/* COMPILER(MINGW) - MinGW GCC */
-/* COMPILER(MINGW64) - mingw-w64 GCC - only used as additional check to exclude mingw.org specific functions */
+/* (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW) - MinGW GCC */
+/* (defined WTF_COMPILER_MINGW64 && WTF_COMPILER_MINGW64) - mingw-w64 GCC - only used as additional check to exclude mingw.org specific functions */
 #if defined(__MINGW32__)
 #define WTF_COMPILER_MINGW 1
 #include <_mingw.h> /* private MinGW header */
@@ -88,27 +88,27 @@
     #endif /* __MINGW64_VERSION_MAJOR */
 #endif /* __MINGW32__ */
 
-/* COMPILER(SUNCC) - Sun CC compiler, also known as Sun Studio or Sun Pro */
+/* (defined WTF_COMPILER_SUNCC && WTF_COMPILER_SUNCC) - Sun CC compiler, also known as Sun Studio or Sun Pro */
 #if defined(__SUNPRO_CC) || defined(__SUNPRO_C)
 #define WTF_COMPILER_SUNCC 1
 #endif
 
-/* COMPILER(WINSCW) - CodeWarrior for Symbian emulator */
+/* (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW) - CodeWarrior for Symbian emulator */
 #if defined(__WINSCW__)
 #define WTF_COMPILER_WINSCW 1
 #endif
 
-/* COMPILER(INTEL) - Intel C++ Compiler */
+/* (defined WTF_COMPILER_INTEL && WTF_COMPILER_INTEL) - Intel C++ Compiler */
 #if defined(__INTEL_COMPILER)
 #define WTF_COMPILER_INTEL 1
 #endif
 
-/* COMPILER(ACC) - HP aCC */
+/* (defined WTF_COMPILER_ACC && WTF_COMPILER_ACC) - HP aCC */
 #if defined(__HP_aCC)
 #define WTF_COMPILER_ACC 1
 #endif
 
-/* COMPILER(XLC) - IBM XL */
+/* (defined WTF_COMPILER_XLC && WTF_COMPILER_XLC) - IBM XL */
 #if defined(__xlC__)
 #define WTF_COMPILER_XLC 1
 #endif
@@ -116,14 +116,14 @@
 
 /* ==== CPU() - the target CPU architecture ==== */
 
-/* This also defines CPU(BIG_ENDIAN) or CPU(MIDDLE_ENDIAN) or neither, as appropriate. */
+/* This also defines (defined WTF_CPU_BIG_ENDIAN && WTF_CPU_BIG_ENDIAN) or (defined WTF_CPU_MIDDLE_ENDIAN && WTF_CPU_MIDDLE_ENDIAN) or neither, as appropriate. */
 
-/* CPU(ALPHA) - DEC Alpha */
+/* (defined WTF_CPU_ALPHA && WTF_CPU_ALPHA) - DEC Alpha */
 #if defined(__alpha__)
 #define WTF_CPU_ALPHA 1
 #endif
 
-/* CPU(IA64) - Itanium / IA-64 */
+/* (defined WTF_CPU_IA64 && WTF_CPU_IA64) - Itanium / IA-64 */
 #if defined(__ia64__) || defined(__ia64) || defined(_M_IA64)
 #define WTF_CPU_IA64 1
 /* 32-bit mode on Itanium */
@@ -142,13 +142,13 @@
 #endif
 #endif
 
-/* CPU(HPPA) - a.k.a. PA-RISC */
+/* (defined WTF_CPU_HPPA && WTF_CPU_HPPA) - a.k.a. PA-RISC */
 #if defined(__hppa) || defined(__hppa__)
 #define WTF_CPU_HPPA 1
 #define WTF_CPU_BIG_ENDIAN 1
 #endif
 
-/* CPU(PPC) - PowerPC 32-bit */
+/* (defined WTF_CPU_PPC && WTF_CPU_PPC) - PowerPC 32-bit */
 #if   defined(__ppc__)     \
     || defined(__PPC__)     \
     || defined(__powerpc__) \
@@ -160,36 +160,36 @@
 #define WTF_CPU_BIG_ENDIAN 1
 #endif
 
-/* CPU(PPC64) - PowerPC 64-bit */
+/* (defined WTF_CPU_PPC64 && WTF_CPU_PPC64) - PowerPC 64-bit */
 #if   defined(__ppc64__) \
     || defined(__PPC64__)
 #define WTF_CPU_PPC64 1
 #define WTF_CPU_BIG_ENDIAN 1
 #endif
 
-/* CPU(SH4) - SuperH SH-4 */
+/* (defined WTF_CPU_SH4 && WTF_CPU_SH4) - SuperH SH-4 */
 #if defined(__SH4__)
 #define WTF_CPU_SH4 1
 #endif
 
-/* CPU(SPARC32) - SPARC 32-bit */
+/* (defined WTF_CPU_SPARC32 && WTF_CPU_SPARC32) - SPARC 32-bit */
 #if defined(__sparc) && !defined(__arch64__) || defined(__sparcv8)
 #define WTF_CPU_SPARC32 1
 #define WTF_CPU_BIG_ENDIAN 1
 #endif
 
-/* CPU(SPARC64) - SPARC 64-bit */
+/* (defined WTF_CPU_SPARC64 && WTF_CPU_SPARC64) - SPARC 64-bit */
 #if defined(__sparc__) && defined(__arch64__) || defined (__sparcv9)
 #define WTF_CPU_SPARC64 1
 #define WTF_CPU_BIG_ENDIAN 1
 #endif
 
-/* CPU(SPARC) - any SPARC, true for CPU(SPARC32) and CPU(SPARC64) */
-#if CPU(SPARC32) || CPU(SPARC64)
+/* (defined WTF_CPU_SPARC && WTF_CPU_SPARC) - any SPARC, true for (defined WTF_CPU_SPARC32 && WTF_CPU_SPARC32) and (defined WTF_CPU_SPARC64 && WTF_CPU_SPARC64) */
+#if (defined WTF_CPU_SPARC32 && WTF_CPU_SPARC32) || (defined WTF_CPU_SPARC64 && WTF_CPU_SPARC64)
 #define WTF_CPU_SPARC 1
 #endif
 
-/* CPU(X86) - i386 / x86 32-bit */
+/* (defined WTF_CPU_X86 && WTF_CPU_X86) - i386 / x86 32-bit */
 #if   defined(__i386__) \
     || defined(i386)     \
     || defined(_M_IX86)  \
@@ -198,7 +198,7 @@
 #define WTF_CPU_X86 1
 #endif
 
-/* CPU(X86_64) - AMD64 / Intel64 / x86_64 64-bit */
+/* (defined WTF_CPU_X86_64 && WTF_CPU_X86_64) - AMD64 / Intel64 / x86_64 64-bit */
 #if   defined(__x86_64__) \
     || defined(_M_X64)
 #define WTF_CPU_X86_64 1
@@ -209,7 +209,7 @@
 #define WTF_CPU_AIX64 1
 #endif
 
-/* CPU(ARM) - ARM, any version*/
+/* (defined WTF_CPU_ARM && WTF_CPU_ARM) - ARM, any version*/
 #if   defined(arm) \
     || defined(__arm__) \
     || defined(__MARM__)
@@ -226,7 +226,7 @@
 
 #endif
 
-#define WTF_ARM_ARCH_AT_LEAST(N) (CPU(ARM) && WTF_ARM_ARCH_VERSION >= N)
+#define WTF_ARM_ARCH_AT_LEAST(N) ((defined WTF_CPU_ARM && WTF_CPU_ARM) && WTF_ARM_ARCH_VERSION >= N)
 
 /* Set WTF_ARM_ARCH_VERSION */
 #if   defined(__ARM_ARCH_4__) \
@@ -297,7 +297,7 @@
 #endif
 
 
-/* CPU(ARMV5_OR_LOWER) - ARM instruction set v5 or earlier */
+/* (defined WTF_CPU_ARMV5_OR_LOWER && WTF_CPU_ARMV5_OR_LOWER) - ARM instruction set v5 or earlier */
 /* On ARMv5 and below the natural alignment is required. 
    And there are some other differences for v5 or earlier. */
 #if !defined(ARMV5_OR_LOWER) && !WTF_ARM_ARCH_AT_LEAST(6)
@@ -305,8 +305,8 @@
 #endif
 
 
-/* CPU(ARM_TRADITIONAL) - Thumb2 is not available, only traditional ARM (v4 or greater) */
-/* CPU(ARM_THUMB2) - Thumb2 instruction set is available */
+/* (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL) - Thumb2 is not available, only traditional ARM (v4 or greater) */
+/* (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2) - Thumb2 instruction set is available */
 /* Only one of these will be defined. */
 #if !defined(WTF_CPU_ARM_TRADITIONAL) && !defined(WTF_CPU_ARM_THUMB2)
 #  if defined(thumb2) || defined(__thumb2__) \
@@ -319,7 +319,7 @@
 #  else
 #    error "Not supported ARM architecture"
 #  endif
-#elif CPU(ARM_TRADITIONAL) && CPU(ARM_THUMB2) /* Sanity Check */
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL) && (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2) /* Sanity Check */
 #  error "Cannot use both of WTF_CPU_ARM_TRADITIONAL and WTF_CPU_ARM_THUMB2 platforms"
 #endif /* !defined(WTF_CPU_ARM_TRADITIONAL) && !defined(WTF_CPU_ARM_THUMB2) */
 
@@ -330,17 +330,17 @@
 /* ==== OS() - underlying operating system; only to be used for mandated low-level services like 
    virtual memory, not to choose a GUI toolkit ==== */
 
-/* OS(ANDROID) - Android */
+/* (defined WTF_OS_ANDROID && WTF_OS_ANDROID) - Android */
 #ifdef ANDROID
 #define WTF_OS_ANDROID 1
 #endif
 
-/* OS(AIX) - AIX */
+/* (defined WTF_OS_AIX && WTF_OS_AIX) - AIX */
 #ifdef _AIX
 #define WTF_OS_AIX 1
 #endif
 
-/* OS(DARWIN) - Any Darwin-based OS, including Mac OS X and iPhone OS */
+/* (defined WTF_OS_DARWIN && WTF_OS_DARWIN) - Any Darwin-based OS, including Mac OS X and iPhone OS */
 #ifdef __APPLE__
 #define WTF_OS_DARWIN 1
 
@@ -364,27 +364,27 @@
 
 #endif
 
-/* OS(IPHONE_OS) - iPhone OS */
-/* OS(MAC_OS_X) - Mac OS X (not including iPhone OS) */
-#if OS(DARWIN) && ((defined(TARGET_OS_EMBEDDED) && TARGET_OS_EMBEDDED)  \
+/* (defined WTF_OS_IPHONE_OS && WTF_OS_IPHONE_OS) - iPhone OS */
+/* (defined WTF_OS_MAC_OS_X && WTF_OS_MAC_OS_X) - Mac OS X (not including iPhone OS) */
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN) && ((defined(TARGET_OS_EMBEDDED) && TARGET_OS_EMBEDDED)  \
     || (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)                   \
     || (defined(TARGET_IPHONE_SIMULATOR) && TARGET_IPHONE_SIMULATOR))
 #define WTF_OS_IPHONE_OS 1
-#elif OS(DARWIN) && defined(TARGET_OS_MAC) && TARGET_OS_MAC
+#elif (defined WTF_OS_DARWIN && WTF_OS_DARWIN) && defined(TARGET_OS_MAC) && TARGET_OS_MAC
 #define WTF_OS_MAC_OS_X 1
 #endif
 
-/* OS(FREEBSD) - FreeBSD */
+/* (defined WTF_OS_FREEBSD && WTF_OS_FREEBSD) - FreeBSD */
 #ifdef __FreeBSD__
 #define WTF_OS_FREEBSD 1
 #endif
 
-/* OS(HAIKU) - Haiku */
+/* (defined WTF_OS_HAIKU && WTF_OS_HAIKU) - Haiku */
 #ifdef __HAIKU__
 #define WTF_OS_HAIKU 1
 #endif
 
-/* OS(HPUX) - HP-UX */
+/* (defined WTF_OS_HPUX && WTF_OS_HPUX) - HP-UX */
 #if defined(hpux) || defined(__hpux)
 #define WTF_OS_HPUX 1
 #ifndef MAP_ANON
@@ -392,42 +392,42 @@
 #endif
 #endif
 
-/* OS(LINUX) - Linux */
+/* (defined WTF_OS_LINUX && WTF_OS_LINUX) - Linux */
 #ifdef __linux__
 #define WTF_OS_LINUX 1
 #endif
 
-/* OS(NETBSD) - NetBSD */
+/* (defined WTF_OS_NETBSD && WTF_OS_NETBSD) - NetBSD */
 #if defined(__NetBSD__)
 #define WTF_PLATFORM_NETBSD 1
 #endif
 
-/* OS(OPENBSD) - OpenBSD */
+/* (defined WTF_OS_OPENBSD && WTF_OS_OPENBSD) - OpenBSD */
 #ifdef __OpenBSD__
 #define WTF_OS_OPENBSD 1
 #endif
 
-/* OS(QNX) - QNX */
+/* (defined WTF_OS_QNX && WTF_OS_QNX) - QNX */
 #if defined(__QNXNTO__)
 #define WTF_OS_QNX 1
 #endif
 
-/* OS(SOLARIS) - Solaris */
+/* (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS) - Solaris */
 #if defined(sun) || defined(__sun)
 #define WTF_OS_SOLARIS 1
 #endif
 
-/* OS(WINCE) - Windows CE; note that for this platform OS(WINDOWS) is also defined */
+/* (defined WTF_OS_WINCE && WTF_OS_WINCE) - Windows CE; note that for this platform (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) is also defined */
 #if defined(_WIN32_WCE)
 #define WTF_OS_WINCE 1
 #endif
 
-/* OS(WINDOWS) - Any version of Windows */
+/* (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) - Any version of Windows */
 #if defined(WIN32) || defined(_WIN32)
 #define WTF_OS_WINDOWS 1
 #endif
 
-/* OS(SYMBIAN) - Symbian */
+/* (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN) - Symbian */
 #if defined (__SYMBIAN32__)
 /* we are cross-compiling, it is not really windows */
 #undef WTF_OS_WINDOWS
@@ -435,19 +435,19 @@
 #define WTF_OS_SYMBIAN 1
 #endif
 
-/* OS(UNIX) - Any Unix-like system */
-#if   OS(AIX)              \
-    || OS(ANDROID)          \
-    || OS(DARWIN)           \
-    || OS(FREEBSD)          \
-    || OS(HAIKU)            \
-    || OS(HPUX)             \
-    || OS(LINUX)            \
-    || OS(NETBSD)           \
-    || OS(OPENBSD)          \
-    || OS(QNX)              \
-    || OS(SOLARIS)          \
-    || OS(SYMBIAN)          \
+/* (defined WTF_OS_UNIX && WTF_OS_UNIX) - Any Unix-like system */
+#if   (defined WTF_OS_AIX && WTF_OS_AIX)              \
+    || (defined WTF_OS_ANDROID && WTF_OS_ANDROID)          \
+    || (defined WTF_OS_DARWIN && WTF_OS_DARWIN)           \
+    || (defined WTF_OS_FREEBSD && WTF_OS_FREEBSD)          \
+    || (defined WTF_OS_HAIKU && WTF_OS_HAIKU)            \
+    || (defined WTF_OS_HPUX && WTF_OS_HPUX)             \
+    || (defined WTF_OS_LINUX && WTF_OS_LINUX)            \
+    || (defined WTF_OS_NETBSD && WTF_OS_NETBSD)           \
+    || (defined WTF_OS_OPENBSD && WTF_OS_OPENBSD)          \
+    || (defined WTF_OS_QNX && WTF_OS_QNX)              \
+    || (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)          \
+    || (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)          \
     || defined(unix)        \
     || defined(__unix)      \
     || defined(__unix__)
@@ -457,13 +457,13 @@
 /* Operating environments */
 
 /* FIXME: these are all mixes of OS, operating environment and policy choices. */
-/* PLATFORM(CHROMIUM) */
-/* PLATFORM(QT) */
-/* PLATFORM(WX) */
-/* PLATFORM(GTK) */
-/* PLATFORM(HAIKU) */
-/* PLATFORM(MAC) */
-/* PLATFORM(WIN) */
+/* (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM) */
+/* (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) */
+/* (defined WTF_PLATFORM_WX && WTF_PLATFORM_WX) */
+/* (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK) */
+/* (defined WTF_PLATFORM_HAIKU && WTF_PLATFORM_HAIKU) */
+/* (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) */
+/* (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN) */
 #if defined(BUILDING_CHROMIUM__)
 #define WTF_PLATFORM_CHROMIUM 1
 #elif defined(BUILDING_QT__)
@@ -474,19 +474,19 @@
 #define WTF_PLATFORM_GTK 1
 #elif defined(BUILDING_HAIKU__)
 #define WTF_PLATFORM_HAIKU 1
-#elif OS(DARWIN)
+#elif (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #define WTF_PLATFORM_MAC 1
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #define WTF_PLATFORM_WIN 1
 #endif
 
-/* PLATFORM(IPHONE) */
+/* (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE) */
 /* FIXME: this is sometimes used as an OS switch and sometimes for higher-level things */
 #if (defined(TARGET_OS_EMBEDDED) && TARGET_OS_EMBEDDED) || (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)
 #define WTF_PLATFORM_IPHONE 1
 #endif
 
-/* PLATFORM(IPHONE_SIMULATOR) */
+/* (defined WTF_PLATFORM_IPHONE_SIMULATOR && WTF_PLATFORM_IPHONE_SIMULATOR) */
 #if defined(TARGET_IPHONE_SIMULATOR) && TARGET_IPHONE_SIMULATOR
 #define WTF_PLATFORM_IPHONE 1
 #define WTF_PLATFORM_IPHONE_SIMULATOR 1
@@ -498,7 +498,7 @@
 #define WTF_PLATFORM_IPHONE 0
 #endif
 
-/* PLATFORM(ANDROID) */
+/* (defined WTF_PLATFORM_ANDROID && WTF_PLATFORM_ANDROID) */
 /* FIXME: this is sometimes used as an OS() switch, and other times to drive
    policy choices */
 #if defined(ANDROID)
@@ -507,18 +507,18 @@
 
 /* Graphics engines */
 
-/* PLATFORM(CG) and PLATFORM(CI) */
-#if PLATFORM(MAC) || PLATFORM(IPHONE)
+/* (defined WTF_PLATFORM_CG && WTF_PLATFORM_CG) and (defined WTF_PLATFORM_CI && WTF_PLATFORM_CI) */
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) || (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
 #define WTF_PLATFORM_CG 1
 #endif
-#if PLATFORM(MAC) && !PLATFORM(IPHONE)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) && !(defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
 #define WTF_PLATFORM_CI 1
 #endif
 
-/* PLATFORM(SKIA) for Win/Linux, CG/CI for Mac */
-#if PLATFORM(CHROMIUM)
+/* (defined WTF_PLATFORM_SKIA && WTF_PLATFORM_SKIA) for Win/Linux, CG/CI for Mac */
+#if (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM)
 #define ENABLE_HISTORY_ALWAYS_ASYNC 1
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #define WTF_PLATFORM_CG 1
 #define WTF_PLATFORM_CI 1
 #define WTF_USE_ATSUI 1
@@ -528,17 +528,17 @@
 #endif
 #endif
 
-#if PLATFORM(GTK)
+#if (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK)
 #define WTF_PLATFORM_CAIRO 1
 #endif
 
 
-/* OS(WINCE) && PLATFORM(QT)
+/* (defined WTF_OS_WINCE && WTF_OS_WINCE) && (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
    We can not determine the endianess at compile time. For
    Qt for Windows CE the endianess is specified in the
    device specific makespec
 */
-#if OS(WINCE) && PLATFORM(QT)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE) && (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #   include <QtGlobal>
 #   undef WTF_CPU_BIG_ENDIAN
 #   undef WTF_CPU_MIDDLE_ENDIAN
@@ -549,16 +549,16 @@
 #   include <ce_time.h>
 #endif
 
-#if (PLATFORM(IPHONE) || PLATFORM(MAC) || PLATFORM(WIN) || (PLATFORM(QT) && OS(DARWIN) && !ENABLE(SINGLE_THREADED))) && !defined(ENABLE_JSC_MULTIPLE_THREADS)
+#if ((defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE) || (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) || (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN) || ((defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN) && !(defined ENABLE_SINGLE_THREADED && ENABLE_SINGLE_THREADED))) && !defined(ENABLE_JSC_MULTIPLE_THREADS)
 #define ENABLE_JSC_MULTIPLE_THREADS 1
 #endif
 
 /* On Windows, use QueryPerformanceCounter by default */
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #define WTF_USE_QUERY_PERFORMANCE_COUNTER  1
 #endif
 
-#if OS(WINCE) && !PLATFORM(QT)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #undef ENABLE_JSC_MULTIPLE_THREADS
 #define ENABLE_JSC_MULTIPLE_THREADS        0
 #define USE_SYSTEM_MALLOC                  0
@@ -583,23 +583,23 @@
 #define _countof(x) (sizeof(x) / sizeof((x)[0]))
 #endif
 
-#endif  /* OS(WINCE) && !PLATFORM(QT) */
+#endif  /* (defined WTF_OS_WINCE && WTF_OS_WINCE) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) */
 
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #define WTF_USE_QT4_UNICODE 1
-#elif OS(WINCE)
+#elif (defined WTF_OS_WINCE && WTF_OS_WINCE)
 #define WTF_USE_WINCE_UNICODE 1
-#elif PLATFORM(GTK)
+#elif (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK)
 /* The GTK+ Unicode backend is configurable */
 #else
 #define WTF_USE_ICU_UNICODE 1
 #endif
 
-#if PLATFORM(MAC) && !PLATFORM(IPHONE)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) && !(defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
 #define WTF_PLATFORM_CF 1
 #define WTF_USE_PTHREADS 1
 #define HAVE_PTHREAD_RWLOCK 1
-#if !defined(BUILDING_ON_LEOPARD) && !defined(BUILDING_ON_TIGER) && CPU(X86_64)
+#if !defined(BUILDING_ON_LEOPARD) && !defined(BUILDING_ON_TIGER) && (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 #define WTF_USE_PLUGIN_HOST_PROCESS 1
 #endif
 #if !defined(ENABLE_MAC_JAVA_BRIDGE)
@@ -610,19 +610,19 @@
 #endif
 #define HAVE_READLINE 1
 #define HAVE_RUNLOOP_TIMER 1
-#endif /* PLATFORM(MAC) && !PLATFORM(IPHONE) */
+#endif /* (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) && !(defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE) */
 
-#if PLATFORM(CHROMIUM) && OS(DARWIN)
+#if (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #define WTF_PLATFORM_CF 1
 #define WTF_USE_PTHREADS 1
 #define HAVE_PTHREAD_RWLOCK 1
 #endif
 
-#if PLATFORM(QT) && OS(DARWIN)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #define WTF_PLATFORM_CF 1
 #endif
 
-#if PLATFORM(IPHONE)
+#if (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
 #define ENABLE_CONTEXT_MENUS 0
 #define ENABLE_DRAG_SUPPORT 0
 #define ENABLE_FTPDIR 1
@@ -637,12 +637,12 @@
 #define WTF_PLATFORM_CF 1
 #endif
 
-#if OS(IPHONE_OS) && !PLATFORM(QT)
+#if (defined WTF_OS_IPHONE_OS && WTF_OS_IPHONE_OS) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #define WTF_USE_PTHREADS 1
 #define HAVE_PTHREAD_RWLOCK 1
 #endif
 
-#if PLATFORM(ANDROID)
+#if (defined WTF_PLATFORM_ANDROID && WTF_PLATFORM_ANDROID)
 #define WTF_USE_PTHREADS 1
 #define WTF_PLATFORM_SGL 1
 #define USE_SYSTEM_MALLOC 1
@@ -654,25 +654,25 @@
 #define ENABLE_JAVASCRIPT_DEBUGGER 0
 #endif
 
-#if PLATFORM(WIN)
+#if (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN)
 #define WTF_USE_WININET 1
 #endif
 
-#if PLATFORM(WX)
+#if (defined WTF_PLATFORM_WX && WTF_PLATFORM_WX)
 #define ENABLE_ASSEMBLER 1
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #define WTF_PLATFORM_CF 1
 #endif
 #endif
 
-#if PLATFORM(GTK)
-#if HAVE(PTHREAD_H)
+#if (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK)
+#if (defined HAVE_PTHREAD_H && HAVE_PTHREAD_H)
 #define WTF_USE_PTHREADS 1
 #define HAVE_PTHREAD_RWLOCK 1
 #endif
 #endif
 
-#if PLATFORM(HAIKU)
+#if (defined WTF_PLATFORM_HAIKU && WTF_PLATFORM_HAIKU)
 #define HAVE_POSIX_MEMALIGN 1
 #define WTF_USE_CURL 1
 #define WTF_USE_PTHREADS 1
@@ -682,24 +682,24 @@
 #endif
 
 #if !defined(HAVE_ACCESSIBILITY)
-#if PLATFORM(IPHONE) || PLATFORM(MAC) || PLATFORM(WIN) || PLATFORM(GTK) || PLATFORM(CHROMIUM)
+#if (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE) || (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) || (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN) || (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK) || (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM)
 #define HAVE_ACCESSIBILITY 1
 #endif
 #endif /* !defined(HAVE_ACCESSIBILITY) */
 
-#if OS(UNIX) && !OS(SYMBIAN)
+#if (defined WTF_OS_UNIX && WTF_OS_UNIX) && !(defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 #define HAVE_SIGNAL_H 1
 #endif
 
-#if !OS(WINDOWS) && !OS(SOLARIS) && !OS(QNX) \
-    && !OS(SYMBIAN) && !OS(HAIKU) && !OS(RVCT) \
-    && !OS(ANDROID) && !OS(AIX) && !OS(HPUX)
+#if !(defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && !(defined WTF_OS_SOLARIS && WTF_OS_SOLARIS) && !(defined WTF_OS_QNX && WTF_OS_QNX) \
+    && !(defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN) && !(defined WTF_OS_HAIKU && WTF_OS_HAIKU) && !(defined WTF_OS_RVCT && WTF_OS_RVCT) \
+    && !(defined WTF_OS_ANDROID && WTF_OS_ANDROID) && !(defined WTF_OS_AIX && WTF_OS_AIX) && !(defined WTF_OS_HPUX && WTF_OS_HPUX)
 #define HAVE_TM_GMTOFF 1
 #define HAVE_TM_ZONE 1
 #define HAVE_TIMEGM 1
 #endif
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
 #define HAVE_ERRNO_H 1
 #define HAVE_LANGINFO_H 1
@@ -715,7 +715,7 @@
 
 #define HAVE_DISPATCH_H 1
 
-#if !PLATFORM(IPHONE)
+#if !(defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
 #define HAVE_MADV_FREE_REUSE 1
 #define HAVE_MADV_FREE 1
 #define HAVE_PTHREAD_SETNAME_NP 1
@@ -723,20 +723,20 @@
 
 #endif
 
-#if PLATFORM(IPHONE)
+#if (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
 #define HAVE_MADV_FREE 1
 #endif
 
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 #define HAVE_ERRNO_H 0
 #else
 #define HAVE_SYS_TIMEB_H 1
 #endif
 #define HAVE_VIRTUALALLOC 1
 
-#elif OS(SYMBIAN)
+#elif (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 
 #define HAVE_ERRNO_H 1
 #define HAVE_MMAP 0
@@ -745,11 +745,11 @@
 #define HAVE_SYS_TIME_H 1
 #define HAVE_STRINGS_H 1
 
-#if !COMPILER(RVCT)
+#if !(defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
 #define HAVE_SYS_PARAM_H 1
 #endif
 
-#elif OS(QNX)
+#elif (defined WTF_OS_QNX && WTF_OS_QNX)
 
 #define HAVE_ERRNO_H 1
 #define HAVE_MMAP 1
@@ -758,7 +758,7 @@
 #define HAVE_SYS_PARAM_H 1
 #define HAVE_SYS_TIME_H 1
 
-#elif OS(ANDROID)
+#elif (defined WTF_OS_ANDROID && WTF_OS_ANDROID)
 
 #define HAVE_ERRNO_H 1
 #define HAVE_LANGINFO_H 0
@@ -774,7 +774,7 @@
 
 #define HAVE_ERRNO_H 1
 /* As long as Haiku doesn't have a complete support of locale this will be disabled. */
-#if !OS(HAIKU)
+#if !(defined WTF_OS_HAIKU && WTF_OS_HAIKU)
 #define HAVE_LANGINFO_H 1
 #endif
 #define HAVE_MMAP 1
@@ -849,10 +849,10 @@
 #define ENABLE_SAMPLING_FLAGS 0
 #define ENABLE_OPCODE_SAMPLING 0
 #define ENABLE_CODEBLOCK_SAMPLING 0
-#if ENABLE(CODEBLOCK_SAMPLING) && !ENABLE(OPCODE_SAMPLING)
+#if (defined ENABLE_CODEBLOCK_SAMPLING && ENABLE_CODEBLOCK_SAMPLING) && !(defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING)
 #error "CODEBLOCK_SAMPLING requires OPCODE_SAMPLING"
 #endif
-#if ENABLE(OPCODE_SAMPLING) || ENABLE(SAMPLING_FLAGS)
+#if (defined ENABLE_OPCODE_SAMPLING && ENABLE_OPCODE_SAMPLING) || (defined ENABLE_SAMPLING_FLAGS && SAMPLING_FLAGS)
 #define ENABLE_SAMPLING_THREAD 1
 #endif
 
@@ -873,11 +873,11 @@
 #endif
 
 #if !defined(WTF_USE_JSVALUE64) && !defined(WTF_USE_JSVALUE32) && !defined(WTF_USE_JSVALUE32_64)
-#if (CPU(X86_64) && (OS(UNIX) || OS(WINDOWS) || OS(SOLARIS) || OS(HPUX))) || (CPU(IA64) && !CPU(IA64_32)) || CPU(ALPHA) || CPU(AIX64) || CPU(SPARC64)
+#if ((defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && ((defined WTF_OS_UNIX && WTF_OS_UNIX) || (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) || (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS) || (defined WTF_OS_HPUX && WTF_OS_HPUX))) || ((defined WTF_CPU_IA64 && WTF_CPU_IA64) && !(defined WTF_CPU_IA64_32 && WTF_CPU_IA64_32)) || (defined WTF_CPU_ALPHA && WTF_CPU_ALPHA) || (defined WTF_CPU_AIX64 && WTF_CPU_AIX64) || (defined WTF_CPU_SPARC64 && WTF_CPU_SPARC64)
 #define WTF_USE_JSVALUE64 1
-#elif CPU(ARM) || CPU(PPC64)
+#elif (defined WTF_CPU_ARM && WTF_CPU_ARM) || (defined WTF_CPU_PPC64 && WTF_CPU_PPC64)
 #define WTF_USE_JSVALUE32 1
-#elif OS(WINDOWS) && COMPILER(MINGW)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW)
 /* Using JSVALUE32_64 causes padding/alignement issues for JITStubArg
 on MinGW. See https://bugs.webkit.org/show_bug.cgi?id=29268 */
 #define WTF_USE_JSVALUE32 1
@@ -893,44 +893,44 @@ on MinGW. See https://bugs.webkit.org/show_bug.cgi?id=29268 */
 #if !defined(ENABLE_JIT)
 
 /* The JIT is tested & working on x86_64 Mac */
-#if CPU(X86_64) && PLATFORM(MAC)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
     #define ENABLE_JIT 1
 /* The JIT is tested & working on x86 Mac */
-#elif CPU(X86) && PLATFORM(MAC)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_VA_LIST 1
-#elif CPU(ARM_THUMB2) && PLATFORM(IPHONE)
+#elif (defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2) && (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
     #define ENABLE_JIT 1
 /* The JIT is tested & working on x86 Windows */
-#elif CPU(X86) && PLATFORM(WIN)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN)
     #define ENABLE_JIT 1
 #endif
 
-#if PLATFORM(QT)
-#if CPU(X86_64) && OS(DARWIN)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     #define ENABLE_JIT 1
-#elif CPU(X86) && OS(DARWIN)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_VA_LIST 1
-#elif CPU(X86) && OS(WINDOWS) && COMPILER(MINGW) && GCC_VERSION >= 40100
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW) && GCC_VERSION >= 40100
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_VA_LIST 1
-#elif CPU(X86) && OS(WINDOWS) && COMPILER(MSVC)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_REGISTER 1
-#elif CPU(X86) && OS(LINUX) && GCC_VERSION >= 40100
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_OS_LINUX && WTF_OS_LINUX) && GCC_VERSION >= 40100
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_VA_LIST 1
-#elif CPU(X86_64) && OS(LINUX) && GCC_VERSION >= 40100
+#elif (defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && (defined WTF_OS_LINUX && WTF_OS_LINUX) && GCC_VERSION >= 40100
     #define ENABLE_JIT 1
-#elif CPU(ARM_TRADITIONAL) && OS(LINUX)
+#elif (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL) && (defined WTF_OS_LINUX && WTF_OS_LINUX)
     #define ENABLE_JIT 1
 #endif
-#endif /* PLATFORM(QT) */
+#endif /* (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) */
 
 #endif /* !defined(ENABLE_JIT) */
 
-#if ENABLE(JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT)
 #ifndef ENABLE_JIT_OPTIMIZE_CALL
 #define ENABLE_JIT_OPTIMIZE_CALL 1
 #endif
@@ -945,19 +945,19 @@ on MinGW. See https://bugs.webkit.org/show_bug.cgi?id=29268 */
 #endif
 #endif
 
-#if CPU(X86) && COMPILER(MSVC)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #define JSC_HOST_CALL __fastcall
-#elif CPU(X86) && COMPILER(GCC)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define JSC_HOST_CALL __attribute__ ((fastcall))
 #else
 #define JSC_HOST_CALL
 #endif
 
-#if COMPILER(GCC) && !ENABLE(JIT)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && !(defined ENABLE_JIT && ENABLE_JIT)
 #define HAVE_COMPUTED_GOTO 1
 #endif
 
-#if ENABLE(JIT) && defined(COVERAGE)
+#if (defined ENABLE_JIT && ENABLE_JIT) && defined(COVERAGE)
     #define WTF_USE_INTERPRETER 0
 #else
     #define WTF_USE_INTERPRETER 1
@@ -967,21 +967,21 @@ on MinGW. See https://bugs.webkit.org/show_bug.cgi?id=29268 */
 #if !defined(ENABLE_YARR_JIT)
 
 /* YARR supports x86 & x86-64, and has been tested on Mac and Windows. */
-#if (CPU(X86) && PLATFORM(MAC)) \
-    || (CPU(X86_64) && PLATFORM(MAC)) \
-    || (CPU(ARM_THUMB2) && PLATFORM(IPHONE)) \
-    || (CPU(X86) && PLATFORM(WIN))
+#if ((defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)) \
+    || ((defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)) \
+    || ((defined WTF_CPU_ARM_THUMB2 && WTF_CPU_ARM_THUMB2) && (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)) \
+    || ((defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN))
 #define ENABLE_YARR 1
 #define ENABLE_YARR_JIT 1
 #endif
 
-#if PLATFORM(QT)
-#if (CPU(X86) && OS(WINDOWS) && COMPILER(MINGW) && GCC_VERSION >= 40100) \
-    || (CPU(X86_64) && OS(WINDOWS) && COMPILER(MINGW64) && GCC_VERSION >= 40100) \
-    || (CPU(X86) && OS(WINDOWS) && COMPILER(MSVC)) \
-    || (CPU(X86) && OS(LINUX) && GCC_VERSION >= 40100) \
-    || (CPU(X86_64) && OS(LINUX) && GCC_VERSION >= 40100) \
-    || (CPU(ARM_TRADITIONAL) && OS(LINUX))
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
+#if ((defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW) && GCC_VERSION >= 40100) \
+    || ((defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_COMPILER_MINGW64 && WTF_COMPILER_MINGW64) && GCC_VERSION >= 40100) \
+    || ((defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)) \
+    || ((defined WTF_CPU_X86 && WTF_CPU_X86) && (defined WTF_OS_LINUX && WTF_OS_LINUX) && GCC_VERSION >= 40100) \
+    || ((defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && (defined WTF_OS_LINUX && WTF_OS_LINUX) && GCC_VERSION >= 40100) \
+    || ((defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL) && (defined WTF_OS_LINUX && WTF_OS_LINUX))
 #define ENABLE_YARR 1
 #define ENABLE_YARR_JIT 1
 #endif
@@ -990,16 +990,16 @@ on MinGW. See https://bugs.webkit.org/show_bug.cgi?id=29268 */
 #endif /* !defined(ENABLE_YARR_JIT) */
 
 /* Sanity Check */
-#if ENABLE(YARR_JIT) && !ENABLE(YARR)
+#if (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT) && !(defined ENABLE_YARR && ENABLE_YARR)
 #error "YARR_JIT requires YARR"
 #endif
 
-#if ENABLE(JIT) || ENABLE(YARR_JIT)
+#if (defined ENABLE_JIT && ENABLE_JIT) || (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT)
 #define ENABLE_ASSEMBLER 1
 #endif
 /* Setting this flag prevents the assembler from using RWX memory; this may improve
    security but currectly comes at a significant performance cost. */
-#if PLATFORM(IPHONE)
+#if (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
 #define ENABLE_ASSEMBLER_WX_EXCLUSIVE 1
 #else
 #define ENABLE_ASSEMBLER_WX_EXCLUSIVE 0
@@ -1007,44 +1007,44 @@ on MinGW. See https://bugs.webkit.org/show_bug.cgi?id=29268 */
 
 /* Pick which allocator to use; we only need an executable allocator if the assembler is compiled in.
    On x86-64 we use a single fixed mmap, on other platforms we mmap on demand. */
-#if ENABLE(ASSEMBLER)
-#if CPU(X86_64) && !COMPILER(MINGW64)
+#if (defined ENABLE_ASSEMBLER && ENABLE_ASSEMBLER)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64) && !(defined WTF_COMPILER_MINGW64 && WTF_COMPILER_MINGW64)
 #define ENABLE_EXECUTABLE_ALLOCATOR_FIXED 1
 #else
 #define ENABLE_EXECUTABLE_ALLOCATOR_DEMAND 1
 #endif
 #endif
 
-#if !defined(ENABLE_PAN_SCROLLING) && OS(WINDOWS)
+#if !defined(ENABLE_PAN_SCROLLING) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #define ENABLE_PAN_SCROLLING 1
 #endif
 
 /* Use the QXmlStreamReader implementation for XMLTokenizer */
 /* Use the QXmlQuery implementation for XSLTProcessor */
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #define WTF_USE_QXMLSTREAM 1
 #define WTF_USE_QXMLQUERY 1
 #endif
 
-#if !PLATFORM(QT)
+#if !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #define WTF_USE_FONT_FAST_PATH 1
 #endif
 
 /* Accelerated compositing */
-#if PLATFORM(MAC)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC)
 #if !defined(BUILDING_ON_TIGER)
 #define WTF_USE_ACCELERATED_COMPOSITING 1
 #endif
 #endif
 
-#if PLATFORM(IPHONE)
+#if (defined WTF_PLATFORM_IPHONE && WTF_PLATFORM_IPHONE)
 #define WTF_USE_ACCELERATED_COMPOSITING 1
 #endif
 
 /* FIXME: Defining ENABLE_3D_RENDERING here isn't really right, but it's always used with
    with WTF_USE_ACCELERATED_COMPOSITING, and it allows the feature to be turned on and
    off in one place. */
-#if PLATFORM(WIN)
+#if (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN)
 #include "QuartzCorePresent.h"
 #if QUARTZCORE_PRESENT
 #define WTF_USE_ACCELERATED_COMPOSITING 1
@@ -1052,13 +1052,13 @@ on MinGW. See https://bugs.webkit.org/show_bug.cgi?id=29268 */
 #endif
 #endif
 
-#if COMPILER(GCC)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
 #define WARN_UNUSED_RETURN __attribute__ ((warn_unused_result))
 #else
 #define WARN_UNUSED_RETURN
 #endif
 
-#if !ENABLE(NETSCAPE_PLUGIN_API) || (ENABLE(NETSCAPE_PLUGIN_API) && ((OS(UNIX) && (PLATFORM(QT) || PLATFORM(WX))) || PLATFORM(GTK)))
+#if !(defined ENABLE_NETSCAPE_PLUGIN_API && ENABLE_NETSCAPE_PLUGIN_API) || ((defined ENABLE_NETSCAPE_PLUGIN_API && ENABLE_NETSCAPE_PLUGIN_API) && (((defined WTF_OS_UNIX && WTF_OS_UNIX) && ((defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) || (defined WTF_PLATFORM_WX && WTF_PLATFORM_WX))) || (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK)))
 #define ENABLE_PLUGIN_PACKAGE_SIMPLE_HASH 1
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RandomNumber.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RandomNumber.cpp
index 74bb45c..c97e6d2 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RandomNumber.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RandomNumber.cpp
@@ -34,7 +34,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 extern "C" {
 #include "wince/mt19937ar.c"
 }
@@ -44,7 +44,7 @@ namespace WTF {
 
 double weakRandomNumber()
 {
-#if COMPILER(MSVC) && defined(_CRT_RAND_S)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && defined(_CRT_RAND_S)
     // rand_s is incredibly slow on windows so we fall back on rand for Math.random
     return (rand() + (rand() / (RAND_MAX + 1.0))) / (RAND_MAX + 1.0);
 #else
@@ -54,7 +54,7 @@ double weakRandomNumber()
 
 double randomNumber()
 {
-#if !ENABLE(JSC_MULTIPLE_THREADS)
+#if !(defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     static bool s_initialized = false;
     if (!s_initialized) {
         initializeRandomNumberGenerator();
@@ -62,14 +62,14 @@ double randomNumber()
     }
 #endif
     
-#if COMPILER(MSVC) && defined(_CRT_RAND_S)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && defined(_CRT_RAND_S)
     uint32_t bits;
     rand_s(&bits);
     return static_cast<double>(bits) / (static_cast<double>(std::numeric_limits<uint32_t>::max()) + 1.0);
-#elif OS(DARWIN)
+#elif (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     uint32_t bits = arc4random();
     return static_cast<double>(bits) / (static_cast<double>(std::numeric_limits<uint32_t>::max()) + 1.0);
-#elif OS(UNIX)
+#elif (defined WTF_OS_UNIX && WTF_OS_UNIX)
     uint32_t part1 = random() & (RAND_MAX - 1);
     uint32_t part2 = random() & (RAND_MAX - 1);
     // random only provides 31 bits
@@ -80,9 +80,9 @@ double randomNumber()
     // Mask off the low 53bits
     fullRandom &= (1LL << 53) - 1;
     return static_cast<double>(fullRandom)/static_cast<double>(1LL << 53);
-#elif OS(WINCE)
+#elif (defined WTF_OS_WINCE && WTF_OS_WINCE)
     return genrand_res53();
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     uint32_t part1 = rand() & (RAND_MAX - 1);
     uint32_t part2 = rand() & (RAND_MAX - 1);
     uint32_t part3 = rand() & (RAND_MAX - 1);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RandomNumberSeed.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RandomNumberSeed.h
index ae414c0..c141a2b 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RandomNumberSeed.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RandomNumberSeed.h
@@ -29,16 +29,16 @@
 #include <stdlib.h>
 #include <time.h>
 
-#if HAVE(SYS_TIME_H)
+#if (defined HAVE_SYS_TIME_H && HAVE_SYS_TIME_H)
 #include <sys/time.h>
 #endif
 
-#if OS(UNIX)
+#if (defined WTF_OS_UNIX && WTF_OS_UNIX)
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 extern "C" {
 void init_by_array(unsigned long init_key[],int key_length);
 }
@@ -49,9 +49,9 @@ namespace WTF {
 
 inline void initializeRandomNumberGenerator()
 {
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
     // On Darwin we use arc4random which initialises itself.
-#elif OS(WINCE)
+#elif (defined WTF_OS_WINCE && WTF_OS_WINCE)
     // initialize rand()
     srand(static_cast<unsigned>(time(0)));
 
@@ -62,9 +62,9 @@ inline void initializeRandomNumberGenerator()
     initializationBuffer[2] = (rand() << 16) | rand();
     initializationBuffer[3] = (rand() << 16) | rand();
     init_by_array(initializationBuffer, 4);
-#elif COMPILER(MSVC) && defined(_CRT_RAND_S)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && defined(_CRT_RAND_S)
     // On Windows we use rand_s which initialises itself
-#elif OS(UNIX)
+#elif (defined WTF_OS_UNIX && WTF_OS_UNIX)
     // srandomdev is not guaranteed to exist on linux so we use this poor seed, this should be improved
     timeval time;
     gettimeofday(&time, 0);
@@ -76,7 +76,7 @@ inline void initializeRandomNumberGenerator()
 
 inline void initializeWeakRandomNumberGenerator()
 {
-#if COMPILER(MSVC) && defined(_CRT_RAND_S)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) && defined(_CRT_RAND_S)
     // We need to initialise windows rand() explicitly for Math.random
     unsigned seed = 0;
     rand_s(&seed);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RefCountedLeakCounter.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RefCountedLeakCounter.cpp
index 80922d3..d485f49 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RefCountedLeakCounter.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RefCountedLeakCounter.cpp
@@ -79,7 +79,7 @@ RefCountedLeakCounter::~RefCountedLeakCounter()
 
 void RefCountedLeakCounter::increment()
 {
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     atomicIncrement(&m_count);
 #else
     ++m_count;
@@ -88,7 +88,7 @@ void RefCountedLeakCounter::increment()
 
 void RefCountedLeakCounter::decrement()
 {
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     atomicDecrement(&m_count);
 #else
     --m_count;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RefPtr.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RefPtr.h
index 198f6d3..274da04 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RefPtr.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/RefPtr.h
@@ -24,7 +24,7 @@
 #include <algorithm>
 #include "AlwaysInline.h"
 #include "FastAllocBase.h"
-#if COMPILER(WINSCW)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
 #include "PassRefPtr.h"
 #endif
 
@@ -53,7 +53,7 @@ namespace WTF {
         RefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }
         bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }
 
-#if COMPILER(WINSCW)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
         ~RefPtr() { if (T* ptr = m_ptr) derefIfNotNull<T>(ptr); }
 #else
         ~RefPtr() { if (T* ptr = m_ptr) ptr->deref(); }
@@ -63,7 +63,7 @@ namespace WTF {
         
         T* get() const { return m_ptr; }
         
-#if COMPILER(WINSCW)
+#if (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
         void clear() { if (T* ptr = m_ptr) derefIfNotNull<T>(ptr); m_ptr = 0; }
 #else
         void clear() { if (T* ptr = m_ptr) ptr->deref(); m_ptr = 0; }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StdLibExtras.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StdLibExtras.h
index b16ea72..95d7a25 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StdLibExtras.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StdLibExtras.h
@@ -33,7 +33,7 @@
 //  it is leaked so that its destructors are not called at exit. Using this
 //  macro also allows workarounds a compiler bug present in Apple's version of GCC 4.0.1.
 #ifndef DEFINE_STATIC_LOCAL
-#if COMPILER(GCC) && defined(__APPLE_CC__) && __GNUC__ == 4 && __GNUC_MINOR__ == 0 && __GNUC_PATCHLEVEL__ == 1
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && defined(__APPLE_CC__) && __GNUC__ == 4 && __GNUC_MINOR__ == 0 && __GNUC_PATCHLEVEL__ == 1
 #define DEFINE_STATIC_LOCAL(type, name, arguments) \
     static type* name##Ptr = new type arguments; \
     type& name = *name##Ptr
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.cpp
index 1b96417..faa317d 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.cpp
@@ -25,7 +25,7 @@
 
 #include "config.h"
 
-#if COMPILER(RVCT) && __ARMCC_VERSION < 400000
+#if (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT) && __ARMCC_VERSION < 400000
 
 #include "StringExtras.h"
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.h
index b1ec09f..dd703ee 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.h
@@ -29,11 +29,11 @@
 #include <stdarg.h>
 #include <stdio.h>
 
-#if HAVE(STRINGS_H) 
+#if (defined HAVE_STRINGS_H && HAVE_STRINGS_H) 
 #include <strings.h> 
 #endif 
 
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 // FIXME: why a COMPILER check instead of OS? also, these should be HAVE checks
 
 inline int snprintf(char* buffer, size_t count, const char* format, ...) 
@@ -46,7 +46,7 @@ inline int snprintf(char* buffer, size_t count, const char* format, ...)
     return result;
 }
 
-#if COMPILER(MSVC7) || OS(WINCE)
+#if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7) || (defined WTF_OS_WINCE && WTF_OS_WINCE)
 
 inline int vsnprintf(char* buffer, size_t count, const char* format, va_list args)
 {
@@ -55,7 +55,7 @@ inline int vsnprintf(char* buffer, size_t count, const char* format, va_list arg
 
 #endif
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 
 inline int strnicmp(const char* string1, const char* string2, size_t count)
 {
@@ -86,7 +86,7 @@ inline int strcasecmp(const char* s1, const char* s2)
 
 #endif
 
-#if OS(WINDOWS) || OS(LINUX) || OS(SOLARIS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) || (defined WTF_OS_LINUX && WTF_OS_LINUX) || (defined WTF_OS_SOLARIS && WTF_OS_SOLARIS)
 // FIXME: should check HAVE_STRNSTR
 
 inline char* strnstr(const char* buffer, const char* target, size_t bufferLength)
@@ -103,7 +103,7 @@ inline char* strnstr(const char* buffer, const char* target, size_t bufferLength
 
 #endif
 
-#if COMPILER(RVCT) && __ARMCC_VERSION < 400000
+#if (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT) && __ARMCC_VERSION < 400000
 
 int strcasecmp(const char* s1, const char* s2);
 int strncasecmp(const char* s1, const char* s2, size_t len);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCPageMap.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCPageMap.h
index 3f56c24..aa1285c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCPageMap.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCPageMap.h
@@ -45,9 +45,9 @@
 #ifndef TCMALLOC_PAGEMAP_H__
 #define TCMALLOC_PAGEMAP_H__
 
-#if HAVE(STDINT_H)
+#if (defined HAVE_STDINT_H && HAVE_STDINT_H)
 #include <stdint.h>
-#elif HAVE(INTTYPES_H)
+#elif (defined HAVE_INTTYPES_H && HAVE_INTTYPES_H)
 #include <inttypes.h>
 #else
 #include <sys/types.h>
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSpinLock.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSpinLock.h
index 8a73e13..c5ed0fd 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSpinLock.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSpinLock.h
@@ -33,21 +33,21 @@
 #ifndef TCMALLOC_INTERNAL_SPINLOCK_H__
 #define TCMALLOC_INTERNAL_SPINLOCK_H__
 
-#if (CPU(X86) || CPU(X86_64) || CPU(PPC)) && (COMPILER(GCC) || COMPILER(MSVC))
+#if ((defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64) || (defined WTF_CPU_PPC && WTF_CPU_PPC)) && ((defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) || (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC))
 
 #include <time.h>       /* For nanosleep() */
 
 #include <sched.h>      /* For sched_yield() */
 
-#if HAVE(STDINT_H)
+#if (defined HAVE_STDINT_H && HAVE_STDINT_H)
 #include <stdint.h>
-#elif HAVE(INTTYPES_H)
+#elif (defined HAVE_INTTYPES_H && HAVE_INTTYPES_H)
 #include <inttypes.h>
 #else
 #include <sys/types.h>
 #endif
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #ifndef WIN32_LEAN_AND_MEAN
 #define WIN32_LEAN_AND_MEAN
 #endif
@@ -61,8 +61,8 @@ struct TCMalloc_SpinLock {
 
   inline void Lock() {
     int r;
-#if COMPILER(GCC)
-#if CPU(X86) || CPU(X86_64)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     __asm__ __volatile__
       ("xchgl %0, %1"
        : "=r"(r), "=m"(lockword_)
@@ -79,7 +79,7 @@ struct TCMalloc_SpinLock {
          : "r" (1), "1" (lockword_ptr)
          : "memory");
 #endif
-#elif COMPILER(MSVC)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     __asm {
         mov eax, this    ; store &lockword_ (which is this+0) in eax
         mov ebx, 1       ; store 1 in ebx
@@ -91,8 +91,8 @@ struct TCMalloc_SpinLock {
   }
 
   inline void Unlock() {
-#if COMPILER(GCC)
-#if CPU(X86) || CPU(X86_64)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     __asm__ __volatile__
       ("movl $0, %0"
        : "=m"(lockword_)
@@ -103,7 +103,7 @@ struct TCMalloc_SpinLock {
       ("isync\n\t"
        "eieio\n\t"
        "stw %1, %0"
-#if OS(DARWIN) || CPU(PPC)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN) || (defined WTF_CPU_PPC && WTF_CPU_PPC)
        : "=o" (lockword_)
 #else
        : "=m" (lockword_) 
@@ -111,7 +111,7 @@ struct TCMalloc_SpinLock {
        : "r" (0)
        : "memory");
 #endif
-#elif COMPILER(MSVC)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
       __asm {
           mov eax, this  ; store &lockword_ (which is this+0) in eax
           mov [eax], 0   ; set lockword_ to 0
@@ -137,8 +137,8 @@ static void TCMalloc_SlowLock(volatile unsigned int* lockword) {
   sched_yield();        // Yield immediately since fast path failed
   while (true) {
     int r;
-#if COMPILER(GCC)
-#if CPU(X86) || CPU(X86_64)
+#if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     __asm__ __volatile__
       ("xchgl %0, %1"
        : "=r"(r), "=m"(*lockword)
@@ -156,7 +156,7 @@ static void TCMalloc_SlowLock(volatile unsigned int* lockword) {
          : "r" (tmp), "1" (lockword)
          : "memory");
 #endif
-#elif COMPILER(MSVC)
+#elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
     __asm {
         mov eax, lockword     ; assign lockword into eax
         mov ebx, 1            ; assign 1 into ebx
@@ -178,7 +178,7 @@ static void TCMalloc_SlowLock(volatile unsigned int* lockword) {
     // from taking 30 seconds to 16 seconds.
 
     // Sleep for a few milliseconds
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     Sleep(2);
 #else
     struct timespec tm;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.cpp
index ff2ac2b..6a5f3d6 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.cpp
@@ -40,15 +40,15 @@
 #include "UnusedParam.h"
 #include "VMTags.h"
 
-#if HAVE(STDINT_H)
+#if (defined HAVE_STDINT_H && HAVE_STDINT_H)
 #include <stdint.h>
-#elif HAVE(INTTYPES_H)
+#elif (defined HAVE_INTTYPES_H && HAVE_INTTYPES_H)
 #include <inttypes.h>
 #else
 #include <sys/types.h>
 #endif
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #include "windows.h"
 #else
 #include <errno.h>
@@ -84,15 +84,15 @@ static size_t pagesize = 0;
 static bool use_devmem = false;
 #endif
 
-#if HAVE(SBRK)
+#if (defined HAVE_SBRK && HAVE_SBRK)
 static bool use_sbrk = false;
 #endif
 
-#if HAVE(MMAP)
+#if (defined HAVE_MMAP && HAVE_MMAP)
 static bool use_mmap = true;
 #endif 
 
-#if HAVE(VIRTUALALLOC)
+#if (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
 static bool use_VirtualAlloc = true;
 #endif
 
@@ -114,7 +114,7 @@ static const int32_t FLAGS_malloc_devmem_start = 0;
 static const int32_t FLAGS_malloc_devmem_limit = 0;
 #endif
 
-#if HAVE(SBRK)
+#if (defined HAVE_SBRK && HAVE_SBRK)
 
 static void* TrySbrk(size_t size, size_t *actual_size, size_t alignment) {
   size = ((size + alignment - 1) / alignment) * alignment;
@@ -156,9 +156,9 @@ static void* TrySbrk(size_t size, size_t *actual_size, size_t alignment) {
   return reinterpret_cast<void*>(ptr);
 }
 
-#endif /* HAVE(SBRK) */
+#endif /* (defined HAVE_SBRK && HAVE_SBRK) */
 
-#if HAVE(MMAP)
+#if (defined HAVE_MMAP && HAVE_MMAP)
 
 static void* TryMmap(size_t size, size_t *actual_size, size_t alignment) {
   // Enforce page alignment
@@ -204,9 +204,9 @@ static void* TryMmap(size_t size, size_t *actual_size, size_t alignment) {
   return reinterpret_cast<void*>(ptr);
 }
 
-#endif /* HAVE(MMAP) */
+#endif /* (defined HAVE_MMAP && HAVE_MMAP) */
 
-#if HAVE(VIRTUALALLOC)
+#if (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
 
 static void* TryVirtualAlloc(size_t size, size_t *actual_size, size_t alignment) {
   // Enforce page alignment
@@ -258,7 +258,7 @@ static void* TryVirtualAlloc(size_t size, size_t *actual_size, size_t alignment)
   return reinterpret_cast<void*>(ptr);
 }
 
-#endif /* HAVE(MMAP) */
+#endif /* (defined HAVE_MMAP && HAVE_MMAP) */
 
 #ifndef WTF_CHANGES
 static void* TryDevMem(size_t size, size_t *actual_size, size_t alignment) {
@@ -358,21 +358,21 @@ void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size, size_t alignment) {
     }
 #endif
     
-#if HAVE(SBRK)
+#if (defined HAVE_SBRK && HAVE_SBRK)
     if (use_sbrk && !sbrk_failure) {
       void* result = TrySbrk(size, actual_size, alignment);
       if (result != NULL) return result;
     }
 #endif
 
-#if HAVE(MMAP)    
+#if (defined HAVE_MMAP && HAVE_MMAP)    
     if (use_mmap && !mmap_failure) {
       void* result = TryMmap(size, actual_size, alignment);
       if (result != NULL) return result;
     }
 #endif
 
-#if HAVE(VIRTUALALLOC)
+#if (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
     if (use_VirtualAlloc && !VirtualAlloc_failure) {
       void* result = TryVirtualAlloc(size, actual_size, alignment);
       if (result != NULL) return result;
@@ -388,20 +388,20 @@ void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size, size_t alignment) {
   return NULL;
 }
 
-#if HAVE(MADV_FREE_REUSE)
+#if (defined HAVE_MADV_FREE_REUSE && HAVE_MADV_FREE_REUSE)
 
 void TCMalloc_SystemRelease(void* start, size_t length)
 {
     while (madvise(start, length, MADV_FREE_REUSABLE) == -1 && errno == EAGAIN) { }
 }
 
-#elif HAVE(MADV_FREE) || HAVE(MADV_DONTNEED)
+#elif (defined HAVE_MADV_FREE && HAVE_MADV_FREE) || (defined HAVE_MADV_DONTNEED && HAVE_MADV_DONTNEED)
 
 void TCMalloc_SystemRelease(void* start, size_t length)
 {
     // MADV_FREE clears the modified bit on pages, which allows
     // them to be discarded immediately.
-#if HAVE(MADV_FREE)
+#if (defined HAVE_MADV_FREE && HAVE_MADV_FREE)
     const int advice = MADV_FREE;
 #else
     const int advice = MADV_DONTNEED;
@@ -439,7 +439,7 @@ void TCMalloc_SystemRelease(void* start, size_t length)
   }
 }
 
-#elif HAVE(MMAP)
+#elif (defined HAVE_MMAP && HAVE_MMAP)
 
 void TCMalloc_SystemRelease(void* start, size_t length)
 {
@@ -448,7 +448,7 @@ void TCMalloc_SystemRelease(void* start, size_t length)
   ASSERT_UNUSED(newAddress, newAddress == start || newAddress == reinterpret_cast<void*>(MAP_FAILED));
 }
 
-#elif HAVE(VIRTUALALLOC)
+#elif (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
 
 void TCMalloc_SystemRelease(void* start, size_t length)
 {
@@ -481,14 +481,14 @@ void TCMalloc_SystemRelease(void* start, size_t length)
 
 #endif
 
-#if HAVE(MADV_FREE_REUSE)
+#if (defined HAVE_MADV_FREE_REUSE && HAVE_MADV_FREE_REUSE)
 
 void TCMalloc_SystemCommit(void* start, size_t length)
 {
     while (madvise(start, length, MADV_FREE_REUSE) == -1 && errno == EAGAIN) { }
 }
 
-#elif HAVE(VIRTUALALLOC)
+#elif (defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
 
 void TCMalloc_SystemCommit(void* start, size_t length)
 {
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.h
index 1c67788..a271a44 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.h
@@ -64,11 +64,11 @@ extern void TCMalloc_SystemRelease(void* start, size_t length);
 
 extern void TCMalloc_SystemCommit(void* start, size_t length);
 
-#if !HAVE(MADV_FREE_REUSE) && !HAVE(MADV_DONTNEED) && !HAVE(MMAP) && !HAVE(VIRTUALALLOC)
+#if !(defined HAVE_MADV_FREE_REUSE && HAVE_MADV_FREE_REUSE) && !(defined HAVE_MADV_DONTNEED && HAVE_MADV_DONTNEED) && !(defined HAVE_MMAP && HAVE_MMAP) && !(defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC)
 inline void TCMalloc_SystemRelease(void*, size_t) { }
 #endif
 
-#if !HAVE(VIRTUALALLOC) && !HAVE(MADV_FREE_REUSE)
+#if !(defined HAVE_VIRTUALALLOC && HAVE_VIRTUALALLOC) && !(defined HAVE_MADV_FREE_REUSE && HAVE_MADV_FREE_REUSE)
 inline void TCMalloc_SystemCommit(void*, size_t) { }
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadIdentifierDataPthreads.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadIdentifierDataPthreads.cpp
index 042d49e..175cb66 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadIdentifierDataPthreads.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadIdentifierDataPthreads.cpp
@@ -30,7 +30,7 @@
 
 #include "config.h"
 
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
 
 #include "ThreadIdentifierDataPthreads.h"
 
@@ -93,5 +93,5 @@ void ThreadIdentifierData::initializeKeyOnce()
 
 } // namespace WTF
 
-#endif // USE(PTHREADS)
+#endif // (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadSpecific.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadSpecific.h
index 3f0e764..e417e07 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadSpecific.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadSpecific.h
@@ -43,17 +43,17 @@
 
 #include <wtf/Noncopyable.h>
 
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
 #include <pthread.h>
-#elif PLATFORM(QT)
+#elif (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #include <QThreadStorage>
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #include <windows.h>
 #endif
 
 namespace WTF {
 
-#if !USE(PTHREADS) && !PLATFORM(QT) && OS(WINDOWS)
+#if !(defined WTF_USE_PTHREADS && WTF_USE_PTHREADS) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 // ThreadSpecificThreadExit should be called each time when a thread is detached.
 // This is done automatically for threads created with WTF::createThread.
 void ThreadSpecificThreadExit();
@@ -68,7 +68,7 @@ public:
     ~ThreadSpecific();
 
 private:
-#if !USE(PTHREADS) && !PLATFORM(QT) && OS(WINDOWS)
+#if !(defined WTF_USE_PTHREADS && WTF_USE_PTHREADS) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     friend void ThreadSpecificThreadExit();
 #endif
     
@@ -76,35 +76,35 @@ private:
     void set(T*);
     void static destroy(void* ptr);
 
-#if USE(PTHREADS) || PLATFORM(QT) || OS(WINDOWS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS) || (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT) || (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     struct Data : Noncopyable {
         Data(T* value, ThreadSpecific<T>* owner) : value(value), owner(owner) {}
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
         ~Data() { owner->destroy(this); }
 #endif
 
         T* value;
         ThreadSpecific<T>* owner;
-#if !USE(PTHREADS) && !PLATFORM(QT)
+#if !(defined WTF_USE_PTHREADS && WTF_USE_PTHREADS) && !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
         void (*destructor)(void*);
 #endif
     };
 #endif
 
-#if ENABLE(SINGLE_THREADED)
+#if (defined ENABLE_SINGLE_THREADED && ENABLE_SINGLE_THREADED)
     T* m_value;
 #else
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
     pthread_key_t m_key;
-#elif PLATFORM(QT)
+#elif (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
     QThreadStorage<Data*> m_key;
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     int m_index;
 #endif
 #endif
 };
 
-#if ENABLE(SINGLE_THREADED)
+#if (defined ENABLE_SINGLE_THREADED && ENABLE_SINGLE_THREADED)
 template<typename T>
 inline ThreadSpecific<T>::ThreadSpecific()
     : m_value(0)
@@ -129,7 +129,7 @@ inline void ThreadSpecific<T>::set(T* ptr)
     m_value = ptr;
 }
 #else
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
 template<typename T>
 inline ThreadSpecific<T>::ThreadSpecific()
 {
@@ -158,7 +158,7 @@ inline void ThreadSpecific<T>::set(T* ptr)
     pthread_setspecific(m_key, new Data(ptr, this));
 }
 
-#elif PLATFORM(QT)
+#elif (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 
 template<typename T>
 inline ThreadSpecific<T>::ThreadSpecific()
@@ -186,7 +186,7 @@ inline void ThreadSpecific<T>::set(T* ptr)
     m_key.setLocalData(data);
 }
 
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 
 // TLS_OUT_OF_INDEXES is not defined on WinCE.
 #ifndef TLS_OUT_OF_INDEXES
@@ -246,15 +246,15 @@ inline void ThreadSpecific<T>::set(T* ptr)
 template<typename T>
 inline void ThreadSpecific<T>::destroy(void* ptr)
 {
-#if !ENABLE(SINGLE_THREADED)
+#if !(defined ENABLE_SINGLE_THREADED && ENABLE_SINGLE_THREADED)
     Data* data = static_cast<Data*>(ptr);
 
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
     // We want get() to keep working while data destructor works, because it can be called indirectly by the destructor.
     // Some pthreads implementations zero out the pointer before calling destroy(), so we temporarily reset it.
     pthread_setspecific(data->owner->m_key, ptr);
 #endif
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
     // See comment as above
     if (!data->owner->m_key.hasLocalData())
         data->owner->m_key.setLocalData(data);
@@ -263,17 +263,17 @@ inline void ThreadSpecific<T>::destroy(void* ptr)
     data->value->~T();
     fastFree(data->value);
 
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
     pthread_setspecific(data->owner->m_key, 0);
-#elif PLATFORM(QT)
+#elif (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
     // Do nothing here
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     TlsSetValue(tlsKeys()[data->owner->m_index], 0);
 #else
 #error ThreadSpecific is not implemented for this platform.
 #endif
 
-#if !PLATFORM(QT)
+#if !(defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
     delete data;
 #endif
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadSpecificWin.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadSpecificWin.cpp
index f2c0cad..1a6855a 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadSpecificWin.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadSpecificWin.cpp
@@ -23,7 +23,7 @@
 #include "ThreadSpecific.h"
 #include <wtf/Noncopyable.h>
 
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
 #error This file should not be compiled by ports that do not use Windows native ThreadSpecific implementation.
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Threading.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Threading.cpp
index 49de59e..b9de804 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Threading.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Threading.cpp
@@ -82,7 +82,7 @@ ThreadIdentifier createThread(ThreadFunction entryPoint, void* data, const char*
     return createThreadInternal(threadEntryPoint, context, name);
 }
 
-#if PLATFORM(MAC) || PLATFORM(WIN)
+#if (defined WTF_PLATFORM_MAC && WTF_PLATFORM_MAC) || (defined WTF_PLATFORM_WIN && WTF_PLATFORM_WIN)
 
 // This function is deprecated but needs to be kept around for backward
 // compatibility. Use the 3-argument version of createThread above.
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Threading.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Threading.h
index 8b76c0f..fccb14f 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Threading.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Threading.h
@@ -61,7 +61,7 @@
 
 #include "Platform.h"
 
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
 #include <windows.h>
 #endif
 
@@ -69,15 +69,15 @@
 #include <wtf/Locker.h>
 #include <wtf/Noncopyable.h>
 
-#if OS(WINDOWS) && !OS(WINCE)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS) && !(defined WTF_OS_WINCE && WTF_OS_WINCE)
 #include <windows.h>
-#elif OS(DARWIN)
+#elif (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #include <libkern/OSAtomic.h>
-#elif OS(ANDROID)
+#elif (defined WTF_OS_ANDROID && WTF_OS_ANDROID)
 #include <cutils/atomic.h>
-#elif OS(QNX)
+#elif (defined WTF_OS_QNX && WTF_OS_QNX)
 #include <atomic.h>
-#elif COMPILER(GCC) && !OS(SYMBIAN)
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && !(defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 #if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 2))
 #include <ext/atomicity.h>
 #else
@@ -85,15 +85,15 @@
 #endif
 #endif
 
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
 #include <pthread.h>
-#elif PLATFORM(GTK)
+#elif (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK)
 #include <wtf/gtk/GOwnPtr.h>
 typedef struct _GMutex GMutex;
 typedef struct _GCond GCond;
 #endif
 
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #include <qglobal.h>
 QT_BEGIN_NAMESPACE
 class QMutex;
@@ -130,23 +130,23 @@ bool isMainThread();
 int waitForThreadCompletion(ThreadIdentifier, void**);
 void detachThread(ThreadIdentifier);
 
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
 typedef pthread_mutex_t PlatformMutex;
-#if HAVE(PTHREAD_RWLOCK)
+#if (defined HAVE_PTHREAD_RWLOCK && HAVE_PTHREAD_RWLOCK)
 typedef pthread_rwlock_t PlatformReadWriteLock;
 #else
 typedef void* PlatformReadWriteLock;
 #endif
 typedef pthread_cond_t PlatformCondition;
-#elif PLATFORM(GTK)
+#elif (defined WTF_PLATFORM_GTK && WTF_PLATFORM_GTK)
 typedef GOwnPtr<GMutex> PlatformMutex;
 typedef void* PlatformReadWriteLock; // FIXME: Implement.
 typedef GOwnPtr<GCond> PlatformCondition;
-#elif PLATFORM(QT)
+#elif (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 typedef QT_PREPEND_NAMESPACE(QMutex)* PlatformMutex;
 typedef void* PlatformReadWriteLock; // FIXME: Implement.
 typedef QT_PREPEND_NAMESPACE(QWaitCondition)* PlatformCondition;
-#elif OS(WINDOWS)
+#elif (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 struct PlatformMutex {
     CRITICAL_SECTION m_internalMutex;
     size_t m_recursionCount;
@@ -219,10 +219,10 @@ private:
     PlatformCondition m_condition;
 };
 
-#if OS(WINDOWS)
+#if (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #define WTF_USE_LOCKFREE_THREADSAFESHARED 1
 
-#if COMPILER(MINGW) || COMPILER(MSVC7) || OS(WINCE)
+#if (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW) || (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7) || (defined WTF_OS_WINCE && WTF_OS_WINCE)
 inline int atomicIncrement(int* addend) { return InterlockedIncrement(reinterpret_cast<long*>(addend)); }
 inline int atomicDecrement(int* addend) { return InterlockedDecrement(reinterpret_cast<long*>(addend)); }
 #else
@@ -230,24 +230,24 @@ inline int atomicIncrement(int volatile* addend) { return InterlockedIncrement(r
 inline int atomicDecrement(int volatile* addend) { return InterlockedDecrement(reinterpret_cast<long volatile*>(addend)); }
 #endif
 
-#elif OS(DARWIN)
+#elif (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #define WTF_USE_LOCKFREE_THREADSAFESHARED 1
 
 inline int atomicIncrement(int volatile* addend) { return OSAtomicIncrement32Barrier(const_cast<int*>(addend)); }
 inline int atomicDecrement(int volatile* addend) { return OSAtomicDecrement32Barrier(const_cast<int*>(addend)); }
 
-#elif OS(ANDROID)
+#elif (defined WTF_OS_ANDROID && WTF_OS_ANDROID)
 
 inline int atomicIncrement(int volatile* addend) { return android_atomic_inc(addend); }
 inline int atomicDecrement(int volatile* addend) { return android_atomic_dec(addend); }
 
-#elif OS(QNX)
+#elif (defined WTF_OS_QNX && WTF_OS_QNX)
 
 // component functions take and return unsigned
 inline int atomicIncrement(int volatile* addend) { return (int) atomic_add_value((unsigned volatile*)addend, 1); }
 inline int atomicDecrement(int volatile* addend) { return (int) atomic_sub_value((unsigned volatile*)addend, 1); }
 
-#elif COMPILER(GCC) && !CPU(SPARC64) && !OS(SYMBIAN) // sizeof(_Atomic_word) != sizeof(int) on sparc64 gcc
+#elif (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && !(defined WTF_CPU_SPARC64 && WTF_CPU_SPARC64) && !(defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN) // sizeof(_Atomic_word) != sizeof(int) on sparc64 gcc
 #define WTF_USE_LOCKFREE_THREADSAFESHARED 1
 
 inline int atomicIncrement(int volatile* addend) { return __gnu_cxx::__exchange_and_add(addend, 1) + 1; }
@@ -264,7 +264,7 @@ public:
 
     void ref()
     {
-#if USE(LOCKFREE_THREADSAFESHARED)
+#if (defined WTF_USE_LOCKFREE_THREADSAFESHARED && WTF_USE_LOCKFREE_THREADSAFESHARED)
         atomicIncrement(&m_refCount);
 #else
         MutexLocker locker(m_mutex);
@@ -279,7 +279,7 @@ public:
 
     int refCount() const
     {
-#if !USE(LOCKFREE_THREADSAFESHARED)
+#if !(defined WTF_USE_LOCKFREE_THREADSAFESHARED && WTF_USE_LOCKFREE_THREADSAFESHARED)
         MutexLocker locker(m_mutex);
 #endif
         return static_cast<int const volatile &>(m_refCount);
@@ -289,7 +289,7 @@ protected:
     // Returns whether the pointer should be freed or not.
     bool derefBase()
     {
-#if USE(LOCKFREE_THREADSAFESHARED)
+#if (defined WTF_USE_LOCKFREE_THREADSAFESHARED && WTF_USE_LOCKFREE_THREADSAFESHARED)
         if (atomicDecrement(&m_refCount) <= 0)
             return true;
 #else
@@ -310,7 +310,7 @@ private:
     friend class CrossThreadRefCounted;
 
     int m_refCount;
-#if !USE(LOCKFREE_THREADSAFESHARED)
+#if !(defined WTF_USE_LOCKFREE_THREADSAFESHARED && WTF_USE_LOCKFREE_THREADSAFESHARED)
     mutable Mutex m_mutex;
 #endif
 };
@@ -344,7 +344,7 @@ using WTF::ThreadCondition;
 using WTF::ThreadIdentifier;
 using WTF::ThreadSafeShared;
 
-#if USE(LOCKFREE_THREADSAFESHARED)
+#if (defined WTF_USE_LOCKFREE_THREADSAFESHARED && WTF_USE_LOCKFREE_THREADSAFESHARED)
 using WTF::atomicDecrement;
 using WTF::atomicIncrement;
 #endif
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingNone.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingNone.cpp
index 2e8a259..4affe6e 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingNone.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingNone.cpp
@@ -30,7 +30,7 @@
 #include "config.h"
 #include "Threading.h"
 
-#if ENABLE(SINGLE_THREADED)
+#if (defined ENABLE_SINGLE_THREADED && ENABLE_SINGLE_THREADED)
 
 namespace WTF {
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingPthreads.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingPthreads.cpp
index 2feb808..363fa74 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingPthreads.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingPthreads.cpp
@@ -30,7 +30,7 @@
 #include "config.h"
 #include "Threading.h"
 
-#if USE(PTHREADS)
+#if (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
 
 #include "CurrentTime.h"
 #include "HashMap.h"
@@ -42,12 +42,12 @@
 #include "UnusedParam.h"
 #include <errno.h>
 
-#if !COMPILER(MSVC)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #include <limits.h>
 #include <sys/time.h>
 #endif
 
-#if OS(ANDROID)
+#if (defined WTF_OS_ANDROID && WTF_OS_ANDROID)
 #include "jni_utility.h"
 #endif
 
@@ -57,7 +57,7 @@ typedef HashMap<ThreadIdentifier, pthread_t> ThreadMap;
 
 static Mutex* atomicallyInitializedStaticMutex;
 
-#if !OS(DARWIN) || PLATFORM(CHROMIUM) || USE(WEB_THREAD)
+#if !(defined WTF_OS_DARWIN && WTF_OS_DARWIN) || (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM) || (defined WTF_USE_WEB_THREAD && WTF_USE_WEB_THREAD)
 static pthread_t mainThread; // The thread that was the first to call initializeThreading(), which must be the main thread.
 #endif
 
@@ -75,7 +75,7 @@ void initializeThreading()
         atomicallyInitializedStaticMutex = new Mutex;
         threadMapMutex();
         initializeRandomNumberGenerator();
-#if !OS(DARWIN) || PLATFORM(CHROMIUM) || USE(WEB_THREAD)
+#if !(defined WTF_OS_DARWIN && WTF_OS_DARWIN) || (defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM) || (defined WTF_USE_WEB_THREAD && WTF_USE_WEB_THREAD)
         mainThread = pthread_self();
 #endif
         initializeMainThread();
@@ -141,7 +141,7 @@ void clearPthreadHandleForIdentifier(ThreadIdentifier id)
     threadMap().remove(id);
 }
 
-#if OS(ANDROID)
+#if (defined WTF_OS_ANDROID && WTF_OS_ANDROID)
 // On the Android platform, threads must be registered with the VM before they run.
 struct ThreadData {
     ThreadFunction entryPoint;
@@ -191,7 +191,7 @@ ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, con
 
 void initializeCurrentThreadInternal(const char* threadName)
 {
-#if HAVE(PTHREAD_SETNAME_NP)
+#if (defined HAVE_PTHREAD_SETNAME_NP && HAVE_PTHREAD_SETNAME_NP)
     pthread_setname_np(threadName);
 #else
     UNUSED_PARAM(threadName);
@@ -242,7 +242,7 @@ ThreadIdentifier currentThread()
 
 bool isMainThread()
 {
-#if OS(DARWIN) && !PLATFORM(CHROMIUM) && !USE(WEB_THREAD)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN) && !(defined WTF_PLATFORM_CHROMIUM && WTF_PLATFORM_CHROMIUM) && !(defined WTF_USE_WEB_THREAD && WTF_USE_WEB_THREAD)
     return pthread_main_np();
 #else
     return pthread_equal(pthread_self(), mainThread);
@@ -284,7 +284,7 @@ void Mutex::unlock()
     ASSERT_UNUSED(result, !result);
 }
 
-#if HAVE(PTHREAD_RWLOCK)
+#if (defined HAVE_PTHREAD_RWLOCK && HAVE_PTHREAD_RWLOCK)
 ReadWriteLock::ReadWriteLock()
 {
     pthread_rwlock_init(&m_readWriteLock, NULL);
@@ -338,7 +338,7 @@ void ReadWriteLock::unlock()
     int result = pthread_rwlock_unlock(&m_readWriteLock);
     ASSERT_UNUSED(result, !result);
 }
-#endif  // HAVE(PTHREAD_RWLOCK)
+#endif  // (defined HAVE_PTHREAD_RWLOCK && HAVE_PTHREAD_RWLOCK)
 
 ThreadCondition::ThreadCondition()
 { 
@@ -390,4 +390,4 @@ void ThreadCondition::broadcast()
 
 } // namespace WTF
 
-#endif // USE(PTHREADS)
+#endif // (defined WTF_USE_PTHREADS && WTF_USE_PTHREADS)
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingWin.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingWin.cpp
index 73c3f0c..1c242e5 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingWin.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/ThreadingWin.cpp
@@ -87,13 +87,13 @@
 #include "Threading.h"
 
 #include "MainThread.h"
-#if !USE(PTHREADS) && OS(WINDOWS)
+#if !(defined WTF_USE_PTHREADS && WTF_USE_PTHREADS) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
 #include "ThreadSpecific.h"
 #endif
-#if !OS(WINCE)
+#if !(defined WTF_OS_WINCE && WTF_OS_WINCE)
 #include <process.h>
 #endif
-#if HAVE(ERRNO_H)
+#if (defined HAVE_ERRNO_H && HAVE_ERRNO_H)
 #include <errno.h>
 #else
 #define NO_ERRNO
@@ -205,7 +205,7 @@ static unsigned __stdcall wtfThreadEntryPoint(void* param)
 
     void* result = invocation.function(invocation.data);
 
-#if !USE(PTHREADS) && OS(WINDOWS)
+#if !(defined WTF_USE_PTHREADS && WTF_USE_PTHREADS) && (defined WTF_OS_WINDOWS && WTF_OS_WINDOWS)
     // Do the TLS cleanup.
     ThreadSpecificThreadExit();
 #endif
@@ -218,7 +218,7 @@ ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, con
     unsigned threadIdentifier = 0;
     ThreadIdentifier threadID = 0;
     ThreadFunctionInvocation* invocation = new ThreadFunctionInvocation(entryPoint, data);
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
     // This is safe on WINCE, since CRT is in the core and innately multithreaded.
     // On desktop Windows, need to use _beginthreadex (not available on WinCE) if using any CRT functions
     HANDLE threadHandle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)wtfThreadEntryPoint, invocation, 0, (LPDWORD)&threadIdentifier);
@@ -226,7 +226,7 @@ ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, con
     HANDLE threadHandle = reinterpret_cast<HANDLE>(_beginthreadex(0, 0, wtfThreadEntryPoint, invocation, 0, &threadIdentifier));
 #endif
     if (!threadHandle) {
-#if OS(WINCE)
+#if (defined WTF_OS_WINCE && WTF_OS_WINCE)
         LOG_ERROR("Failed to create thread at entry point %p with data %p: %ld", entryPoint, data, ::GetLastError());
 #elif defined(NO_ERRNO)
         LOG_ERROR("Failed to create thread at entry point %p with data %p.", entryPoint, data);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.cpp
index 9e51ad0..62f824c 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.cpp
@@ -38,7 +38,7 @@ COMPILE_ASSERT(IsInteger<long>::value, WTF_IsInteger_long_true);
 COMPILE_ASSERT(IsInteger<unsigned long>::value, WTF_IsInteger_unsigned_long_true);
 COMPILE_ASSERT(IsInteger<long long>::value, WTF_IsInteger_long_long_true);
 COMPILE_ASSERT(IsInteger<unsigned long long>::value, WTF_IsInteger_unsigned_long_long_true);
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
 COMPILE_ASSERT(IsInteger<wchar_t>::value, WTF_IsInteger_wchar_t_true);
 #endif
 COMPILE_ASSERT(!IsInteger<char*>::value, WTF_IsInteger_char_pointer_false);
@@ -59,7 +59,7 @@ COMPILE_ASSERT(IsPod<long>::value, WTF_IsPod_long_true);
 COMPILE_ASSERT(IsPod<unsigned long>::value, WTF_IsPod_unsigned_long_true);
 COMPILE_ASSERT(IsPod<long long>::value, WTF_IsPod_long_long_true);
 COMPILE_ASSERT(IsPod<unsigned long long>::value, WTF_IsPod_unsigned_long_long_true);
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
 COMPILE_ASSERT(IsPod<wchar_t>::value, WTF_IsPod_wchar_t_true);
 #endif
 COMPILE_ASSERT(IsPod<char*>::value, WTF_IsPod_char_pointer_true);
@@ -84,7 +84,7 @@ COMPILE_ASSERT(IsConvertibleToInteger<long>::value, WTF_IsConvertibleToInteger_l
 COMPILE_ASSERT(IsConvertibleToInteger<unsigned long>::value, WTF_IsConvertibleToInteger_unsigned_long_true);
 COMPILE_ASSERT(IsConvertibleToInteger<long long>::value, WTF_IsConvertibleToInteger_long_long_true);
 COMPILE_ASSERT(IsConvertibleToInteger<unsigned long long>::value, WTF_IsConvertibleToInteger_unsigned_long_long_true);
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
 COMPILE_ASSERT(IsConvertibleToInteger<wchar_t>::value, WTF_IsConvertibleToInteger_wchar_t_true);
 #endif
 COMPILE_ASSERT(IsConvertibleToInteger<double>::value, WTF_IsConvertibleToInteger_double_true);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.h
index 7ba487f..4a0a5a5 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.h
@@ -58,7 +58,7 @@ namespace WTF {
     template<> struct IsInteger<unsigned long>      { static const bool value = true; };
     template<> struct IsInteger<long long>          { static const bool value = true; };
     template<> struct IsInteger<unsigned long long> { static const bool value = true; };
-#if !COMPILER(MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
+#if !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC) || defined(_NATIVE_WCHAR_T_DEFINED)
     template<> struct IsInteger<wchar_t>            { static const bool value = true; };
 #endif
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/VMTags.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/VMTags.h
index 75bec11..fce14fd 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/VMTags.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/VMTags.h
@@ -30,7 +30,7 @@
 
 // On Mac OS X, the VM subsystem allows tagging memory requested from mmap and vm_map
 // in order to aid tools that inspect system memory use. 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
 #include <mach/vm_statistics.h>
 
@@ -79,7 +79,7 @@
 #define VM_TAG_FOR_WEBCORE_PURGEABLE_MEMORY VM_MAKE_TAG(69)
 #endif // defined(VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS)
 
-#else // OS(DARWIN)
+#else // (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
 #define VM_TAG_FOR_TCMALLOC_MEMORY -1
 #define VM_TAG_FOR_COLLECTOR_MEMORY -1
@@ -87,6 +87,6 @@
 #define VM_TAG_FOR_REGISTERFILE_MEMORY -1
 #define VM_TAG_FOR_WEBCORE_PURGEABLE_MEMORY -1
 
-#endif // OS(DARWIN)
+#endif // (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 
 #endif // VMTags_h
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Vector.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Vector.h
index 156ff1a..26470df 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Vector.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Vector.h
@@ -28,7 +28,7 @@
 #include <limits>
 #include <utility>
 
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
 #include <QDataStream>
 #endif
 
@@ -38,17 +38,17 @@ namespace WTF {
     using std::max;
 
     // WTF_ALIGN_OF / WTF_ALIGNED
-    #if COMPILER(GCC) || COMPILER(MINGW) || COMPILER(RVCT) || COMPILER(WINSCW)
+    #if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) || (defined WTF_COMPILER_MINGW && WTF_COMPILER_MINGW) || (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT) || (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW)
         #define WTF_ALIGN_OF(type) __alignof__(type)
         #define WTF_ALIGNED(variable_type, variable, n) variable_type variable __attribute__((__aligned__(n)))
-    #elif COMPILER(MSVC)
+    #elif (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
         #define WTF_ALIGN_OF(type) __alignof(type)
         #define WTF_ALIGNED(variable_type, variable, n) __declspec(align(n)) variable_type variable
     #else
         #define WTF_ALIGN_OF(type)   0
     #endif
 
-    #if COMPILER(GCC) && !COMPILER(INTEL) && (((__GNUC__ * 100) + __GNUC_MINOR__) >= 303)
+    #if (defined WTF_COMPILER_GCC  && WTF_COMPILER_GCC) && !(defined WTF_COMPILER_INTEL && WTF_COMPILER_INTEL) && (((__GNUC__ * 100) + __GNUC_MINOR__) >= 303)
         typedef char __attribute__((__may_alias__)) AlignedBufferChar; 
     #else
         typedef char AlignedBufferChar; 
@@ -612,7 +612,7 @@ namespace WTF {
         Buffer m_buffer;
     };
 
-#if PLATFORM(QT)
+#if (defined WTF_PLATFORM_QT && WTF_PLATFORM_QT)
     QT_USE_NAMESPACE
     template<typename T>
     QDataStream& operator<<(QDataStream& stream, const Vector<T>& data)
@@ -872,7 +872,7 @@ namespace WTF {
                 return;
         }
             
-#if COMPILER(MSVC7)
+#if (defined WTF_COMPILER_MSVC7  && WTF_COMPILER_MSVC7)
         // FIXME: MSVC7 generates compilation errors when trying to assign
         // a pointer to a Vector of its base class (i.e. can't downcast). So far
         // I've been unable to determine any logical reason for this, so I can
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/dtoa.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/dtoa.cpp
index 6289d04..c27afc6 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/dtoa.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/dtoa.cpp
@@ -135,7 +135,7 @@
 #include "config.h"
 #include "dtoa.h"
 
-#if HAVE(ERRNO_H)
+#if (defined HAVE_ERRNO_H && HAVE_ERRNO_H)
 #include <errno.h>
 #else
 #define NO_ERRNO
@@ -153,15 +153,15 @@
 
 #include <stdio.h>
 
-#if COMPILER(MSVC)
+#if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #pragma warning(disable: 4244)
 #pragma warning(disable: 4245)
 #pragma warning(disable: 4554)
 #endif
 
-#if CPU(BIG_ENDIAN)
+#if (defined WTF_CPU_BIG_ENDIAN && WTF_CPU_BIG_ENDIAN)
 #define IEEE_MC68k
-#elif CPU(MIDDLE_ENDIAN)
+#elif (defined WTF_CPU_MIDDLE_ENDIAN && WTF_CPU_MIDDLE_ENDIAN)
 #define IEEE_ARM
 #else
 #define IEEE_8087
@@ -175,7 +175,7 @@ Exactly one of IEEE_8087, IEEE_ARM or IEEE_MC68k should be defined.
 
 namespace WTF {
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
 Mutex* s_dtoaP5Mutex;
 #endif
 
@@ -262,7 +262,7 @@ typedef union { double d; uint32_t L[2]; } U;
 #define Pack_32
 #endif
 
-#if CPU(PPC64) || CPU(X86_64)
+#if (defined WTF_CPU_PPC64 && WTF_CPU_PPC64) || (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
 // FIXME: should we enable this on all 64-bit CPUs?
 // 64-bit emulation provided by the compiler is likely to be slower than dtoa own code on 32-bit hardware.
 #define USE_LONG_LONG
@@ -579,7 +579,7 @@ static ALWAYS_INLINE void pow5mult(BigInt& b, int k)
     if (!(k >>= 2))
         return;
 
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     s_dtoaP5Mutex->lock();
 #endif
     P5Node* p5 = p5s;
@@ -594,7 +594,7 @@ static ALWAYS_INLINE void pow5mult(BigInt& b, int k)
     }
 
     int p5s_count_local = p5s_count;
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
     s_dtoaP5Mutex->unlock();
 #endif
     int p5s_used = 0;
@@ -607,7 +607,7 @@ static ALWAYS_INLINE void pow5mult(BigInt& b, int k)
             break;
 
         if (++p5s_used == p5s_count_local) {
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
             s_dtoaP5Mutex->lock();
 #endif
             if (p5s_used == p5s_count) {
@@ -620,7 +620,7 @@ static ALWAYS_INLINE void pow5mult(BigInt& b, int k)
             }
             
             p5s_count_local = p5s_count;
-#if ENABLE(JSC_MULTIPLE_THREADS)
+#if (defined ENABLE_JSC_MULTIPLE_THREADS && ENABLE_JSC_MULTIPLE_THREADS)
             s_dtoaP5Mutex->unlock();
 #endif
         }
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/qt/ThreadingQt.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/qt/ThreadingQt.cpp
index 3e5aa59..e20ded7 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/qt/ThreadingQt.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/qt/ThreadingQt.cpp
@@ -29,7 +29,7 @@
 #include "config.h"
 #include "Threading.h"
 
-#if !ENABLE(SINGLE_THREADED)
+#if !(defined ENABLE_SINGLE_THREADED && ENABLE_SINGLE_THREADED)
 
 #include "CurrentTime.h"
 #include "HashMap.h"
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/symbian/BlockAllocatorSymbian.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/symbian/BlockAllocatorSymbian.cpp
index 7ed8b96..9e65808 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/symbian/BlockAllocatorSymbian.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/symbian/BlockAllocatorSymbian.cpp
@@ -28,7 +28,7 @@
 
 #include "config.h"
 
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 
 #include "BlockAllocatorSymbian.h"
 #include <e32atomics.h>
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/symbian/RegisterFileAllocatorSymbian.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/symbian/RegisterFileAllocatorSymbian.cpp
index e89dd7a..6a78db9 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/symbian/RegisterFileAllocatorSymbian.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/symbian/RegisterFileAllocatorSymbian.cpp
@@ -28,7 +28,7 @@
 
 #include "config.h"
 
-#if OS(SYMBIAN)
+#if (defined WTF_OS_SYMBIAN && WTF_OS_SYMBIAN)
 
 #include "RegisterFileAllocatorSymbian.h"
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/Collator.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/Collator.h
index 51e8a06..a3fa7ab 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/Collator.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/Collator.h
@@ -33,7 +33,7 @@
 #include <wtf/Noncopyable.h>
 #include <wtf/unicode/Unicode.h>
 
-#if USE(ICU_UNICODE) && !UCONFIG_NO_COLLATION
+#if (defined WTF_USE_ICU_UNICODE && WTF_USE_ICU_UNICODE) && !UCONFIG_NO_COLLATION
 struct UCollator;
 #endif
 
@@ -52,7 +52,7 @@ namespace WTF {
         Result collate(const ::UChar*, size_t, const ::UChar*, size_t) const;
 
     private:
-#if USE(ICU_UNICODE) && !UCONFIG_NO_COLLATION
+#if (defined WTF_USE_ICU_UNICODE && WTF_USE_ICU_UNICODE) && !UCONFIG_NO_COLLATION
         void createCollator() const;
         void releaseCollator();
         mutable UCollator* m_collator;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/CollatorDefault.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/CollatorDefault.cpp
index eddbe53..6b3c8b3 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/CollatorDefault.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/CollatorDefault.cpp
@@ -29,7 +29,7 @@
 #include "config.h"
 #include "Collator.h"
 
-#if !USE(ICU_UNICODE) || UCONFIG_NO_COLLATION
+#if !(defined WTF_USE_ICU_UNICODE && WTF_USE_ICU_UNICODE) || UCONFIG_NO_COLLATION
 
 namespace WTF {
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/Unicode.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/Unicode.h
index d59439d..cc4a589 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/Unicode.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/Unicode.h
@@ -25,13 +25,13 @@
 
 #include <wtf/Assertions.h>
 
-#if USE(QT4_UNICODE)
+#if (defined WTF_USE_QT4_UNICODE && WTF_USE_QT4_UNICODE)
 #include "qt4/UnicodeQt4.h"
-#elif USE(ICU_UNICODE)
+#elif (defined WTF_USE_ICU_UNICODE && WTF_USE_ICU_UNICODE)
 #include <wtf/unicode/icu/UnicodeIcu.h>
-#elif USE(GLIB_UNICODE)
+#elif (defined WTF_USE_GLIB_UNICODE && WTF_USE_GLIB_UNICODE)
 #include <wtf/unicode/glib/UnicodeGLib.h>
-#elif USE(WINCE_UNICODE)
+#elif (defined WTF_USE_WINCE_UNICODE && WTF_USE_WINCE_UNICODE)
 #include <wtf/unicode/wince/UnicodeWince.h>
 #else
 #error "Unknown Unicode implementation"
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/icu/CollatorICU.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/icu/CollatorICU.cpp
index a1753a4..b84c351 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/icu/CollatorICU.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/icu/CollatorICU.cpp
@@ -29,14 +29,14 @@
 #include "config.h"
 #include "Collator.h"
 
-#if USE(ICU_UNICODE) && !UCONFIG_NO_COLLATION
+#if (defined WTF_USE_ICU_UNICODE && WTF_USE_ICU_UNICODE) && !UCONFIG_NO_COLLATION
 
 #include "Assertions.h"
 #include "Threading.h"
 #include <unicode/ucol.h>
 #include <string.h>
 
-#if OS(DARWIN)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN)
 #include "RetainPtr.h"
 #include <CoreFoundation/CoreFoundation.h>
 #endif
@@ -59,9 +59,9 @@ Collator::Collator(const char* locale)
 
 std::auto_ptr<Collator> Collator::userDefault()
 {
-#if OS(DARWIN) && PLATFORM(CF)
+#if (defined WTF_OS_DARWIN && WTF_OS_DARWIN) && (defined WTF_PLATFORM_CF && WTF_PLATFORM_CF)
     // Mac OS X doesn't set UNIX locale to match user-selected one, so ICU default doesn't work.
-#if !defined(BUILDING_ON_TIGER) && !defined(BUILDING_ON_LEOPARD) && !OS(IPHONE_OS)
+#if !defined(BUILDING_ON_TIGER) && !defined(BUILDING_ON_LEOPARD) && !(defined WTF_OS_IPHONE_OS && WTF_OS_IPHONE_OS)
     RetainPtr<CFLocaleRef> currentLocale(AdoptCF, CFLocaleCopyCurrent());
     CFStringRef collationOrder = (CFStringRef)CFLocaleGetValue(currentLocale.get(), kCFLocaleCollatorIdentifier);
 #else
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/qt4/UnicodeQt4.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/qt4/UnicodeQt4.h
index 784adbb..cc37238 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/qt4/UnicodeQt4.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/unicode/qt4/UnicodeQt4.h
@@ -56,7 +56,7 @@ namespace QUnicodeTables {
 QT_END_NAMESPACE
 
 // ugly hack to make UChar compatible with JSChar in API/JSStringRef.h
-#if defined(Q_OS_WIN) || COMPILER(WINSCW) || COMPILER(RVCT)
+#if defined(Q_OS_WIN) || (defined WTF_COMPILER_WINSCW && WTF_COMPILER_WINSCW) || (defined WTF_COMPILER_RVCT  && WTF_COMPILER_RVCT)
 typedef wchar_t UChar;
 #else
 typedef uint16_t UChar;
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/wince/FastMallocWince.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/wince/FastMallocWince.h
index 37174f0..65b7774 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/wince/FastMallocWince.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/wince/FastMallocWince.h
@@ -95,7 +95,7 @@ namespace WTF {
     }
 
 
-#if ENABLE(FAST_MALLOC_MATCH_VALIDATION)
+#if (defined ENABLE_FAST_MALLOC_MATCH_VALIDATION && ENABLE_FAST_MALLOC_MATCH_VALIDATION)
 
     // Malloc validation is a scheme whereby a tag is attached to an
     // allocation which identifies how it was originally allocated.
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexCompiler.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexCompiler.cpp
index 9cd3d12..230fa35 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexCompiler.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexCompiler.cpp
@@ -30,7 +30,7 @@
 #include "RegexPattern.h"
 #include <wtf/Vector.h>
 
-#if ENABLE(YARR)
+#if (defined ENABLE_YARR && ENABLE_YARR)
 
 using namespace WTF;
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexCompiler.h b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexCompiler.h
index 3ed2be9..c49ca4a 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexCompiler.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexCompiler.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(YARR)
+#if (defined ENABLE_YARR && ENABLE_YARR)
 
 #include <wtf/unicode/Unicode.h>
 #include "RegexParser.h"
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexInterpreter.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexInterpreter.cpp
index d088086..29d0208 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexInterpreter.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexInterpreter.cpp
@@ -33,7 +33,7 @@
 #include <stdio.h>
 #endif
 
-#if ENABLE(YARR)
+#if (defined ENABLE_YARR && ENABLE_YARR)
 
 using namespace WTF;
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexInterpreter.h b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexInterpreter.h
index 48c9a5e..c82e537 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexInterpreter.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexInterpreter.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(YARR)
+#if (defined ENABLE_YARR && ENABLE_YARR)
 
 #include <wtf/unicode/Unicode.h>
 #include "RegexParser.h"
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexJIT.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexJIT.cpp
index 1015923..79af305 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexJIT.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexJIT.cpp
@@ -34,7 +34,7 @@
 
 #include "pcre.h" // temporary, remove when fallback is removed.
 
-#if ENABLE(YARR_JIT)
+#if (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT)
 
 using namespace WTF;
 
@@ -44,7 +44,7 @@ namespace JSC { namespace Yarr {
 class RegexGenerator : private MacroAssembler {
     friend void jitCompileRegex(JSGlobalData* globalData, RegexCodeBlock& jitObject, const UString& pattern, unsigned& numSubpatterns, const char*& error, bool ignoreCase, bool multiline);
 
-#if CPU(ARM)
+#if (defined WTF_CPU_ARM && WTF_CPU_ARM)
     static const RegisterID input = ARMRegisters::r0;
     static const RegisterID index = ARMRegisters::r1;
     static const RegisterID length = ARMRegisters::r2;
@@ -54,7 +54,7 @@ class RegexGenerator : private MacroAssembler {
     static const RegisterID regT1 = ARMRegisters::r6;
 
     static const RegisterID returnRegister = ARMRegisters::r0;
-#elif CPU(X86)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86)
     static const RegisterID input = X86Registers::eax;
     static const RegisterID index = X86Registers::edx;
     static const RegisterID length = X86Registers::ecx;
@@ -64,7 +64,7 @@ class RegexGenerator : private MacroAssembler {
     static const RegisterID regT1 = X86Registers::esi;
 
     static const RegisterID returnRegister = X86Registers::eax;
-#elif CPU(X86_64)
+#elif (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
     static const RegisterID input = X86Registers::edi;
     static const RegisterID index = X86Registers::esi;
     static const RegisterID length = X86Registers::edx;
@@ -1288,11 +1288,11 @@ class RegexGenerator : private MacroAssembler {
 
     void generateEnter()
     {
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         push(X86Registers::ebp);
         move(stackPointerRegister, X86Registers::ebp);
         push(X86Registers::ebx);
-#elif CPU(X86)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86)
         push(X86Registers::ebp);
         move(stackPointerRegister, X86Registers::ebp);
         // TODO: do we need spill registers to fill the output pointer if there are no sub captures?
@@ -1300,7 +1300,7 @@ class RegexGenerator : private MacroAssembler {
         push(X86Registers::edi);
         push(X86Registers::esi);
         // load output into edi (2 = saved ebp + return address).
-    #if COMPILER(MSVC)
+    #if (defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), input);
         loadPtr(Address(X86Registers::ebp, 3 * sizeof(void*)), index);
         loadPtr(Address(X86Registers::ebp, 4 * sizeof(void*)), length);
@@ -1308,11 +1308,11 @@ class RegexGenerator : private MacroAssembler {
     #else
         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), output);
     #endif
-#elif CPU(ARM)
+#elif (defined WTF_CPU_ARM && WTF_CPU_ARM)
         push(ARMRegisters::r4);
         push(ARMRegisters::r5);
         push(ARMRegisters::r6);
-#if CPU(ARM_TRADITIONAL)
+#if (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
         push(ARMRegisters::r8); // scratch register
 #endif
         move(ARMRegisters::r3, output);
@@ -1321,16 +1321,16 @@ class RegexGenerator : private MacroAssembler {
 
     void generateReturn()
     {
-#if CPU(X86_64)
+#if (defined WTF_CPU_X86_64 && WTF_CPU_X86_64)
         pop(X86Registers::ebx);
         pop(X86Registers::ebp);
-#elif CPU(X86)
+#elif (defined WTF_CPU_X86 && WTF_CPU_X86)
         pop(X86Registers::esi);
         pop(X86Registers::edi);
         pop(X86Registers::ebx);
         pop(X86Registers::ebp);
-#elif CPU(ARM)
-#if CPU(ARM_TRADITIONAL)
+#elif (defined WTF_CPU_ARM && WTF_CPU_ARM)
+#if (defined WTF_CPU_ARM_TRADITIONAL && WTF_CPU_ARM_TRADITIONAL)
         pop(ARMRegisters::r8); // scratch register
 #endif
         pop(ARMRegisters::r6);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexJIT.h b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexJIT.h
index 5ead00f..644a8ed 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexJIT.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexJIT.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(YARR_JIT)
+#if (defined ENABLE_YARR_JIT && ENABLE_YARR_JIT)
 
 #include "MacroAssembler.h"
 #include "RegexPattern.h"
@@ -37,7 +37,7 @@
 #include <pcre.h>
 struct JSRegExp; // temporary, remove when fallback is removed.
 
-#if CPU(X86) && !COMPILER(MSVC)
+#if (defined WTF_CPU_X86 && WTF_CPU_X86) && !(defined WTF_COMPILER_MSVC  && WTF_COMPILER_MSVC)
 #define YARR_CALL __attribute__ ((regparm (3)))
 #else
 #define YARR_CALL
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexParser.h b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexParser.h
index 64e8463..8fb04b2 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexParser.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexParser.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(YARR)
+#if (defined ENABLE_YARR && ENABLE_YARR)
 
 #include <UString.h>
 #include <wtf/ASCIICType.h>
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexPattern.h b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexPattern.h
index dd7512d..c886b87 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexPattern.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/yarr/RegexPattern.h
@@ -28,7 +28,7 @@
 
 #include <wtf/Platform.h>
 
-#if ENABLE(YARR)
+#if (defined ENABLE_YARR && ENABLE_YARR)
 
 #include <wtf/Vector.h>
 #include <wtf/unicode/Unicode.h>
