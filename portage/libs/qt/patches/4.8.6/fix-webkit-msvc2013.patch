--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/MathExtras.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/MathExtras.h
@@ -90,7 +90,7 @@
 
 #endif
 
-#if COMPILER(MSVC) || COMPILER(RVCT)
+#if (COMPILER(MSVC) && _MSC_VER < 1800) || COMPILER(RVCT)
 
 // We must not do 'num + 0.5' or 'num - 0.5' because they can cause precision loss.
 static double round(double num)
@@ -115,7 +115,7 @@
 
 #endif
 
-#if COMPILER(MSVC)
+#if COMPILER(MSVC) && _MSC_VER < 1800
 
 inline bool isinf(double num) { return !_finite(num) && !_isnan(num); }
 inline bool isnan(double num) { return !!_isnan(num); }
 
--- a/src/3rdparty/webkit/Source/JavaScriptCore/wtf/HashSet.h
+++ b/src/3rdparty/webkit/Source/JavaScriptCore/wtf/HashSet.h
@@ -92,6 +92,14 @@
         friend void deleteAllValues<>(const HashSet&);
         friend void fastDeleteAllValues<>(const HashSet&);
 
+#if COMPILER(MSVC) && _MSC_VER >= 1700
+        // MSVC2012/MSVC2013 has trouble constructing a HashTableConstIteratorAdapter from a
+        // HashTableIterator despite the existence of a const_iterator cast method on the latter class.
+        pair<iterator, bool> iterator_const_cast(const pair<typename HashTableType::iterator, bool>& p)
+        {
+            return make_pair(iterator(HashTableType::const_iterator(p.first)), p.second);
+        }
+#endif
         HashTableType m_impl;
     };
 
@@ -177,7 +185,11 @@
     template<typename T, typename U, typename V>
     inline pair<typename HashSet<T, U, V>::iterator, bool> HashSet<T, U, V>::add(const ValueType& value)
     {
+#if COMPILER(MSVC) && _MSC_VER >= 1700
+        return iterator_const_cast(m_impl.add(value));
+#else
         return m_impl.add(value);
+#endif
     }
 
     template<typename Value, typename HashFunctions, typename Traits>
@@ -186,7 +198,11 @@
     HashSet<Value, HashFunctions, Traits>::add(const T& value)
     {
         typedef HashSetTranslatorAdapter<ValueType, ValueTraits, T, HashTranslator> Adapter;
+#if COMPILER(MSVC) && _MSC_VER >= 1700
+        return iterator_const_cast(m_impl.template addPassingHashCode<T, T, Adapter>(value, value));
+#else
         return m_impl.template addPassingHashCode<T, T, Adapter>(value, value);
+#endif
     }
 
     template<typename T, typename U, typename V>
