diff --git a/mkspecs/features/qt_build_extra.prf b/mkspecs/features/qt_build_extra.prf
index 378f5bb..4e53f8c 100644
--- a/mkspecs/features/qt_build_extra.prf
+++ b/mkspecs/features/qt_build_extra.prf
@@ -13,7 +13,7 @@ equals(TEMPLATE, subdirs): return()
 
 # It's likely that these extra flags will be wrong for host builds,
 # and the bootstrapped tools usually don't need them anyway.
-host_build:force_bootstrap: return()
+# host_build:force_bootstrap: return()
 
 # The headersclean check needs defines and includes even for
 # header-only modules.
diff --git a/qmake/generators/makefile.cpp b/qmake/generators/makefile.cpp
index a596474..b5e26f3 100644
--- a/qmake/generators/makefile.cpp
+++ b/qmake/generators/makefile.cpp
@@ -1183,7 +1183,7 @@ MakefileGenerator::filePrefixRoot(const QString &root, const QString &path)
 {
     QString ret(path);
     if(path.length() > 2 && path[1] == ':') //c:\foo
-        ret.insert(2, root);
+        ret.replace(0, 2, root);
     else
         ret.prepend(root);
     while (ret.endsWith('\\'))
diff --git a/src/corelib/io/qstandardpaths_win.cpp b/src/corelib/io/qstandardpaths_win.cpp
index c1b34d1..6002b0b 100644
--- a/src/corelib/io/qstandardpaths_win.cpp
+++ b/src/corelib/io/qstandardpaths_win.cpp
@@ -271,6 +271,16 @@ QStringList QStandardPaths::standardLocations(StandardLocation type)
 #  ifndef QT_BOOTSTRAPPED
         dirs.append(QCoreApplication::applicationDirPath());
         dirs.append(QCoreApplication::applicationDirPath() + QLatin1String("/data"));
+        dirs.append(QCoreApplication::applicationDirPath() + QLatin1String("/../share"));
+        if (type != GenericDataLocation && type != GenericConfigLocation) {
+            QString appData = QCoreApplication::applicationDirPath() + QLatin1String("/../share");
+            if (!QCoreApplication::organizationName().isEmpty())
+                appData += QLatin1Char('/') + QCoreApplication::organizationName();
+            if (!QCoreApplication::applicationName().isEmpty())
+                appData += QLatin1Char('/') + QCoreApplication::applicationName();
+           dirs.append(appData);
+       }
+        dirs.append(QCoreApplication::applicationDirPath() + QLatin1String("/../etc/xdg"));
 #  endif // !QT_BOOTSTRAPPED
     } // isConfigLocation()
 #endif // !Q_OS_WINCE
diff --git a/src/gui/image/qiconloader.cpp b/src/gui/image/qiconloader.cpp
index 3ead72d..7d39e3d 100644
--- a/src/gui/image/qiconloader.cpp
+++ b/src/gui/image/qiconloader.cpp
@@ -149,6 +149,7 @@ QStringList QIconLoader::themeSearchPaths() const
 {
     if (m_iconDirs.isEmpty()) {
         m_iconDirs = systemIconSearchPaths();
+        m_iconDirs.append(QCoreApplication::applicationDirPath() + QLatin1String("/../share/icons"));
         // Always add resource directory as search path
         m_iconDirs.append(QLatin1String(":/icons"));
     }
diff --git a/src/plugins/platforms/windows/qwindowstheme.cpp b/src/plugins/platforms/windows/qwindowstheme.cpp
index f673ce5..f219ee0 100644
--- a/src/plugins/platforms/windows/qwindowstheme.cpp
+++ b/src/plugins/platforms/windows/qwindowstheme.cpp
@@ -347,6 +347,8 @@ static inline QStringList iconThemeSearchPaths()
 static inline QStringList styleNames()
 {
     QStringList result;
+    result.append(QStringLiteral("breeze"));
+    result.append(QStringLiteral("oxygen"));
     if (QSysInfo::WindowsVersion >= QSysInfo::WV_VISTA)
         result.append(QStringLiteral("WindowsVista"));
     if (QSysInfo::WindowsVersion >= QSysInfo::WV_XP)
@@ -410,6 +412,9 @@ QVariant QWindowsTheme::themeHint(ThemeHint hint) const
         return QVariant(true);
     case WheelScrollLines:
         return QVariant(int(dWordSystemParametersInfo(SPI_GETWHEELSCROLLLINES, 3)));
+    case QPlatformTheme::SystemIconThemeName:
+    case QPlatformTheme::SystemIconFallbackThemeName:
+        return QVariant(QLatin1String("breeze"));
     default:
         break;
     }
