diff -Nru -x '*~' kdewin-0.5.6.orig/include/ntddcdrm.h kdewin-0.5.6/include/ntddcdrm.h
--- kdewin-0.5.6.orig/include/ntddcdrm.h	1970-01-01 01:00:00.000000000 +0100
+++ kdewin-0.5.6/include/ntddcdrm.h	2013-05-30 22:02:10.791259400 +0200
@@ -0,0 +1,360 @@
+/*
+ * ntddcdrm.h
+ *
+ * CDROM IOCTL interface.
+ *
+ * This file is part of the kdewin package and is originally from the mingw-w64 w32api package.
+ *
+ * Contributors:
+ *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
+ *   Modified by Patrick Spendrin <ps_ml@gmx.de>
+ *
+ * THIS SOFTWARE IS NOT COPYRIGHTED
+ *
+ * This source code is offered for use in the public domain. You may
+ * use, modify or distribute it freely.
+ *
+ * This code is distributed in the hope that it will be useful but
+ * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
+ * DISCLAIMED. This includes but is not limited to warranties of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+#ifndef _NTDDCDRM_
+#define _NTDDCDRM_
+
+#include "ntddstor.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IOCTL_CDROM_BASE                  FILE_DEVICE_CD_ROM
+
+#define IOCTL_CDROM_CHECK_VERIFY \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_FIND_NEW_DEVICES \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_GET_CONFIGURATION \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0016, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_GET_CONTROL \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x000D, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_GET_DRIVE_GEOMETRY \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0014, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_GET_LAST_SESSION \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x000E, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_GET_VOLUME \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_PAUSE_AUDIO \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_PLAY_AUDIO_MSF \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_RAW_READ \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x000F, METHOD_OUT_DIRECT,  FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_DISK_TYPE \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_CDROM_READ_Q_CHANNEL \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_READ_TOC \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_READ_TOC_EX \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0015, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_RESUME_AUDIO \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_SEEK_AUDIO_MSF \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_SET_VOLUME \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_SIMBAD \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x1003, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_CDROM_STOP_AUDIO \
+  CTL_CODE(IOCTL_CDROM_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+
+#define MAXIMUM_NUMBER_TRACKS             100
+#define MAXIMUM_CDROM_SIZE                804
+#define MINIMUM_CDROM_READ_TOC_EX_SIZE    2
+
+typedef struct _TRACK_DATA {
+  UCHAR  Reserved;
+  UCHAR  Control : 4;
+  UCHAR  Adr : 4;
+  UCHAR  TrackNumber;
+  UCHAR  Reserved1;
+  UCHAR  Address[4];
+} TRACK_DATA, *PTRACK_DATA;
+
+/* CDROM_DISK_DATA.DiskData flags */
+#define CDROM_DISK_AUDIO_TRACK            0x00000001
+#define CDROM_DISK_DATA_TRACK             0x00000002
+
+typedef struct _CDROM_DISK_DATA {
+  ULONG  DiskData;
+} CDROM_DISK_DATA, *PCDROM_DISK_DATA;
+
+typedef struct _CDROM_PLAY_AUDIO_MSF {
+  UCHAR  StartingM;
+  UCHAR  StartingS;
+  UCHAR  StartingF;
+  UCHAR  EndingM;
+  UCHAR  EndingS;
+  UCHAR  EndingF;
+} CDROM_PLAY_AUDIO_MSF, *PCDROM_PLAY_AUDIO_MSF;
+
+/* CDROM_READ_TOC_EX.Format constants */
+#define CDROM_READ_TOC_EX_FORMAT_TOC      0x00
+#define CDROM_READ_TOC_EX_FORMAT_SESSION  0x01
+#define CDROM_READ_TOC_EX_FORMAT_FULL_TOC 0x02
+#define CDROM_READ_TOC_EX_FORMAT_PMA      0x03
+#define CDROM_READ_TOC_EX_FORMAT_ATIP     0x04
+#define CDROM_READ_TOC_EX_FORMAT_CDTEXT   0x05
+
+typedef struct _CDROM_READ_TOC_EX {
+  UCHAR  Format : 4;
+  UCHAR  Reserved1 : 3;
+  UCHAR  Msf : 1;
+  UCHAR  SessionTrack;
+  UCHAR  Reserved2;
+  UCHAR  Reserved3;
+} CDROM_READ_TOC_EX, *PCDROM_READ_TOC_EX;
+
+typedef struct _CDROM_SEEK_AUDIO_MSF {
+  UCHAR  M;
+  UCHAR  S;
+  UCHAR  F;
+} CDROM_SEEK_AUDIO_MSF, *PCDROM_SEEK_AUDIO_MSF;
+
+/* CDROM_SUB_Q_DATA_FORMAT.Format constants */
+#define IOCTL_CDROM_SUB_Q_CHANNEL         0x00
+#define IOCTL_CDROM_CURRENT_POSITION      0x01
+#define IOCTL_CDROM_MEDIA_CATALOG         0x02
+#define IOCTL_CDROM_TRACK_ISRC            0x03
+
+typedef struct _CDROM_SUB_Q_DATA_FORMAT {
+  UCHAR Format;
+  UCHAR Track;
+} CDROM_SUB_Q_DATA_FORMAT, *PCDROM_SUB_Q_DATA_FORMAT;
+
+typedef struct _CDROM_TOC {
+  UCHAR  Length[2];
+  UCHAR  FirstTrack;
+  UCHAR  LastTrack;
+  TRACK_DATA  TrackData[MAXIMUM_NUMBER_TRACKS];
+} CDROM_TOC, *PCDROM_TOC;
+
+#define CDROM_TOC_SIZE sizeof(CDROM_TOC)
+
+typedef struct _CDROM_TOC_SESSION_DATA {
+  UCHAR Length[2];
+  UCHAR FirstCompleteSession;
+  UCHAR LastCompleteSession;
+  TRACK_DATA TrackData[1];
+} CDROM_TOC_SESSION_DATA, *PCDROM_TOC_SESSION_DATA;
+
+typedef struct _CDROM_TOC_ATIP_DATA_BLOCK {
+  UCHAR  CdrwReferenceSpeed : 3;
+  UCHAR  Reserved3 : 1;
+  UCHAR  WritePower : 3;
+  UCHAR  True1 : 1;
+  UCHAR  Reserved4 : 6;
+  UCHAR  UnrestrictedUse : 1;
+  UCHAR  Reserved5 : 1;
+  UCHAR  A3Valid : 1;
+  UCHAR  A2Valid : 1;
+  UCHAR  A1Valid : 1;
+  UCHAR  Reserved6 : 3;
+  UCHAR  IsCdrw : 1;
+  UCHAR  True2 : 1;
+  UCHAR  Reserved7;
+  UCHAR  LeadInMsf[3];
+  UCHAR  Reserved8;
+  UCHAR  LeadOutMsf[3];
+  UCHAR  Reserved9;
+  UCHAR  A1Values[3];
+  UCHAR  Reserved10;
+  UCHAR  A2Values[3];
+  UCHAR  Reserved11;
+  UCHAR  A3Values[3];
+  UCHAR  Reserved12;
+} CDROM_TOC_ATIP_DATA_BLOCK, *PCDROM_TOC_ATIP_DATA_BLOCK;
+
+typedef struct _CDROM_TOC_ATIP_DATA {
+  UCHAR  Length[2];
+  UCHAR  Reserved1;
+  UCHAR  Reserved2;
+  CDROM_TOC_ATIP_DATA_BLOCK  Descriptors[1];
+} CDROM_TOC_ATIP_DATA, *PCDROM_TOC_ATIP_DATA;
+
+/* CDROM_TOC_CD_TEXT_DATA_BLOCK.PackType constants */
+#define CDROM_CD_TEXT_PACK_ALBUM_NAME 0x80
+#define CDROM_CD_TEXT_PACK_PERFORMER  0x81
+#define CDROM_CD_TEXT_PACK_SONGWRITER 0x82
+#define CDROM_CD_TEXT_PACK_COMPOSER   0x83
+#define CDROM_CD_TEXT_PACK_ARRANGER   0x84
+#define CDROM_CD_TEXT_PACK_MESSAGES   0x85
+#define CDROM_CD_TEXT_PACK_DISC_ID    0x86
+#define CDROM_CD_TEXT_PACK_GENRE      0x87
+#define CDROM_CD_TEXT_PACK_TOC_INFO   0x88
+#define CDROM_CD_TEXT_PACK_TOC_INFO2  0x89
+#define CDROM_CD_TEXT_PACK_UPC_EAN    0x8e
+#define CDROM_CD_TEXT_PACK_SIZE_INFO  0x8f
+
+#define _ANONYMOUS_UNION
+typedef struct _CDROM_TOC_CD_TEXT_DATA_BLOCK {
+  UCHAR  PackType;
+  UCHAR  TrackNumber : 7;
+  UCHAR  ExtensionFlag : 1;
+  UCHAR  SequenceNumber;
+  UCHAR  CharacterPosition : 4;
+  UCHAR  BlockNumber : 3;
+  UCHAR  Unicode : 1;
+  _ANONYMOUS_UNION union {
+    UCHAR  Text[12];
+    WCHAR  WText[6];
+  } DUMMYUNIONNAME;
+  UCHAR  CRC[2];
+} CDROM_TOC_CD_TEXT_DATA_BLOCK, *PCDROM_TOC_CD_TEXT_DATA_BLOCK;
+
+typedef struct _CDROM_TOC_CD_TEXT_DATA {
+  UCHAR  Length[2];
+  UCHAR  Reserved1;
+  UCHAR  Reserved2;
+  CDROM_TOC_CD_TEXT_DATA_BLOCK  Descriptors[1];
+} CDROM_TOC_CD_TEXT_DATA, *PCDROM_TOC_CD_TEXT_DATA;
+
+/* CDROM_TOC_FULL_TOC_DATA_BLOCK.Adr constants */
+#define ADR_NO_MODE_INFORMATION           0x0
+#define ADR_ENCODES_CURRENT_POSITION      0x1
+#define ADR_ENCODES_MEDIA_CATALOG         0x2
+#define ADR_ENCODES_ISRC                  0x3
+
+typedef struct _CDROM_TOC_FULL_TOC_DATA_BLOCK {
+  UCHAR  SessionNumber;
+  UCHAR  Control : 4;
+  UCHAR  Adr : 4;
+  UCHAR  Reserved1;
+  UCHAR  Point;
+  UCHAR  MsfExtra[3];
+  UCHAR  Zero;
+  UCHAR  Msf[3];
+} CDROM_TOC_FULL_TOC_DATA_BLOCK, *PCDROM_TOC_FULL_TOC_DATA_BLOCK;
+
+typedef struct _CDROM_TOC_FULL_TOC_DATA {
+  UCHAR  Length[2];
+  UCHAR  FirstCompleteSession;
+  UCHAR  LastCompleteSession;
+  CDROM_TOC_FULL_TOC_DATA_BLOCK  Descriptors[1];
+} CDROM_TOC_FULL_TOC_DATA, *PCDROM_TOC_FULL_TOC_DATA;
+
+typedef struct _CDROM_TOC_PMA_DATA {
+  UCHAR  Length[2];
+  UCHAR  Reserved1;
+  UCHAR  Reserved2;
+  CDROM_TOC_FULL_TOC_DATA_BLOCK  Descriptors[1];
+} CDROM_TOC_PMA_DATA, *PCDROM_TOC_PMA_DATA;
+
+/* SUB_Q_HEADER.AudioStatus constants */
+#define AUDIO_STATUS_NOT_SUPPORTED  0x00
+#define AUDIO_STATUS_IN_PROGRESS    0x11
+#define AUDIO_STATUS_PAUSED         0x12
+#define AUDIO_STATUS_PLAY_COMPLETE  0x13
+#define AUDIO_STATUS_PLAY_ERROR     0x14
+#define AUDIO_STATUS_NO_STATUS      0x15
+
+typedef struct _SUB_Q_HEADER {
+  UCHAR  Reserved;
+  UCHAR  AudioStatus;
+  UCHAR  DataLength[2];
+} SUB_Q_HEADER, *PSUB_Q_HEADER;
+
+typedef struct _SUB_Q_MEDIA_CATALOG_NUMBER {
+  SUB_Q_HEADER  Header;
+  UCHAR  FormatCode;
+  UCHAR  Reserved[3];
+  UCHAR  Reserved1 : 7;
+  UCHAR  Mcval :1;
+  UCHAR  MediaCatalog[15];
+} SUB_Q_MEDIA_CATALOG_NUMBER, *PSUB_Q_MEDIA_CATALOG_NUMBER;
+
+typedef struct _SUB_Q_TRACK_ISRC {
+  SUB_Q_HEADER  Header;
+  UCHAR  FormatCode;
+  UCHAR  Reserved0;
+  UCHAR  Track;
+  UCHAR  Reserved1;
+  UCHAR  Reserved2 : 7;
+  UCHAR  Tcval : 1;
+  UCHAR  TrackIsrc[15];
+} SUB_Q_TRACK_ISRC, *PSUB_Q_TRACK_ISRC;
+
+typedef struct _SUB_Q_CURRENT_POSITION {
+  SUB_Q_HEADER  Header;
+  UCHAR  FormatCode;
+  UCHAR  Control : 4;
+  UCHAR  ADR : 4;
+  UCHAR  TrackNumber;
+  UCHAR  IndexNumber;
+  UCHAR  AbsoluteAddress[4];
+  UCHAR  TrackRelativeAddress[4];
+} SUB_Q_CURRENT_POSITION, *PSUB_Q_CURRENT_POSITION;
+
+typedef union _SUB_Q_CHANNEL_DATA {
+  SUB_Q_CURRENT_POSITION  CurrentPosition;
+  SUB_Q_MEDIA_CATALOG_NUMBER  MediaCatalog;
+  SUB_Q_TRACK_ISRC  TrackIsrc;
+} SUB_Q_CHANNEL_DATA, *PSUB_Q_CHANNEL_DATA;
+
+/* CDROM_AUDIO_CONTROL.LbaFormat constants */
+#define AUDIO_WITH_PREEMPHASIS            0x1
+#define DIGITAL_COPY_PERMITTED            0x2
+#define AUDIO_DATA_TRACK                  0x4
+#define TWO_FOUR_CHANNEL_AUDIO            0x8
+
+typedef struct _CDROM_AUDIO_CONTROL {
+	UCHAR  LbaFormat;
+	USHORT  LogicalBlocksPerSecond;
+} CDROM_AUDIO_CONTROL, *PCDROM_AUDIO_CONTROL;
+
+typedef struct _VOLUME_CONTROL {
+  UCHAR  PortVolume[4];
+} VOLUME_CONTROL, *PVOLUME_CONTROL;
+
+typedef enum _TRACK_MODE_TYPE {
+	YellowMode2,
+	XAForm2,
+	CDDA
+} TRACK_MODE_TYPE, *PTRACK_MODE_TYPE;
+
+typedef struct __RAW_READ_INFO {
+	LARGE_INTEGER  DiskOffset;
+	ULONG  SectorCount;
+	TRACK_MODE_TYPE  TrackMode;
+} RAW_READ_INFO, *PRAW_READ_INFO;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NTDDCDRM_ */
diff -Nru -x '*~' kdewin-0.5.6.orig/include/ntddcdvd.h kdewin-0.5.6/include/ntddcdvd.h
--- kdewin-0.5.6.orig/include/ntddcdvd.h	1970-01-01 01:00:00.000000000 +0100
+++ kdewin-0.5.6/include/ntddcdvd.h	2013-05-30 22:02:10.791259400 +0200
@@ -0,0 +1,215 @@
+/*
+ * ntddcdvd.h
+ *
+ * DVD IOCTL interface.
+ *
+ * This file is part of the kdewin package and is originally from the mingw-w64 w32api package.
+ *
+ * Contributors:
+ *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
+ *   Modified by Patrick Spendrin <ps_ml@gmx.de>
+ *
+ * THIS SOFTWARE IS NOT COPYRIGHTED
+ *
+ * This source code is offered for use in the public domain. You may
+ * use, modify or distribute it freely.
+ *
+ * This code is distributed in the hope that it will be useful but
+ * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
+ * DISCLAIMED. This includes but is not limited to warranties of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+#ifndef _NTDDCDVD_
+#define _NTDDCDVD_
+
+#include "ntddstor.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IOCTL_DVD_BASE                    FILE_DEVICE_DVD
+
+#define IOCTL_STORAGE_SET_READ_AHEAD \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0100, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_DVD_END_SESSION \
+  CTL_CODE(IOCTL_DVD_BASE, 0x0403, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_DVD_GET_REGION \
+  CTL_CODE(IOCTL_DVD_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_DVD_SEND_KEY2 \
+  CTL_CODE(IOCTL_DVD_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
+
+#define IOCTL_DVD_READ_KEY \
+  CTL_CODE(IOCTL_DVD_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_DVD_READ_STRUCTURE \
+  CTL_CODE(IOCTL_DVD_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_DVD_SEND_KEY \
+  CTL_CODE(IOCTL_DVD_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_DVD_START_SESSION \
+  CTL_CODE(IOCTL_DVD_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_DVD_SET_READ_AHEAD \
+  CTL_CODE(IOCTL_DVD_BASE, 0x0404, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+
+typedef ULONG DVD_SESSION_ID, *PDVD_SESSION_ID;
+
+typedef struct _STORAGE_SET_READ_AHEAD {
+	LARGE_INTEGER  TriggerAddress;
+	LARGE_INTEGER  TargetAddress;
+} STORAGE_SET_READ_AHEAD, *PSTORAGE_SET_READ_AHEAD;
+
+typedef enum DVD_STRUCTURE_FORMAT {
+  DvdPhysicalDescriptor,
+  DvdCopyrightDescriptor,
+  DvdDiskKeyDescriptor,
+  DvdBCADescriptor,
+  DvdManufacturerDescriptor,
+  DvdMaxDescriptor
+} DVD_STRUCTURE_FORMAT, *PDVD_STRUCTURE_FORMAT;
+
+#include <pshpack1.h>
+typedef struct DVD_READ_STRUCTURE {
+  LARGE_INTEGER  BlockByteOffset;
+  DVD_STRUCTURE_FORMAT  Format;
+  DVD_SESSION_ID  SessionId;
+  UCHAR  LayerNumber;
+} DVD_READ_STRUCTURE, *PDVD_READ_STRUCTURE;
+#include <poppack.h>
+
+typedef struct _DVD_DESCRIPTOR_HEADER {
+    USHORT Length;
+    UCHAR Reserved[2];
+    UCHAR Data[0];
+} DVD_DESCRIPTOR_HEADER, *PDVD_DESCRIPTOR_HEADER;
+
+#include <pshpack1.h>
+typedef struct _DVD_LAYER_DESCRIPTOR {
+  UCHAR  BookVersion : 4;
+  UCHAR  BookType : 4;
+  UCHAR  MinimumRate : 4;
+  UCHAR  DiskSize : 4;
+  UCHAR  LayerType : 4;
+  UCHAR  TrackPath : 1;
+  UCHAR  NumberOfLayers : 2;
+  UCHAR  Reserved1 : 1;
+  UCHAR  TrackDensity : 4;
+  UCHAR  LinearDensity : 4;
+  ULONG  StartingDataSector;
+  ULONG  EndDataSector;
+  ULONG  EndLayerZeroSector;
+  UCHAR  Reserved5 : 7;
+  UCHAR  BCAFlag : 1;
+  UCHAR  Reserved6;
+} DVD_LAYER_DESCRIPTOR, *PDVD_LAYER_DESCRIPTOR;
+#include <poppack.h>
+
+typedef struct _DVD_COPYRIGHT_DESCRIPTOR {
+  UCHAR  CopyrightProtectionType;
+  UCHAR  RegionManagementInformation;
+  USHORT  Reserved;
+} DVD_COPYRIGHT_DESCRIPTOR, *PDVD_COPYRIGHT_DESCRIPTOR;
+
+typedef struct _DVD_DISK_KEY_DESCRIPTOR {
+  UCHAR  DiskKeyData[2048];
+} DVD_DISK_KEY_DESCRIPTOR, *PDVD_DISK_KEY_DESCRIPTOR;
+
+typedef enum _DVD_KEY_TYPE {
+	DvdChallengeKey = 0x01,
+	DvdBusKey1,
+	DvdBusKey2,
+	DvdTitleKey,
+	DvdAsf,
+	DvdSetRpcKey = 0x6,
+	DvdGetRpcKey = 0x8,
+	DvdDiskKey = 0x80,
+	DvdInvalidateAGID = 0x3f
+} DVD_KEY_TYPE;
+
+typedef struct _DVD_COPY_PROTECT_KEY {
+	ULONG  KeyLength;
+	DVD_SESSION_ID  SessionId;
+	DVD_KEY_TYPE  KeyType;
+	ULONG  KeyFlags;
+	union {
+		HANDLE  FileHandle;
+		LARGE_INTEGER  TitleOffset;
+	} Parameters;
+	UCHAR  KeyData[0];
+} DVD_COPY_PROTECT_KEY, *PDVD_COPY_PROTECT_KEY;
+
+#define DVD_CHALLENGE_KEY_LENGTH          (12 + sizeof(DVD_COPY_PROTECT_KEY))
+#define DVD_BUS_KEY_LENGTH                (8 + sizeof(DVD_COPY_PROTECT_KEY))
+#define DVD_TITLE_KEY_LENGTH              (8 + sizeof(DVD_COPY_PROTECT_KEY))
+#define DVD_DISK_KEY_LENGTH               (2048 + sizeof(DVD_COPY_PROTECT_KEY))
+#define DVD_RPC_KEY_LENGTH                (sizeof(DVD_RPC_KEY) + sizeof(DVD_COPY_PROTECT_KEY))
+#define DVD_SET_RPC_KEY_LENGTH            (sizeof(DVD_SET_RPC_KEY) + sizeof(DVD_COPY_PROTECT_KEY))
+#define DVD_ASF_LENGTH                    (sizeof(DVD_ASF) + sizeof(DVD_COPY_PROTECT_KEY))
+
+#define DVD_END_ALL_SESSIONS              ((DVD_SESSION_ID) 0xffffffff)
+
+
+#define DVD_CGMS_RESERVED_MASK            0x00000078
+
+#define DVD_CGMS_COPY_PROTECT_MASK        0x00000018
+#define DVD_CGMS_COPY_PERMITTED           0x00000000
+#define DVD_CGMS_COPY_ONCE                0x00000010
+#define DVD_CGMS_NO_COPY                  0x00000018
+
+#define DVD_COPYRIGHT_MASK                0x00000040
+#define DVD_NOT_COPYRIGHTED               0x00000000
+#define DVD_COPYRIGHTED                   0x00000040
+
+#define DVD_SECTOR_PROTECT_MASK           0x00000020
+#define DVD_SECTOR_NOT_PROTECTED          0x00000000
+#define DVD_SECTOR_PROTECTED              0x00000020
+
+
+typedef struct _DVD_BCA_DESCRIPTOR {
+  UCHAR  BCAInformation[0];
+} DVD_BCA_DESCRIPTOR, *PDVD_BCA_DESCRIPTOR;
+
+typedef struct _DVD_MANUFACTURER_DESCRIPTOR {
+  UCHAR  ManufacturingInformation[2048];
+} DVD_MANUFACTURER_DESCRIPTOR, *PDVD_MANUFACTURER_DESCRIPTOR;
+
+typedef struct _DVD_RPC_KEY {
+  UCHAR  UserResetsAvailable : 3;
+  UCHAR  ManufacturerResetsAvailable : 3;
+  UCHAR  TypeCode : 2;
+  UCHAR  RegionMask;
+  UCHAR  RpcScheme;
+  UCHAR  Reserved2[1];
+} DVD_RPC_KEY, *PDVD_RPC_KEY;
+
+typedef struct _DVD_SET_RPC_KEY {
+  UCHAR  PreferredDriveRegionCode;
+  UCHAR  Reserved[3];
+} DVD_SET_RPC_KEY, *PDVD_SET_RPC_KEY;
+
+typedef struct _DVD_ASF {
+  UCHAR  Reserved0[3];
+  UCHAR  SuccessFlag : 1;
+  UCHAR  Reserved1 : 7;
+} DVD_ASF, *PDVD_ASF;
+
+typedef struct _DVD_REGION {
+	UCHAR  CopySystem;
+	UCHAR  RegionData;
+	UCHAR  SystemRegion;
+	UCHAR  ResetCount;
+} DVD_REGION, *PDVD_REGION;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NTDDCDVD_ */
diff -Nru -x '*~' kdewin-0.5.6.orig/include/ntddmmc.h kdewin-0.5.6/include/ntddmmc.h
--- kdewin-0.5.6.orig/include/ntddmmc.h	1970-01-01 01:00:00.000000000 +0100
+++ kdewin-0.5.6/include/ntddmmc.h	2013-05-30 22:02:10.791259400 +0200
@@ -0,0 +1,663 @@
+/**
+ * This file has no copyright assigned and is placed in the Public Domain.
+ * This file is part of the kdewin package and is originally from the mingw-w64 w32api package.
+ *   Modified by Patrick Spendrin <ps_ml@gmx.de>
+ * This file is part of the ReactOS PSDK package.
+ * No warranty is given; refer to the file DISCLAIMER within this package.
+ */
+
+#pragma once
+
+#define __NTDDMMC__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL          0x0
+#define SCSI_GET_CONFIGURATION_REQUEST_TYPE_CURRENT      0x1
+#define SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE          0x2
+
+typedef struct _GET_CONFIGURATION_HEADER {
+  UCHAR DataLength[4];
+  UCHAR Reserved[2];
+  UCHAR CurrentProfile[2];
+#if !defined(__midl) && !defined(__WIDL__)
+  UCHAR Data[1];
+#endif
+} GET_CONFIGURATION_HEADER, *PGET_CONFIGURATION_HEADER;
+
+typedef struct _FEATURE_HEADER {
+  UCHAR FeatureCode[2];
+  UCHAR Current:1;
+  UCHAR Persistent:1;
+  UCHAR Version:4;
+  UCHAR Reserved0:2;
+  UCHAR AdditionalLength;
+} FEATURE_HEADER, *PFEATURE_HEADER;
+
+typedef enum _FEATURE_PROFILE_TYPE {
+  ProfileInvalid = 0x0000,
+  ProfileNonRemovableDisk = 0x0001,
+  ProfileRemovableDisk = 0x0002,
+  ProfileMOErasable = 0x0003,
+  ProfileMOWriteOnce = 0x0004,
+  ProfileAS_MO = 0x0005,
+  ProfileCdrom = 0x0008,
+  ProfileCdRecordable = 0x0009,
+  ProfileCdRewritable = 0x000a,
+  ProfileDvdRom = 0x0010,
+  ProfileDvdRecordable = 0x0011,
+  ProfileDvdRam = 0x0012,
+  ProfileDvdRewritable = 0x0013,
+  ProfileDvdRWSequential = 0x0014,
+  ProfileDvdDashRDualLayer = 0x0015,
+  ProfileDvdDashRLayerJump = 0x0016,
+  ProfileDvdPlusRW = 0x001A,
+  ProfileDvdPlusR = 0x001B,
+  ProfileDDCdrom = 0x0020,
+  ProfileDDCdRecordable = 0x0021,
+  ProfileDDCdRewritable = 0x0022,
+  ProfileDvdPlusRWDualLayer = 0x002A,
+  ProfileDvdPlusRDualLayer = 0x002B,
+  ProfileBDRom = 0x0040,
+  ProfileBDRSequentialWritable = 0x0041,
+  ProfileBDRRandomWritable = 0x0042,
+  ProfileBDRewritable = 0x0043,
+  ProfileHDDVDRom = 0x0050,
+  ProfileHDDVDRecordable = 0x0051,
+  ProfileHDDVDRam = 0x0052,
+  ProfileHDDVDRewritable = 0x0053,
+  ProfileHDDVDRDualLayer = 0x0058,
+  ProfileHDDVDRWDualLayer = 0x005A,
+  ProfileNonStandard = 0xffff
+} FEATURE_PROFILE_TYPE, *PFEATURE_PROFILE_TYPE;
+
+typedef enum _FEATURE_NUMBER {
+  FeatureProfileList = 0x0000,
+  FeatureCore = 0x0001,
+  FeatureMorphing = 0x0002,
+  FeatureRemovableMedium = 0x0003,
+  FeatureWriteProtect = 0x0004,
+  FeatureRandomReadable = 0x0010,
+  FeatureMultiRead = 0x001D,
+  FeatureCdRead = 0x001E,
+  FeatureDvdRead = 0x001F,
+  FeatureRandomWritable = 0x0020,
+  FeatureIncrementalStreamingWritable = 0x0021,
+  FeatureSectorErasable = 0x0022,
+  FeatureFormattable = 0x0023,
+  FeatureDefectManagement = 0x0024,
+  FeatureWriteOnce = 0x0025,
+  FeatureRestrictedOverwrite = 0x0026,
+  FeatureCdrwCAVWrite = 0x0027,
+  FeatureMrw = 0x0028,
+  FeatureEnhancedDefectReporting = 0x0029,
+  FeatureDvdPlusRW = 0x002A,
+  FeatureDvdPlusR = 0x002B,
+  FeatureRigidRestrictedOverwrite = 0x002C,
+  FeatureCdTrackAtOnce = 0x002D,
+  FeatureCdMastering = 0x002E,
+  FeatureDvdRecordableWrite = 0x002F,
+  FeatureDDCDRead = 0x0030,
+  FeatureDDCDRWrite = 0x0031,
+  FeatureDDCDRWWrite = 0x0032,
+  FeatureLayerJumpRecording = 0x0033,
+  FeatureCDRWMediaWriteSupport = 0x0037,
+  FeatureBDRPseudoOverwrite = 0x0038,
+  FeatureDvdPlusRWDualLayer = 0x003A,
+  FeatureDvdPlusRDualLayer = 0x003B,
+  FeatureBDRead = 0x0040,
+  FeatureBDWrite = 0x0041,
+  FeatureTSR = 0x0042,
+  FeatureHDDVDRead = 0x0050,
+  FeatureHDDVDWrite = 0x0051,
+  FeatureHybridDisc = 0x0080,
+  FeaturePowerManagement = 0x0100,
+  FeatureSMART = 0x0101,
+  FeatureEmbeddedChanger = 0x0102,
+  FeatureCDAudioAnalogPlay = 0x0103,
+  FeatureMicrocodeUpgrade = 0x0104,
+  FeatureTimeout = 0x0105,
+  FeatureDvdCSS = 0x0106,
+  FeatureRealTimeStreaming = 0x0107,
+  FeatureLogicalUnitSerialNumber = 0x0108,
+  FeatureMediaSerialNumber = 0x0109,
+  FeatureDiscControlBlocks = 0x010A,
+  FeatureDvdCPRM = 0x010B,
+  FeatureFirmwareDate = 0x010C,
+  FeatureAACS = 0x010D,
+  FeatureVCPS = 0x0110,
+} FEATURE_NUMBER, *PFEATURE_NUMBER;
+
+typedef struct _FEATURE_DATA_PROFILE_LIST_EX {
+  UCHAR ProfileNumber[2];
+  UCHAR Current:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2;
+} FEATURE_DATA_PROFILE_LIST_EX, *PFEATURE_DATA_PROFILE_LIST_EX;
+
+typedef struct _FEATURE_DATA_PROFILE_LIST {
+  FEATURE_HEADER Header;
+#if !defined(__midl) && !defined(__WIDL__)
+  FEATURE_DATA_PROFILE_LIST_EX Profiles[1];
+#endif
+} FEATURE_DATA_PROFILE_LIST, *PFEATURE_DATA_PROFILE_LIST;
+
+typedef struct _FEATURE_DATA_CORE {
+  FEATURE_HEADER Header;
+  UCHAR PhysicalInterface[4];
+  UCHAR DeviceBusyEvent:1;
+  UCHAR INQUIRY2:1;
+  UCHAR Reserved1:6;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_CORE, *PFEATURE_DATA_CORE;
+
+typedef struct _FEATURE_DATA_MORPHING {
+  FEATURE_HEADER Header;
+  UCHAR Asynchronous:1;
+  UCHAR OCEvent:1;
+  UCHAR Reserved01:6;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_MORPHING, *PFEATURE_DATA_MORPHING;
+
+typedef struct _FEATURE_DATA_REMOVABLE_MEDIUM {
+  FEATURE_HEADER Header;
+  UCHAR Lockable:1;
+  UCHAR Reserved1:1;
+  UCHAR DefaultToPrevent:1;
+  UCHAR Eject:1;
+  UCHAR Reserved2:1;
+  UCHAR LoadingMechanism:3;
+  UCHAR Reserved3[3];
+} FEATURE_DATA_REMOVABLE_MEDIUM, *PFEATURE_DATA_REMOVABLE_MEDIUM;
+
+typedef struct _FEATURE_DATA_WRITE_PROTECT {
+  FEATURE_HEADER Header;
+  UCHAR SupportsSWPPBit:1;
+  UCHAR SupportsPersistentWriteProtect:1;
+  UCHAR WriteInhibitDCB:1;
+  UCHAR DiscWriteProtectPAC:1;
+  UCHAR Reserved01:4;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_WRITE_PROTECT, *PFEATURE_DATA_WRITE_PROTECT;
+
+typedef struct _FEATURE_DATA_RANDOM_READABLE {
+  FEATURE_HEADER Header;
+  UCHAR LogicalBlockSize[4];
+  UCHAR Blocking[2];
+  UCHAR ErrorRecoveryPagePresent:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2;
+} FEATURE_DATA_RANDOM_READABLE, *PFEATURE_DATA_RANDOM_READABLE;
+
+typedef struct _FEATURE_DATA_MULTI_READ {
+  FEATURE_HEADER Header;
+} FEATURE_DATA_MULTI_READ, *PFEATURE_DATA_MULTI_READ;
+
+typedef struct _FEATURE_DATA_CD_READ {
+  FEATURE_HEADER Header;
+  UCHAR CDText:1;
+  UCHAR C2ErrorData:1;
+  UCHAR Reserved01:5;
+  UCHAR DigitalAudioPlay:1;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_CD_READ, *PFEATURE_DATA_CD_READ;
+
+typedef struct _FEATURE_DATA_DVD_READ {
+  FEATURE_HEADER Header;
+  UCHAR Multi110:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2;
+  UCHAR DualDashR:1;
+  UCHAR Reserved3:7;
+  UCHAR Reserved4;
+} FEATURE_DATA_DVD_READ, *PFEATURE_DATA_DVD_READ;
+
+typedef struct _FEATURE_DATA_RANDOM_WRITABLE {
+  FEATURE_HEADER Header;
+  UCHAR LastLBA[4];
+  UCHAR LogicalBlockSize[4];
+  UCHAR Blocking[2];
+  UCHAR ErrorRecoveryPagePresent:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2;
+} FEATURE_DATA_RANDOM_WRITABLE, *PFEATURE_DATA_RANDOM_WRITABLE;
+
+typedef struct _FEATURE_DATA_INCREMENTAL_STREAMING_WRITABLE {
+  FEATURE_HEADER Header;
+  UCHAR DataTypeSupported[2];
+  UCHAR BufferUnderrunFree:1;
+  UCHAR AddressModeReservation:1;
+  UCHAR TrackRessourceInformation:1;
+  UCHAR Reserved01:5;
+  UCHAR NumberOfLinkSizes;
+#if !defined(__midl) && !defined(__WIDL__)
+  UCHAR LinkSize[1];
+#endif
+} FEATURE_DATA_INCREMENTAL_STREAMING_WRITABLE, *PFEATURE_DATA_INCREMENTAL_STREAMING_WRITABLE;
+
+typedef struct _FEATURE_DATA_SECTOR_ERASABLE {
+  FEATURE_HEADER Header;
+} FEATURE_DATA_SECTOR_ERASABLE, *PFEATURE_DATA_SECTOR_ERASABLE;
+
+typedef struct _FEATURE_DATA_FORMATTABLE {
+  FEATURE_HEADER Header;
+  UCHAR FullCertification:1;
+  UCHAR QuickCertification:1;
+  UCHAR SpareAreaExpansion:1;
+  UCHAR RENoSpareAllocated:1;
+  UCHAR Reserved1:4;
+  UCHAR Reserved2[3];
+  UCHAR RRandomWritable:1;
+  UCHAR Reserved3:7;
+  UCHAR Reserved4[3];
+} FEATURE_DATA_FORMATTABLE, *PFEATURE_DATA_FORMATTABLE;
+
+typedef struct _FEATURE_DATA_DEFECT_MANAGEMENT {
+  FEATURE_HEADER Header;
+  UCHAR Reserved1:7;
+  UCHAR SupplimentalSpareArea:1;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_DEFECT_MANAGEMENT, *PFEATURE_DATA_DEFECT_MANAGEMENT;
+
+typedef struct _FEATURE_DATA_WRITE_ONCE {
+  FEATURE_HEADER Header;
+  UCHAR LogicalBlockSize[4];
+  UCHAR Blocking[2];
+  UCHAR ErrorRecoveryPagePresent:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2;
+} FEATURE_DATA_WRITE_ONCE, *PFEATURE_DATA_WRITE_ONCE;
+
+typedef struct _FEATURE_DATA_RESTRICTED_OVERWRITE {
+  FEATURE_HEADER Header;
+} FEATURE_DATA_RESTRICTED_OVERWRITE, *PFEATURE_DATA_RESTRICTED_OVERWRITE;
+
+typedef struct _FEATURE_DATA_CDRW_CAV_WRITE {
+  FEATURE_HEADER Header;
+  UCHAR Reserved1[4];
+} FEATURE_DATA_CDRW_CAV_WRITE, *PFEATURE_DATA_CDRW_CAV_WRITE;
+
+typedef struct _FEATURE_DATA_MRW {
+  FEATURE_HEADER Header;
+  UCHAR Write:1;
+  UCHAR DvdPlusRead:1;
+  UCHAR DvdPlusWrite:1;
+  UCHAR Reserved01:5;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_MRW, *PFEATURE_DATA_MRW;
+
+typedef struct _FEATURE_ENHANCED_DEFECT_REPORTING {
+  FEATURE_HEADER Header;
+  UCHAR DRTDMSupported:1;
+  UCHAR Reserved0:7;
+  UCHAR NumberOfDBICacheZones;
+  UCHAR NumberOfEntries[2];
+} FEATURE_ENHANCED_DEFECT_REPORTING, *PFEATURE_ENHANCED_DEFECT_REPORTING;
+
+typedef struct _FEATURE_DATA_DVD_PLUS_RW {
+  FEATURE_HEADER Header;
+  UCHAR Write:1;
+  UCHAR Reserved1:7;
+  UCHAR CloseOnly:1;
+  UCHAR QuickStart:1;
+  UCHAR Reserved02:6;
+  UCHAR Reserved03[2];
+} FEATURE_DATA_DVD_PLUS_RW, *PFEATURE_DATA_DVD_PLUS_RW;
+
+typedef struct _FEATURE_DATA_DVD_PLUS_R {
+  FEATURE_HEADER Header;
+  UCHAR Write:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_DVD_PLUS_R, *PFEATURE_DATA_DVD_PLUS_R;
+
+typedef struct _FEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE {
+  FEATURE_HEADER Header;
+  UCHAR Blank:1;
+  UCHAR Intermediate:1;
+  UCHAR DefectStatusDataRead:1;
+  UCHAR DefectStatusDataGenerate:1;
+  UCHAR Reserved0:4;
+  UCHAR Reserved1[3];
+} FEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE, *PFEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE;
+
+typedef struct _FEATURE_DATA_CD_TRACK_AT_ONCE {
+  FEATURE_HEADER Header;
+  UCHAR RWSubchannelsRecordable:1;
+  UCHAR CdRewritable:1;
+  UCHAR TestWriteOk:1;
+  UCHAR RWSubchannelPackedOk:1;
+  UCHAR RWSubchannelRawOk:1;
+  UCHAR Reserved1:1;
+  UCHAR BufferUnderrunFree:1;
+  UCHAR Reserved3:1;
+  UCHAR Reserved2;
+  UCHAR DataTypeSupported[2];
+} FEATURE_DATA_CD_TRACK_AT_ONCE, *PFEATURE_DATA_CD_TRACK_AT_ONCE;
+
+typedef struct _FEATURE_DATA_CD_MASTERING {
+  FEATURE_HEADER Header;
+  UCHAR RWSubchannelsRecordable:1;
+  UCHAR CdRewritable:1;
+  UCHAR TestWriteOk:1;
+  UCHAR RawRecordingOk:1;
+  UCHAR RawMultiSessionOk:1;
+  UCHAR SessionAtOnceOk:1;
+  UCHAR BufferUnderrunFree:1;
+  UCHAR Reserved1:1;
+  UCHAR MaximumCueSheetLength[3];
+} FEATURE_DATA_CD_MASTERING, *PFEATURE_DATA_CD_MASTERING;
+
+typedef struct _FEATURE_DATA_DVD_RECORDABLE_WRITE {
+  FEATURE_HEADER Header;
+  UCHAR Reserved1:1;
+  UCHAR DVD_RW:1;
+  UCHAR TestWrite:1;
+  UCHAR RDualLayer:1;
+  UCHAR Reserved02:2;
+  UCHAR BufferUnderrunFree:1;
+  UCHAR Reserved3:1;
+  UCHAR Reserved4[3];
+} FEATURE_DATA_DVD_RECORDABLE_WRITE, *PFEATURE_DATA_DVD_RECORDABLE_WRITE;
+
+typedef struct _FEATURE_DATA_DDCD_READ {
+  FEATURE_HEADER Header;
+} FEATURE_DATA_DDCD_READ, *PFEATURE_DATA_DDCD_READ;
+
+typedef struct _FEATURE_DATA_DDCD_R_WRITE {
+  FEATURE_HEADER Header;
+  UCHAR Reserved1:2;
+  UCHAR TestWrite:1;
+  UCHAR Reserved2:5;
+  UCHAR Reserved3[3];
+} FEATURE_DATA_DDCD_R_WRITE, *PFEATURE_DATA_DDCD_R_WRITE;
+
+typedef struct _FEATURE_DATA_DDCD_RW_WRITE {
+  FEATURE_HEADER Header;
+  UCHAR Blank:1;
+  UCHAR Intermediate:1;
+  UCHAR Reserved1:6;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_DDCD_RW_WRITE, *PFEATURE_DATA_DDCD_RW_WRITE;
+
+typedef struct _FEATURE_DATA_LAYER_JUMP_RECORDING {
+  FEATURE_HEADER Header;
+  UCHAR Reserved0[3];
+  UCHAR NumberOfLinkSizes;
+#if !defined(__midl) && !defined(__WIDL__)
+  UCHAR LinkSizes[1];
+#endif
+} FEATURE_DATA_LAYER_JUMP_RECORDING, *PFEATURE_DATA_LAYER_JUMP_RECORDING;
+
+typedef struct _FEATURE_CD_RW_MEDIA_WRITE_SUPPORT {
+  FEATURE_HEADER Header;
+  UCHAR Reserved1;
+  struct{
+    UCHAR Subtype0:1;
+    UCHAR Subtype1:1;
+    UCHAR Subtype2:1;
+    UCHAR Subtype3:1;
+    UCHAR Subtype4:1;
+    UCHAR Subtype5:1;
+    UCHAR Subtype6:1;
+    UCHAR Subtype7:1;
+  } CDRWMediaSubtypeSupport;
+  UCHAR Reserved2[2];
+} FEATURE_CD_RW_MEDIA_WRITE_SUPPORT, *PFEATURE_CD_RW_MEDIA_WRITE_SUPPORT;
+
+typedef struct _FEATURE_BD_R_PSEUDO_OVERWRITE {
+  FEATURE_HEADER Header;
+  UCHAR Reserved[4];
+} FEATURE_BD_R_PSEUDO_OVERWRITE, *PFEATURE_BD_R_PSEUDO_OVERWRITE;
+
+typedef struct _FEATURE_DATA_DVD_PLUS_RW_DUAL_LAYER {
+  FEATURE_HEADER Header;
+  UCHAR Write:1;
+  UCHAR Reserved1:7;
+  UCHAR CloseOnly:1;
+  UCHAR QuickStart:1;
+  UCHAR Reserved2:6;
+  UCHAR Reserved3[2];
+} FEATURE_DATA_DVD_PLUS_RW_DUAL_LAYER, *PFEATURE_DATA_DVD_PLUS_RW_DUAL_LAYER;
+
+typedef struct _FEATURE_DATA_DVD_PLUS_R_DUAL_LAYER {
+  FEATURE_HEADER Header;
+  UCHAR Write:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_DVD_PLUS_R_DUAL_LAYER, *PFEATURE_DATA_DVD_PLUS_R_DUAL_LAYER;
+
+typedef struct _BD_CLASS_SUPPORT_BITMAP {
+  UCHAR Version8:1;
+  UCHAR Version9:1;
+  UCHAR Version10:1;
+  UCHAR Version11:1;
+  UCHAR Version12:1;
+  UCHAR Version13:1;
+  UCHAR Version14:1;
+  UCHAR Version15:1;
+  UCHAR Version0:1;
+  UCHAR Version1:1;
+  UCHAR Version2:1;
+  UCHAR Version3:1;
+  UCHAR Version4:1;
+  UCHAR Version5:1;
+  UCHAR Version6:1;
+  UCHAR Version7:1;
+} BD_CLASS_SUPPORT_BITMAP, *PBD_CLASS_SUPPORT_BITMAP;
+
+typedef struct _FEATURE_BD_READ {
+  FEATURE_HEADER Header;
+  UCHAR Reserved[4];
+  BD_CLASS_SUPPORT_BITMAP Class0BitmapBDREReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class1BitmapBDREReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class2BitmapBDREReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class3BitmapBDREReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class0BitmapBDRReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class1BitmapBDRReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class2BitmapBDRReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class3BitmapBDRReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class0BitmapBDROMReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class1BitmapBDROMReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class2BitmapBDROMReadSupport;
+  BD_CLASS_SUPPORT_BITMAP Class3BitmapBDROMReadSupport;
+} FEATURE_BD_READ, *PFEATURE_BD_READ;
+
+typedef struct _FEATURE_BD_WRITE {
+  FEATURE_HEADER Header;
+  UCHAR SupportsVerifyNotRequired:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2[3];
+  BD_CLASS_SUPPORT_BITMAP Class0BitmapBDREWriteSupport;
+  BD_CLASS_SUPPORT_BITMAP Class1BitmapBDREWriteSupport;
+  BD_CLASS_SUPPORT_BITMAP Class2BitmapBDREWriteSupport;
+  BD_CLASS_SUPPORT_BITMAP Class3BitmapBDREWriteSupport;
+  BD_CLASS_SUPPORT_BITMAP Class0BitmapBDRWriteSupport;
+  BD_CLASS_SUPPORT_BITMAP Class1BitmapBDRWriteSupport;
+  BD_CLASS_SUPPORT_BITMAP Class2BitmapBDRWriteSupport;
+  BD_CLASS_SUPPORT_BITMAP Class3BitmapBDRWriteSupport;
+} FEATURE_BD_WRITE, *PFEATURE_BD_WRITE;
+
+typedef struct _FEATURE_TSR {
+  FEATURE_HEADER Header;
+} FEATURE_TSR, *PFEATURE_TSR;
+
+typedef struct _FEATURE_DATA_HDDVD_READ {
+  FEATURE_HEADER Header;
+  UCHAR Recordable:1;
+  UCHAR Reserved0:7;
+  UCHAR Reserved1;
+  UCHAR Rewritable:1;
+  UCHAR Reserved2:7;
+  UCHAR Reserved3;
+} FEATURE_DATA_HDDVD_READ, *PFEATURE_DATA_HDDVD_READ;
+
+typedef struct _FEATURE_DATA_HDDVD_WRITE {
+  FEATURE_HEADER Header;
+  UCHAR Recordable:1;
+  UCHAR Reserved0:7;
+  UCHAR Reserved1;
+  UCHAR Rewritable:1;
+  UCHAR Reserved2:7;
+  UCHAR Reserved3;
+} FEATURE_DATA_HDDVD_WRITE, *PFEATURE_DATA_HDDVD_WRITE;
+
+typedef struct _FEATURE_HYBRID_DISC {
+  FEATURE_HEADER Header;
+  UCHAR ResetImmunity:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2[3];
+} FEATURE_HYBRID_DISC, *PFEATURE_HYBRID_DISC;
+
+typedef struct _FEATURE_DATA_POWER_MANAGEMENT {
+  FEATURE_HEADER Header;
+} FEATURE_DATA_POWER_MANAGEMENT, *PFEATURE_DATA_POWER_MANAGEMENT;
+
+typedef struct _FEATURE_DATA_SMART {
+  FEATURE_HEADER Header;
+  UCHAR FaultFailureReportingPagePresent:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved02[3];
+} FEATURE_DATA_SMART, *PFEATURE_DATA_SMART;
+
+typedef struct _FEATURE_DATA_EMBEDDED_CHANGER {
+  FEATURE_HEADER Header;
+  UCHAR Reserved1:2;
+  UCHAR SupportsDiscPresent:1;
+  UCHAR Reserved2:1;
+  UCHAR SideChangeCapable:1;
+  UCHAR Reserved3:3;
+  UCHAR Reserved4[2];
+  UCHAR HighestSlotNumber:5;
+  UCHAR Reserved:3;
+} FEATURE_DATA_EMBEDDED_CHANGER, *PFEATURE_DATA_EMBEDDED_CHANGER;
+
+typedef struct _FEATURE_DATA_CD_AUDIO_ANALOG_PLAY {
+  FEATURE_HEADER Header;
+  UCHAR SeperateVolume:1;
+  UCHAR SeperateChannelMute:1;
+  UCHAR ScanSupported:1;
+  UCHAR Reserved1:5;
+  UCHAR Reserved2;
+  UCHAR NumerOfVolumeLevels[2];
+} FEATURE_DATA_CD_AUDIO_ANALOG_PLAY, *PFEATURE_DATA_CD_AUDIO_ANALOG_PLAY;
+
+typedef struct _FEATURE_DATA_MICROCODE_UPDATE {
+  FEATURE_HEADER Header;
+  UCHAR M5:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_MICROCODE_UPDATE, *PFEATURE_DATA_MICROCODE_UPDATE;
+
+typedef struct _FEATURE_DATA_TIMEOUT {
+  FEATURE_HEADER Header;
+  UCHAR Group3:1;
+  UCHAR Reserved1:7;
+  UCHAR Reserved2;
+  UCHAR UnitLength[2];
+} FEATURE_DATA_TIMEOUT, *PFEATURE_DATA_TIMEOUT;
+
+typedef struct _FEATURE_DATA_DVD_CSS {
+  FEATURE_HEADER Header;
+  UCHAR Reserved1[3];
+  UCHAR CssVersion;
+} FEATURE_DATA_DVD_CSS, *PFEATURE_DATA_DVD_CSS;
+
+typedef struct _FEATURE_DATA_REAL_TIME_STREAMING {
+  FEATURE_HEADER Header;
+  UCHAR StreamRecording:1;
+  UCHAR WriteSpeedInGetPerf:1;
+  UCHAR WriteSpeedInMP2A:1;
+  UCHAR SetCDSpeed:1;
+  UCHAR ReadBufferCapacityBlock:1;
+  UCHAR Reserved1:3;
+  UCHAR Reserved2[3];
+} FEATURE_DATA_REAL_TIME_STREAMING, *PFEATURE_DATA_REAL_TIME_STREAMING;
+
+typedef struct _FEATURE_DATA_LOGICAL_UNIT_SERIAL_NUMBER {
+  FEATURE_HEADER Header;
+#if !defined(__midl) && !defined(__WIDL__)
+  UCHAR SerialNumber[1];
+#endif
+} FEATURE_DATA_LOGICAL_UNIT_SERIAL_NUMBER, *PFEATURE_DATA_LOGICAL_UNIT_SERIAL_NUMBER;
+
+typedef struct _FEATURE_MEDIA_SERIAL_NUMBER {
+  FEATURE_HEADER Header;
+} FEATURE_MEDIA_SERIAL_NUMBER, *PFEATURE_MEDIA_SERIAL_NUMBER;
+
+typedef struct _FEATURE_DATA_DISC_CONTROL_BLOCKS_EX {
+  UCHAR ContentDescriptor[4];
+} FEATURE_DATA_DISC_CONTROL_BLOCKS_EX, *PFEATURE_DATA_DISC_CONTROL_BLOCKS_EX;
+
+typedef struct _FEATURE_DATA_DISC_CONTROL_BLOCKS {
+  FEATURE_HEADER Header;
+#if !defined(__midl) && !defined(__WIDL__)
+  FEATURE_DATA_DISC_CONTROL_BLOCKS_EX Data[1];
+#endif
+} FEATURE_DATA_DISC_CONTROL_BLOCKS, *PFEATURE_DATA_DISC_CONTROL_BLOCKS;
+
+typedef struct _FEATURE_DATA_DVD_CPRM {
+  FEATURE_HEADER Header;
+  UCHAR Reserved0[3];
+  UCHAR CPRMVersion;
+} FEATURE_DATA_DVD_CPRM, *PFEATURE_DATA_DVD_CPRM;
+
+typedef struct _FEATURE_DATA_FIRMWARE_DATE {
+  FEATURE_HEADER Header;
+  UCHAR Year[4];
+  UCHAR Month[2];
+  UCHAR Day[2];
+  UCHAR Hour[2];
+  UCHAR Minute[2];
+  UCHAR Seconds[2];
+  UCHAR Reserved[2];
+} FEATURE_DATA_FIRMWARE_DATE, *PFEATURE_DATA_FIRMWARE_DATE;
+
+typedef struct _FEATURE_DATA_AACS {
+  FEATURE_HEADER Header;
+  UCHAR BindingNonceGeneration:1;
+  UCHAR Reserved0:7;
+  UCHAR BindingNonceBlockCount;
+  UCHAR NumberOfAGIDs:4;
+  UCHAR Reserved1:4;
+  UCHAR AACSVersion;
+} FEATURE_DATA_AACS, *PFEATURE_DATA_AACS;
+
+typedef struct _FEATURE_VCPS {
+  FEATURE_HEADER Header;
+  UCHAR Reserved[4];
+} FEATURE_VCPS, *PFEATURE_VCPS;
+
+typedef struct _FEATURE_DATA_RESERVED {
+  FEATURE_HEADER Header;
+#if !defined(__midl) && !defined(__WIDL__)
+  UCHAR Data[1];
+#endif
+} FEATURE_DATA_RESERVED, *PFEATURE_DATA_RESERVED;
+
+typedef struct _FEATURE_DATA_VENDOR_SPECIFIC {
+  FEATURE_HEADER Header;
+#if !defined(__midl) && !defined(__WIDL__)
+  UCHAR VendorSpecificData[1];
+#endif
+} FEATURE_DATA_VENDOR_SPECIFIC, *PFEATURE_DATA_VENDOR_SPECIFIC;
+
+typedef struct _GET_CONFIGURATION_IOCTL_INPUT {
+  FEATURE_NUMBER Feature;
+  ULONG RequestType;
+  PVOID Reserved[2];
+} GET_CONFIGURATION_IOCTL_INPUT, *PGET_CONFIGURATION_IOCTL_INPUT;
+
+#if defined(_WIN64)
+typedef struct _GET_CONFIGURATION_IOCTL_INPUT32 {
+  FEATURE_NUMBER Feature;
+  ULONG RequestType;
+  VOID* UPOINTER_32 Reserved[2];
+} GET_CONFIGURATION_IOCTL_INPUT32, *PGET_CONFIGURATION_IOCTL_INPUT32;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
diff -Nru -x '*~' kdewin-0.5.6.orig/include/ntddstor.h kdewin-0.5.6/include/ntddstor.h
--- kdewin-0.5.6.orig/include/ntddstor.h	1970-01-01 01:00:00.000000000 +0100
+++ kdewin-0.5.6/include/ntddstor.h	2013-05-30 22:02:10.791259400 +0200
@@ -0,0 +1,704 @@
+/*
+ * ntddstor.h
+ *
+ * Storage class IOCTL interface.
+ *
+ * This file is part of the kdewin package and is originally from the mingw-w64 w32api package.
+ *
+ * Contributors:
+ *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
+ *   Modified by Patrick Spendrin <ps_ml@gmx.de>
+ *
+ * THIS SOFTWARE IS NOT COPYRIGHTED
+ *
+ * This source code is offered for use in the public domain. You may
+ * use, modify or distribute it freely.
+ *
+ * This code is distributed in the hope that it will be useful but
+ * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
+ * DISCLAIMED. This includes but is not limited to warranties of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+#ifndef _NTDDSTOR_H_
+#define _NTDDSTOR_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <windows.h>
+#include <winioctl.h>
+
+#if defined(DEFINE_GUID)
+
+DEFINE_GUID(GUID_DEVINTERFACE_DISK,
+  0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_CDROM,
+  0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_PARTITION,
+  0x53f5630aL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_TAPE,
+  0x53f5630bL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_WRITEONCEDISK,
+  0x53f5630cL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_VOLUME,
+  0x53f5630dL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_MEDIUMCHANGER,
+  0x53f56310L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_FLOPPY,
+  0x53f56311L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_CDCHANGER,
+  0x53f56312L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_STORAGEPORT,
+  0x2accfe60L, 0xc130, 0x11d2, 0xb0, 0x82, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
+
+DEFINE_GUID(GUID_DEVINTERFACE_HIDDEN_VOLUME,
+  0x7f108a28L, 0x9833, 0x4b3b, 0xb7, 0x80, 0x2c, 0x6b, 0x5f, 0xa5, 0xc0, 0x62);
+
+#define WDI_STORAGE_PREDICT_FAILURE_DPS_GUID \
+  {0xe9f2d03aL, 0x747c, 0x41c2, {0xbb, 0x9a, 0x02, 0xc6, 0x2b, 0x6d, 0x5f, 0xcb}};
+
+/* Aliases for storage guids */
+#define DiskClassGuid               GUID_DEVINTERFACE_DISK
+#define CdRomClassGuid              GUID_DEVINTERFACE_CDROM
+#define PartitionClassGuid          GUID_DEVINTERFACE_PARTITION
+#define TapeClassGuid               GUID_DEVINTERFACE_TAPE
+#define WriteOnceDiskClassGuid      GUID_DEVINTERFACE_WRITEONCEDISK
+#define VolumeClassGuid             GUID_DEVINTERFACE_VOLUME
+#define MediumChangerClassGuid      GUID_DEVINTERFACE_MEDIUMCHANGER
+#define FloppyClassGuid             GUID_DEVINTERFACE_FLOPPY
+#define CdChangerClassGuid          GUID_DEVINTERFACE_CDCHANGER
+#define StoragePortClassGuid        GUID_DEVINTERFACE_STORAGEPORT
+#define HiddenVolumeClassGuid       GUID_DEVINTERFACE_HIDDEN_VOLUME
+
+#endif /* defined(DEFINE_GUID) */
+
+#ifndef _WINIOCTL_
+
+#define IOCTL_STORAGE_BASE                FILE_DEVICE_MASS_STORAGE
+
+#define IOCTL_STORAGE_CHECK_VERIFY \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_CHECK_VERIFY2 \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_MEDIA_REMOVAL \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_EJECT_MEDIA \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_LOAD_MEDIA \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_LOAD_MEDIA2 \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_RESERVE \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_RELEASE \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_FIND_NEW_DEVICES \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_EJECTION_CONTROL \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0250, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_MCN_CONTROL \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0251, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_GET_MEDIA_TYPES \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_GET_MEDIA_TYPES_EX \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0301, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_RESET_BUS \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_RESET_DEVICE \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_GET_DEVICE_NUMBER \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0420, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_PREDICT_FAILURE \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0440, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#endif /* _WINIOCTL_ */
+
+#define IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0304, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_GET_HOTPLUG_INFO \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0305, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_SET_HOTPLUG_INFO \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0306, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
+
+#define OBSOLETE_IOCTL_STORAGE_RESET_BUS \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
+
+#define OBSOLETE_IOCTL_STORAGE_RESET_DEVICE \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
+
+#define IOCTL_STORAGE_BREAK_RESERVATION \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_PERSISTENT_RESERVE_IN \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_PERSISTENT_RESERVE_OUT \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0407, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
+
+#define IOCTL_STORAGE_READ_CAPACITY \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_QUERY_PROPERTY \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0500, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0501, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+#define IOCTL_STORAGE_GET_BC_PROPERTIES \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0600, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+#define IOCTL_STORAGE_ALLOCATE_BC_STREAM \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0601, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
+
+#define IOCTL_STORAGE_FREE_BC_STREAM \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0602, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
+
+#define IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT \
+  CTL_CODE(IOCTL_STORAGE_BASE, 0x0620, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define RECOVERED_WRITES_VALID         0x00000001
+#define UNRECOVERED_WRITES_VALID       0x00000002
+#define RECOVERED_READS_VALID          0x00000004
+#define UNRECOVERED_READS_VALID        0x00000008
+#define WRITE_COMPRESSION_INFO_VALID   0x00000010
+#define READ_COMPRESSION_INFO_VALID    0x00000020
+
+#define TAPE_RETURN_STATISTICS         0L
+#define TAPE_RETURN_ENV_INFO           1L
+#define TAPE_RESET_STATISTICS          2L
+
+/* DEVICE_MEDIA_INFO.DeviceSpecific.DiskInfo.MediaCharacteristics constants */
+#define MEDIA_ERASEABLE                   0x00000001
+#define MEDIA_WRITE_ONCE                  0x00000002
+#define MEDIA_READ_ONLY                   0x00000004
+#define MEDIA_READ_WRITE                  0x00000008
+#define MEDIA_WRITE_PROTECTED             0x00000100
+#define MEDIA_CURRENTLY_MOUNTED           0x80000000
+
+#define StorageIdTypeNAA StorageIdTypeFCPHName
+
+#define DeviceDsmActionFlag_NonDestructive  0x80000000
+
+#define IsDsmActionNonDestructive(_Action) ((BOOLEAN)((_Action & DeviceDsmActionFlag_NonDestructive) != 0))
+
+#define DeviceDsmAction_None            0
+#define DeviceDsmAction_Trim            1
+#define DeviceDsmAction_Notification   (2 | DeviceDsmActionFlag_NonDestructive)
+
+#define DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE    0x00000001
+
+#define DEVICE_DSM_NOTIFY_FLAG_BEGIN             0x00000001
+#define DEVICE_DSM_NOTIFY_FLAG_END               0x00000002
+
+#define IOCTL_STORAGE_BC_VERSION                 1
+
+#define STORAGE_PRIORITY_HINT_SUPPORTED          0x0001
+
+typedef struct _STORAGE_HOTPLUG_INFO {
+  ULONG Size;
+  BOOLEAN MediaRemovable;
+  BOOLEAN MediaHotplug;
+  BOOLEAN DeviceHotplug;
+  BOOLEAN WriteCacheEnableOverride;
+} STORAGE_HOTPLUG_INFO, *PSTORAGE_HOTPLUG_INFO;
+
+typedef struct _STORAGE_DEVICE_NUMBER {
+  DEVICE_TYPE DeviceType;
+  ULONG DeviceNumber;
+  ULONG PartitionNumber;
+} STORAGE_DEVICE_NUMBER, *PSTORAGE_DEVICE_NUMBER;
+
+typedef struct _STORAGE_BUS_RESET_REQUEST {
+  UCHAR PathId;
+} STORAGE_BUS_RESET_REQUEST, *PSTORAGE_BUS_RESET_REQUEST;
+
+typedef struct _STORAGE_BREAK_RESERVATION_REQUEST {
+  ULONG Length;
+  UCHAR _unused;
+  UCHAR PathId;
+  UCHAR TargetId;
+  UCHAR Lun;
+} STORAGE_BREAK_RESERVATION_REQUEST, *PSTORAGE_BREAK_RESERVATION_REQUEST;
+
+#ifndef _WINIOCTL_
+typedef struct _PREVENT_MEDIA_REMOVAL {
+  BOOLEAN PreventMediaRemoval;
+} PREVENT_MEDIA_REMOVAL, *PPREVENT_MEDIA_REMOVAL;
+#endif
+
+typedef struct _CLASS_MEDIA_CHANGE_CONTEXT {
+  ULONG MediaChangeCount;
+  ULONG NewState;
+} CLASS_MEDIA_CHANGE_CONTEXT, *PCLASS_MEDIA_CHANGE_CONTEXT;
+
+typedef struct _TAPE_STATISTICS {
+  ULONG Version;
+  ULONG Flags;
+  LARGE_INTEGER RecoveredWrites;
+  LARGE_INTEGER UnrecoveredWrites;
+  LARGE_INTEGER RecoveredReads;
+  LARGE_INTEGER UnrecoveredReads;
+  UCHAR CompressionRatioReads;
+  UCHAR CompressionRatioWrites;
+} TAPE_STATISTICS, *PTAPE_STATISTICS;
+
+typedef struct _TAPE_GET_STATISTICS {
+  ULONG Operation;
+} TAPE_GET_STATISTICS, *PTAPE_GET_STATISTICS;
+
+typedef enum _STORAGE_MEDIA_TYPE {
+  DDS_4mm = 0x20,
+  MiniQic,
+  Travan,
+  QIC,
+  MP_8mm,
+  AME_8mm,
+  AIT1_8mm,
+  DLT,
+  NCTP,
+  IBM_3480,
+  IBM_3490E,
+  IBM_Magstar_3590,
+  IBM_Magstar_MP,
+  STK_DATA_D3,
+  SONY_DTF,
+  DV_6mm,
+  DMI,
+  SONY_D2,
+  CLEANER_CARTRIDGE,
+  CD_ROM,
+  CD_R,
+  CD_RW,
+  DVD_ROM,
+  DVD_R,
+  DVD_RW,
+  MO_3_RW,
+  MO_5_WO,
+  MO_5_RW,
+  MO_5_LIMDOW,
+  PC_5_WO,
+  PC_5_RW,
+  PD_5_RW,
+  ABL_5_WO,
+  PINNACLE_APEX_5_RW,
+  SONY_12_WO,
+  PHILIPS_12_WO,
+  HITACHI_12_WO,
+  CYGNET_12_WO,
+  KODAK_14_WO,
+  MO_NFR_525,
+  NIKON_12_RW,
+  IOMEGA_ZIP,
+  IOMEGA_JAZ,
+  SYQUEST_EZ135,
+  SYQUEST_EZFLYER,
+  SYQUEST_SYJET,
+  AVATAR_F2,
+  MP2_8mm,
+  DST_S,
+  DST_M,
+  DST_L,
+  VXATape_1,
+  VXATape_2,
+#if (NTDDI_VERSION < NTDDI_WINXP)
+  STK_EAGLE,
+#else
+  STK_9840,
+#endif
+  LTO_Ultrium,
+  LTO_Accelis,
+  DVD_RAM,
+  AIT_8mm,
+  ADR_1,
+  ADR_2,
+  STK_9940,
+  SAIT,
+  VXATape
+} STORAGE_MEDIA_TYPE, *PSTORAGE_MEDIA_TYPE;
+
+typedef enum _STORAGE_BUS_TYPE {
+  BusTypeUnknown = 0x00,
+  BusTypeScsi,
+  BusTypeAtapi,
+  BusTypeAta,
+  BusType1394,
+  BusTypeSsa,
+  BusTypeFibre,
+  BusTypeUsb,
+  BusTypeRAID,
+  BusTypeiScsi,
+  BusTypeSas,
+  BusTypeSata,
+  BusTypeSd,
+  BusTypeMmc,
+  BusTypeVirtual,
+  BusTypeFileBackedVirtual,
+  BusTypeMax,
+  BusTypeMaxReserved = 0x7F
+} STORAGE_BUS_TYPE, *PSTORAGE_BUS_TYPE;
+
+typedef struct _DEVICE_MEDIA_INFO {
+  union {
+    struct {
+      LARGE_INTEGER Cylinders;
+      STORAGE_MEDIA_TYPE MediaType;
+      ULONG TracksPerCylinder;
+      ULONG SectorsPerTrack;
+      ULONG BytesPerSector;
+      ULONG NumberMediaSides;
+      ULONG MediaCharacteristics;
+    } DiskInfo;
+    struct {
+      LARGE_INTEGER Cylinders;
+      STORAGE_MEDIA_TYPE MediaType;
+      ULONG TracksPerCylinder;
+      ULONG SectorsPerTrack;
+      ULONG BytesPerSector;
+      ULONG NumberMediaSides;
+      ULONG MediaCharacteristics;
+    } RemovableDiskInfo;
+    struct {
+      STORAGE_MEDIA_TYPE MediaType;
+      ULONG MediaCharacteristics;
+      ULONG CurrentBlockSize;
+      STORAGE_BUS_TYPE BusType;
+      union {
+        struct {
+          UCHAR MediumType;
+          UCHAR DensityCode;
+        } ScsiInformation;
+      } BusSpecificData;
+    } TapeInfo;
+  } DeviceSpecific;
+} DEVICE_MEDIA_INFO, *PDEVICE_MEDIA_INFO;
+
+typedef struct _GET_MEDIA_TYPES {
+  ULONG DeviceType;
+  ULONG MediaInfoCount;
+  DEVICE_MEDIA_INFO MediaInfo[1];
+} GET_MEDIA_TYPES, *PGET_MEDIA_TYPES;
+
+typedef struct _STORAGE_PREDICT_FAILURE {
+  ULONG PredictFailure;
+  UCHAR VendorSpecific[512];
+} STORAGE_PREDICT_FAILURE, *PSTORAGE_PREDICT_FAILURE;
+
+typedef enum _STORAGE_QUERY_TYPE {
+  PropertyStandardQuery = 0,
+  PropertyExistsQuery,
+  PropertyMaskQuery,
+  PropertyQueryMaxDefined
+} STORAGE_QUERY_TYPE, *PSTORAGE_QUERY_TYPE;
+
+typedef enum _STORAGE_PROPERTY_ID {
+  StorageDeviceProperty = 0,
+  StorageAdapterProperty,
+  StorageDeviceIdProperty,
+  StorageDeviceUniqueIdProperty,
+  StorageDeviceWriteCacheProperty,
+  StorageMiniportProperty,
+  StorageAccessAlignmentProperty,
+  StorageDeviceSeekPenaltyProperty,
+  StorageDeviceTrimProperty,
+  StorageDeviceWriteAggregationProperty
+} STORAGE_PROPERTY_ID, *PSTORAGE_PROPERTY_ID;
+
+typedef struct _STORAGE_PROPERTY_QUERY {
+  STORAGE_PROPERTY_ID PropertyId;
+  STORAGE_QUERY_TYPE QueryType;
+  UCHAR AdditionalParameters[1];
+} STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;
+
+typedef struct _STORAGE_DESCRIPTOR_HEADER {
+  ULONG Version;
+  ULONG Size;
+} STORAGE_DESCRIPTOR_HEADER, *PSTORAGE_DESCRIPTOR_HEADER;
+
+typedef struct _STORAGE_DEVICE_DESCRIPTOR {
+  ULONG Version;
+  ULONG Size;
+  UCHAR DeviceType;
+  UCHAR DeviceTypeModifier;
+  BOOLEAN RemovableMedia;
+  BOOLEAN CommandQueueing;
+  ULONG VendorIdOffset;
+  ULONG ProductIdOffset;
+  ULONG ProductRevisionOffset;
+  ULONG SerialNumberOffset;
+  STORAGE_BUS_TYPE BusType;
+  ULONG RawPropertiesLength;
+  UCHAR RawDeviceProperties[1];
+} STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;
+
+typedef struct _STORAGE_ADAPTER_DESCRIPTOR {
+  ULONG Version;
+  ULONG Size;
+  ULONG MaximumTransferLength;
+  ULONG MaximumPhysicalPages;
+  ULONG AlignmentMask;
+  BOOLEAN AdapterUsesPio;
+  BOOLEAN AdapterScansDown;
+  BOOLEAN CommandQueueing;
+  BOOLEAN AcceleratedTransfer;
+#if (NTDDI_VERSION < NTDDI_WINXP)
+  BOOLEAN BusType;
+#else
+  UCHAR BusType;
+#endif
+  USHORT BusMajorVersion;
+  USHORT BusMinorVersion;
+} STORAGE_ADAPTER_DESCRIPTOR, *PSTORAGE_ADAPTER_DESCRIPTOR;
+
+typedef struct _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR {
+  ULONG Version;
+  ULONG Size;
+  ULONG BytesPerCacheLine;
+  ULONG BytesOffsetForCacheAlignment;
+  ULONG BytesPerLogicalSector;
+  ULONG BytesPerPhysicalSector;
+  ULONG BytesOffsetForSectorAlignment;
+} STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR, *PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;
+
+typedef enum _STORAGE_PORT_CODE_SET {
+  StoragePortCodeSetReserved = 0,
+  StoragePortCodeSetStorport = 1,
+  StoragePortCodeSetSCSIport = 2
+} STORAGE_PORT_CODE_SET, *PSTORAGE_PORT_CODE_SET;
+
+typedef struct _STORAGE_MINIPORT_DESCRIPTOR {
+  ULONG Version;
+  ULONG Size;
+  STORAGE_PORT_CODE_SET Portdriver;
+  BOOLEAN LUNResetSupported;
+  BOOLEAN TargetResetSupported;
+} STORAGE_MINIPORT_DESCRIPTOR, *PSTORAGE_MINIPORT_DESCRIPTOR;
+
+typedef enum _STORAGE_IDENTIFIER_CODE_SET {
+  StorageIdCodeSetReserved = 0,
+  StorageIdCodeSetBinary = 1,
+  StorageIdCodeSetAscii = 2,
+  StorageIdCodeSetUtf8 = 3
+} STORAGE_IDENTIFIER_CODE_SET, *PSTORAGE_IDENTIFIER_CODE_SET;
+
+typedef enum _STORAGE_IDENTIFIER_TYPE {
+  StorageIdTypeVendorSpecific = 0,
+  StorageIdTypeVendorId = 1,
+  StorageIdTypeEUI64 = 2,
+  StorageIdTypeFCPHName = 3,
+  StorageIdTypePortRelative = 4,
+  StorageIdTypeTargetPortGroup = 5,
+  StorageIdTypeLogicalUnitGroup = 6,
+  StorageIdTypeMD5LogicalUnitIdentifier = 7,
+  StorageIdTypeScsiNameString = 8
+} STORAGE_IDENTIFIER_TYPE, *PSTORAGE_IDENTIFIER_TYPE;
+
+typedef enum _STORAGE_ID_NAA_FORMAT {
+  StorageIdNAAFormatIEEEExtended = 2,
+  StorageIdNAAFormatIEEERegistered = 3,
+  StorageIdNAAFormatIEEEERegisteredExtended = 5
+} STORAGE_ID_NAA_FORMAT, *PSTORAGE_ID_NAA_FORMAT;
+
+typedef enum _STORAGE_ASSOCIATION_TYPE {
+  StorageIdAssocDevice = 0,
+  StorageIdAssocPort = 1,
+  StorageIdAssocTarget = 2
+} STORAGE_ASSOCIATION_TYPE, *PSTORAGE_ASSOCIATION_TYPE;
+
+typedef struct _STORAGE_IDENTIFIER {
+  STORAGE_IDENTIFIER_CODE_SET CodeSet;
+  STORAGE_IDENTIFIER_TYPE Type;
+  USHORT IdentifierSize;
+  USHORT NextOffset;
+  STORAGE_ASSOCIATION_TYPE Association;
+  UCHAR Identifier[1];
+} STORAGE_IDENTIFIER, *PSTORAGE_IDENTIFIER;
+
+typedef struct _STORAGE_DEVICE_ID_DESCRIPTOR {
+  ULONG Version;
+  ULONG Size;
+  ULONG NumberOfIdentifiers;
+  UCHAR Identifiers[1];
+} STORAGE_DEVICE_ID_DESCRIPTOR, *PSTORAGE_DEVICE_ID_DESCRIPTOR;
+
+typedef struct _DEVICE_SEEK_PENALTY_DESCRIPTOR {
+  ULONG Version;
+  ULONG Size;
+  BOOLEAN IncursSeekPenalty;
+} DEVICE_SEEK_PENALTY_DESCRIPTOR, *PDEVICE_SEEK_PENALTY_DESCRIPTOR;
+
+typedef struct _DEVICE_WRITE_AGGREGATION_DESCRIPTOR {
+  ULONG Version;
+  ULONG Size;
+  BOOLEAN BenefitsFromWriteAggregation;
+} DEVICE_WRITE_AGGREGATION_DESCRIPTOR, *PDEVICE_WRITE_AGGREGATION_DESCRIPTOR;
+
+typedef struct _DEVICE_TRIM_DESCRIPTOR {
+  ULONG Version;
+  ULONG Size;
+  BOOLEAN TrimEnabled;
+} DEVICE_TRIM_DESCRIPTOR, *PDEVICE_TRIM_DESCRIPTOR;
+
+typedef ULONG DEVICE_DATA_MANAGEMENT_SET_ACTION;
+
+typedef struct _DEVICE_DATA_SET_RANGE {
+  LONGLONG StartingOffset;
+  ULONGLONG LengthInBytes;
+} DEVICE_DATA_SET_RANGE, *PDEVICE_DATA_SET_RANGE;
+
+typedef struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
+  ULONG Size;
+  DEVICE_DATA_MANAGEMENT_SET_ACTION Action;
+  ULONG Flags;
+  ULONG ParameterBlockOffset;
+  ULONG ParameterBlockLength;
+  ULONG DataSetRangesOffset;
+  ULONG DataSetRangesLength;
+} DEVICE_MANAGE_DATA_SET_ATTRIBUTES, *PDEVICE_MANAGE_DATA_SET_ATTRIBUTES;
+
+typedef struct _DEVICE_DSM_NOTIFICATION_PARAMETERS {
+  ULONG Size;
+  ULONG Flags;
+  ULONG NumFileTypeIDs;
+  GUID FileTypeID[1];
+} DEVICE_DSM_NOTIFICATION_PARAMETERS, *PDEVICE_DSM_NOTIFICATION_PARAMETERS;
+
+typedef struct _STORAGE_GET_BC_PROPERTIES_OUTPUT {
+  ULONG MaximumRequestsPerPeriod;
+  ULONG MinimumPeriod;
+  ULONGLONG MaximumRequestSize;
+  ULONG EstimatedTimePerRequest;
+  ULONG NumOutStandingRequests;
+  ULONGLONG RequestSize;
+} STORAGE_GET_BC_PROPERTIES_OUTPUT, *PSTORAGE_GET_BC_PROPERTIES_OUTPUT;
+
+typedef struct _STORAGE_ALLOCATE_BC_STREAM_INPUT {
+  ULONG Version;
+  ULONG RequestsPerPeriod;
+  ULONG Period;
+  BOOLEAN RetryFailures;
+  BOOLEAN Discardable;
+  BOOLEAN Reserved1[2];
+  ULONG AccessType;
+  ULONG AccessMode;
+} STORAGE_ALLOCATE_BC_STREAM_INPUT, *PSTORAGE_ALLOCATE_BC_STREAM_INPUT;
+
+typedef struct _STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
+  ULONGLONG RequestSize;
+  ULONG NumOutStandingRequests;
+} STORAGE_ALLOCATE_BC_STREAM_OUTPUT, *PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT;
+
+typedef struct _STORAGE_PRIORITY_HINT_SUPPORT {
+  ULONG SupportFlags;
+} STORAGE_PRIORITY_HINT_SUPPORT, *PSTORAGE_PRIORITY_HINT_SUPPORT;
+
+#if defined(_MSC_EXTENSIONS) || defined(__GNUC__)
+
+typedef struct _STORAGE_MEDIA_SERIAL_NUMBER_DATA {
+  USHORT Reserved;
+  USHORT SerialNumberLength;
+  UCHAR SerialNumber[1];
+} STORAGE_MEDIA_SERIAL_NUMBER_DATA, *PSTORAGE_MEDIA_SERIAL_NUMBER_DATA;
+
+#define __C89_NAMELESS
+typedef struct _PERSISTENT_RESERVE_COMMAND {
+  ULONG Version;
+  ULONG Size;
+
+  __C89_NAMELESS union {
+    struct {
+      UCHAR ServiceAction:5;
+      UCHAR Reserved1:3;
+      USHORT AllocationLength;
+    } PR_IN;
+    struct {
+      UCHAR ServiceAction:5;
+      UCHAR Reserved1:3;
+      UCHAR Type:4;
+      UCHAR Scope:4;
+      UCHAR ParameterList[1];
+    } PR_OUT;
+  } DUMMYUNIONNAME;
+} PERSISTENT_RESERVE_COMMAND, *PPERSISTENT_RESERVE_COMMAND;
+
+#endif /* defined(_MSC_EXTENSIONS) */
+
+typedef struct _STORAGE_READ_CAPACITY {
+  ULONG Version;
+  ULONG Size;
+  ULONG BlockLength;
+  LARGE_INTEGER NumberOfBlocks;
+  LARGE_INTEGER DiskLength;
+} STORAGE_READ_CAPACITY, *PSTORAGE_READ_CAPACITY;
+
+typedef enum _WRITE_CACHE_TYPE {
+  WriteCacheTypeUnknown,
+  WriteCacheTypeNone,
+  WriteCacheTypeWriteBack,
+  WriteCacheTypeWriteThrough
+} WRITE_CACHE_TYPE;
+
+typedef enum _WRITE_CACHE_ENABLE {
+  WriteCacheEnableUnknown,
+  WriteCacheDisabled,
+  WriteCacheEnabled
+} WRITE_CACHE_ENABLE;
+
+typedef enum _WRITE_CACHE_CHANGE {
+  WriteCacheChangeUnknown,
+  WriteCacheNotChangeable,
+  WriteCacheChangeable
+} WRITE_CACHE_CHANGE;
+
+typedef enum _WRITE_THROUGH {
+  WriteThroughUnknown,
+  WriteThroughNotSupported,
+  WriteThroughSupported
+} WRITE_THROUGH;
+
+typedef struct _STORAGE_WRITE_CACHE_PROPERTY {
+  ULONG Version;
+  ULONG Size;
+  WRITE_CACHE_TYPE WriteCacheType;
+  WRITE_CACHE_ENABLE WriteCacheEnabled;
+  WRITE_CACHE_CHANGE WriteCacheChangeable;
+  WRITE_THROUGH WriteThroughSupported;
+  BOOLEAN FlushCacheSupported;
+  BOOLEAN UserDefinedPowerProtection;
+  BOOLEAN NVCacheEnabled;
+} STORAGE_WRITE_CACHE_PROPERTY, *PSTORAGE_WRITE_CACHE_PROPERTY;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NTDDSTOR_H_ */
diff -Nru -x '*~' kdewin-0.5.6.orig/include/winioctl_backport.h kdewin-0.5.6/include/winioctl_backport.h
--- kdewin-0.5.6.orig/include/winioctl_backport.h	1970-01-01 01:00:00.000000000 +0100
+++ kdewin-0.5.6/include/winioctl_backport.h	2013-05-31 12:01:52.610144700 +0200
@@ -0,0 +1,87 @@
+/*
+ * winioctl_backport.h
+ *
+ * additional IOCTL interface definitions based on the winioctl.h from the new w32api package.
+ *
+ * This file is part of the kdewin package and is originally from the mingw-w64 w32api package.
+ *
+ * Contributors:
+ *   Created by Patrick Spendrin <ps_ml@gmx.de>
+ *
+ * THIS SOFTWARE IS NOT COPYRIGHTED
+ *
+ * This source code is offered for use in the public domain. You may
+ * use, modify or distribute it freely.
+ *
+ * This code is distributed in the hope that it will be useful but
+ * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
+ * DISCLAIMED. This includes but is not limited to warranties of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+#ifndef WINIOCTL_BACKPORT_H
+#define WINIOCTL_BACKPORT_H
+
+#include <winioctl.h>
+
+#define IOCTL_STORAGE_QUERY_PROPERTY CTL_CODE(IOCTL_STORAGE_BASE, 0x0500, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+typedef enum _STORAGE_PROPERTY_ID {
+  StorageDeviceProperty              = 0,
+  StorageAdapterProperty             = 1,
+  StorageDeviceIdProperty            = 2,
+  StorageDeviceUniqueIdProperty      = 3,
+  StorageDeviceWriteCacheProperty    = 4,
+  StorageMiniportProperty            = 5,
+  StorageAccessAlignmentProperty     = 6,
+  StorageDeviceSeekPenaltyProperty   = 7,
+  StorageDeviceTrimProperty          = 8 
+} STORAGE_PROPERTY_ID, *PSTORAGE_PROPERTY_ID;
+
+typedef enum _STORAGE_QUERY_TYPE {
+  PropertyStandardQuery     = 0,
+  PropertyExistsQuery       = 1,
+  PropertyMaskQuery         = 2,
+  PropertyQueryMaxDefined   = 3 
+} STORAGE_QUERY_TYPE, *PSTORAGE_QUERY_TYPE;
+
+typedef struct _STORAGE_PROPERTY_QUERY {
+  STORAGE_PROPERTY_ID PropertyId;
+  STORAGE_QUERY_TYPE  QueryType;
+  BYTE                AdditionalParameters[1];
+} STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;
+
+typedef struct _STORAGE_DEVICE_DESCRIPTOR {
+  DWORD            Version;
+  DWORD            Size;
+  BYTE             DeviceType;
+  BYTE             DeviceTypeModifier;
+  BOOLEAN          RemovableMedia;
+  BOOLEAN          CommandQueueing;
+  DWORD            VendorIdOffset;
+  DWORD            ProductIdOffset;
+  DWORD            ProductRevisionOffset;
+  DWORD            SerialNumberOffset;
+  STORAGE_BUS_TYPE BusType;
+  DWORD            RawPropertiesLength;
+  BYTE             RawDeviceProperties[1];
+} STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;
+
+typedef struct _STORAGE_ADAPTER_DESCRIPTOR {
+  DWORD   Version;
+  DWORD   Size;
+  DWORD   MaximumTransferLength;
+  DWORD   MaximumPhysicalPages;
+  DWORD   AlignmentMask;
+  BOOLEAN AdapterUsesPio;
+  BOOLEAN AdapterScansDown;
+  BOOLEAN CommandQueueing;
+  BOOLEAN AcceleratedTransfer;
+  BYTE    BusType;
+  WORD    BusMajorVersion;
+  WORD    BusMinorVersion;
+} STORAGE_ADAPTER_DESCRIPTOR, *PSTORAGE_ADAPTER_DESCRIPTOR;
+
+
+#endif /* WINIOCTL_BACKPORT_H */
\ Kein Zeilenumbruch am Dateiende.
diff -Nru -x '*~' kdewin-0.5.6.orig/src/CMakeLists.txt kdewin-0.5.6/src/CMakeLists.txt
--- kdewin-0.5.6.orig/src/CMakeLists.txt	2013-02-22 14:03:48.000000000 +0100
+++ kdewin-0.5.6/src/CMakeLists.txt	2013-05-31 12:08:25.072592300 +0200
@@ -87,10 +87,36 @@
   ARCHIVE DESTINATION lib
 )
 
+file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/required_ioctls_test.cpp
+"#include <windows.h>
+#include <winioctl.h>
+#if !defined(IOCTL_STORAGE_QUERY_PROPERTY)
+#error 1
+#endif
+
+int main() { return 0; }
+")
+try_compile(HAVE_REQUIRED_IOCTLS ${CMAKE_CURRENT_BINARY_DIR}
+                                 ${CMAKE_CURRENT_BINARY_DIR}/required_ioctls_test.cpp)
+
+set(ddk_HDRS
+  ../include/ntddcdrm.h
+  ../include/ntddcdvd.h
+  ../include/ntddmmc.h
+  ../include/ntddstor.h
+)
+
 install(DIRECTORY ../include/${_incDirPrefix}                  DESTINATION include PATTERN ".svn" EXCLUDE)
 install(FILES ../include/fixwinh.h ../include/kde_file_win.h   DESTINATION include)
 install(FILES ${CMAKE_BINARY_DIR}/include/kdewin_export.h      DESTINATION include)
 
+install(FILES ${ddk_HDRS}                                      DESTINATION include/${_incDirPrefix})
+
+if(MINGW AND NOT HAVE_REQUIRED_IOCTLS)
+    message(STATUS "you miss the required ioctl definitions. Installing winioctl_backport.h")
+    install(FILES ../include/winioctl_backport.h               DESTINATION include/${_incDirPrefix})
+endif(MINGW AND NOT HAVE_REQUIRED_IOCTLS)
+
 if(MINGW32 AND NOT MINGW_W32)
     install(DIRECTORY ../include/directx                       DESTINATION include/${_incDirPrefix} PATTERN ".svn" EXCLUDE)
 endif(MINGW32 AND NOT MINGW_W32)
