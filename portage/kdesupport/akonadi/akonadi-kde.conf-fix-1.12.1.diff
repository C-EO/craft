diff -Nru -x '*~' akonadi-1.12.1.orig/libs/xdgbasedirs.cpp akonadi-1.12.1/libs/xdgbasedirs.cpp
--- akonadi-1.12.1.orig/libs/xdgbasedirs.cpp	2014-04-07 23:02:16.000000000 +0200
+++ akonadi-1.12.1/libs/xdgbasedirs.cpp	2015-07-11 19:01:41.467150900 +0200
@@ -27,9 +27,15 @@
 #include <QtCore/QFileInfo>
 #include <QtCore/QProcess>
 #include <QtCore/QSettings>
+#include <QtCore/QProcessEnvironment>
+#include <QtCore/QRegexp>
 
 #include <cstdlib>
 
+#ifdef Q_OS_WIN
+# include <windows.h>
+#endif
+
 static QStringList alternateExecPaths( const QString &path )
 {
   QStringList pathList;
@@ -54,6 +60,57 @@
 #endif
 }
 
+#ifdef Q_OS_WIN
+static QMap<QString, QString> getEnvironment()
+{
+    QMap<QString, QString> ret;
+    Q_FOREACH(const QString& str, QProcessEnvironment::systemEnvironment().toStringList())
+    {
+        const int p = str.indexOf(QLatin1Char('='));
+        ret[str.left(p)] = str.mid(p + 1);
+    }
+    return ret;
+}
+
+QString expandEnvironmentVariables(const QString& str)
+{
+    static QMap<QString, QString> envVars = getEnvironment();
+    static QRegExp possibleVars(QLatin1String("((\\{|%)(\\w+)(\\}|%))"));
+    QString ret = str;
+    while(possibleVars.indexIn(ret) != -1)
+    {
+        QStringList caps = possibleVars.capturedTexts();
+        if(caps[2] == QLatin1String("{"))
+        {
+            ret.replace(QLatin1String("$") + caps[1], envVars[caps[3]]);
+        }
+        else
+        {
+            ret.replace(caps[1], envVars[caps[3]]);
+        }
+        QString key = possibleVars.cap();
+        ret.replace(key, envVars[key]);
+    }
+    return ret;
+}
+
+static QSettings* getKdeConf()
+{
+    WCHAR wPath[MAX_PATH+1];
+    GetModuleFileNameW(NULL, wPath, MAX_PATH);
+    QString kdeconfPath = QString::fromUtf16((const ushort *) wPath);
+    kdeconfPath = kdeconfPath.left(kdeconfPath.lastIndexOf(QLatin1Char('\\'))).replace(QLatin1Char('\\'), QLatin1Char('/'));
+    if(QFile::exists(kdeconfPath + QString::fromLatin1("/kde.conf")))
+    {
+        return new QSettings(kdeconfPath + QString::fromLatin1("/kde.conf"), QSettings::IniFormat);
+    }
+    else
+    {
+        return 0;
+    }
+}
+#endif
+
 namespace Akonadi {
 
 class XdgBaseDirsPrivate
@@ -103,14 +160,43 @@
 
 QString XdgBaseDirs::homePath( const char *resource )
 {
+#ifdef Q_OS_WIN
+  static QSettings* kdeconf = getKdeConf();
+#endif
   if ( qstrncmp( "data", resource, 4 ) == 0 ) {
     if ( instance()->mDataHome.isEmpty() ) {
-      instance()->mDataHome = instance()->homePath( "XDG_DATA_HOME", ".local/share" );
+#ifdef Q_OS_WIN
+      if(kdeconf) {
+        kdeconf->beginGroup(QLatin1String("XDG"));
+        if(kdeconf->childKeys().contains(QLatin1String("XDG_DATA_HOME")))
+          instance()->mDataHome = expandEnvironmentVariables(kdeconf->value(QLatin1String("XDG_DATA_HOME")).toString());
+        else
+          instance()->mDataHome = instance()->homePath( "XDG_DATA_HOME", ".local/share" );
+        kdeconf->endGroup();
+      } else {
+#else
+      {
+#endif
+        instance()->mDataHome = instance()->homePath( "XDG_DATA_HOME", ".local/share" );
+      }
     }
     return instance()->mDataHome;
   } else if ( qstrncmp( "config", resource, 6 ) == 0 ) {
     if ( instance()->mConfigHome.isEmpty() ) {
-      instance()->mConfigHome = instance()->homePath( "XDG_CONFIG_HOME", ".config" );
+#ifdef Q_OS_WIN
+      if(kdeconf) {
+         kdeconf->beginGroup(QLatin1String("XDG"));
+         if(kdeconf->childKeys().contains(QLatin1String("XDG_CONFIG_HOME")))
+           instance()->mConfigHome = expandEnvironmentVariables(kdeconf->value(QLatin1String("XDG_CONFIG_HOME")).toString());
+         else
+           instance()->mConfigHome = instance()->homePath( "XDG_CONFIG_HOME", ".config" );
+         kdeconf->endGroup();
+      } else {
+#else
+      {
+#endif
+        instance()->mConfigHome = instance()->homePath( "XDG_CONFIG_HOME", ".config" );
+      }
     }
     return instance()->mConfigHome;
   }
@@ -120,25 +206,40 @@
 
 QStringList XdgBaseDirs::systemPathList( const char *resource )
 {
+#ifdef Q_OS_WIN
+  static QSettings* kdeconf = getKdeConf();
+#endif
   if ( qstrncmp( "data", resource, 4 ) == 0 ) {
     if ( instance()->mDataDirs.isEmpty() ) {
 #ifdef Q_OS_WIN
-      QDir dir( QCoreApplication::applicationDirPath() );
-      dir.cdUp();
-      const QString defaultPathList = dir.absoluteFilePath( QLatin1String( "share" ) );
-      QStringList dataDirs = instance()->systemPathList( "XDG_DATA_DIRS", defaultPathList.toLocal8Bit().constData() );
+      QStringList dataDirs;
+      if(kdeconf) {
+        kdeconf->beginGroup(QLatin1String("XDG"));
+        if(kdeconf->childKeys().contains(QLatin1String("XDG_DATA_DIRS"))) {
+          dataDirs = instance()->systemPathList( "XDG_DATA_DIRS", expandEnvironmentVariables(kdeconf->value(QLatin1String("XDG_DATA_DIRS")).toString()).toLocal8Bit().constData() );
+        } else {
+          QDir dir( QCoreApplication::applicationDirPath() );
+          dir.cdUp();
+          const QString defaultPathList = dir.absoluteFilePath( QLatin1String( "share" ) );
+          dataDirs = instance()->systemPathList( "XDG_DATA_DIRS", defaultPathList.toLocal8Bit().constData() );
+        }
+        kdeconf->endGroup();
+      } else {
+        QDir dir( QCoreApplication::applicationDirPath() );
+        dir.cdUp();
+        const QString defaultPathList = dir.absoluteFilePath( QLatin1String( "share" ) );
+        dataDirs = instance()->systemPathList( "XDG_DATA_DIRS", defaultPathList.toLocal8Bit().constData() );
+      }
 #else
       QStringList dataDirs = instance()->systemPathList( "XDG_DATA_DIRS", "/usr/local/share:/usr/share" );
 #endif
 
-#ifdef Q_OS_WIN
-      const QString prefixDataDir = QLatin1String( AKONADIPREFIX "/" AKONADIDATA );
-#else
+#ifndef Q_OS_WIN
       const QString prefixDataDir = QLatin1String( AKONADIDATA );
-#endif
       if ( !dataDirs.contains( prefixDataDir ) ) {
         dataDirs << prefixDataDir;
       }
+#endif
 
       // fallback for users with KDE in a different prefix and not correctly set up XDG_DATA_DIRS, hi David ;-)
       QProcess proc;
@@ -180,22 +281,34 @@
   } else if ( qstrncmp( "config", resource, 6 ) == 0 ) {
     if ( instance()->mConfigDirs.isEmpty() ) {
 #ifdef Q_OS_WIN
-      QDir dir( QCoreApplication::applicationDirPath() );
-      dir.cdUp();
-      const QString defaultPathList = dir.absoluteFilePath( QLatin1String( "etc" ) ) + QLatin1Char( ';' ) + dir.absoluteFilePath( QLatin1String( "share/config" ) );
-      QStringList configDirs = instance()->systemPathList( "XDG_CONFIG_DIRS", defaultPathList.toLocal8Bit().constData() );
+      QStringList configDirs;
+      if(kdeconf) {
+        kdeconf->beginGroup(QLatin1String("XDG"));
+        if(kdeconf->childKeys().contains(QLatin1String("XDG_CONFIG_DIRS"))) {
+            configDirs = instance()->systemPathList( "XDG_CONFIG_DIRS", expandEnvironmentVariables(kdeconf->value(QLatin1String("XDG_CONFIG_DIRS")).toString()).toLocal8Bit().constData() );
+        } else {
+            QDir dir( QCoreApplication::applicationDirPath() );
+            dir.cdUp();
+            const QString defaultPathList = dir.absoluteFilePath( QLatin1String( "etc" ) ) + QLatin1Char( ';' ) + dir.absoluteFilePath( QLatin1String( "share/config" ) );
+            configDirs = instance()->systemPathList( "XDG_CONFIG_DIRS", defaultPathList.toLocal8Bit().constData() );
+        }
+        kdeconf->endGroup();
+      } else {
+        QDir dir( QCoreApplication::applicationDirPath() );
+        dir.cdUp();
+        const QString defaultPathList = dir.absoluteFilePath( QLatin1String( "etc" ) ) + QLatin1Char( ';' ) + dir.absoluteFilePath( QLatin1String( "share/config" ) );
+        configDirs = instance()->systemPathList( "XDG_CONFIG_DIRS", defaultPathList.toLocal8Bit().constData() );
+      }
 #else
       QStringList configDirs = instance()->systemPathList( "XDG_CONFIG_DIRS", "/etc/xdg" );
 #endif
 
-#ifdef Q_OS_WIN
-      const QString prefixConfigDir = QLatin1String( AKONADIPREFIX "/" AKONADICONFIG );
-#else
+#ifndef Q_OS_WIN
       const QString prefixConfigDir = QLatin1String( AKONADICONFIG );
-#endif
       if ( !configDirs.contains( prefixConfigDir ) ) {
         configDirs << prefixConfigDir;
       }
+#endif
 
       instance()->mConfigDirs = configDirs;
     }
@@ -231,10 +344,12 @@
   if ( instance()->mExecutableDirs.isEmpty() ) {
     QStringList executableDirs = instance()->systemPathList( "PATH", "/usr/local/bin:/usr/bin" );
 
+#if !defined(Q_OS_WIN)
     const QString prefixExecutableDir = QLatin1String( AKONADIPREFIX "/bin" );
     if ( !executableDirs.contains( prefixExecutableDir ) ) {
       executableDirs << prefixExecutableDir;
     }
+#endif
 
     if ( QCoreApplication::instance() != 0 ) {
       const QString appExecutableDir = QCoreApplication::instance()->applicationDirPath();
diff -Nru -x '*~' akonadi-1.12.1.orig/server/CMakeLists.txt akonadi-1.12.1/server/CMakeLists.txt
--- akonadi-1.12.1.orig/server/CMakeLists.txt	2014-04-07 23:02:16.000000000 +0200
+++ akonadi-1.12.1/server/CMakeLists.txt	2015-07-11 18:27:27.814688700 +0200
@@ -1,25 +1,27 @@
-find_program(MYSQLD_EXECUTABLE NAMES mysqld
-              PATHS /usr/sbin /usr/local/sbin /usr/libexec /usr/local/libexec /opt/mysql/libexec /usr/mysql/bin /opt/mysql/sbin
-              DOC "The mysqld executable path. ONLY needed at runtime"
-            )
-
-if(MYSQLD_EXECUTABLE)
-   message(STATUS "MySQL Server found: ${MYSQLD_EXECUTABLE}")
-else()
-   message(STATUS "MySQL Server wasn't found. it is required to use the MySQL backend.")
-endif()
-
-find_path(POSTGRES_PATH NAMES pg_ctl
-              HINTS /usr/lib${LIB_SUFFIX}/postgresql/8.4/bin
-                    /usr/lib${LIB_SUFFIX}/postgresql/9.0/bin
-                    /usr/lib${LIB_SUFFIX}/postgresql/9.1/bin
-              DOC "The pg_ctl executable path. ONLY needed at runtime by the PostgreSQL backend"
-         )
-
-if(POSTGRES_PATH)
-   message(STATUS "PostgreSQL Server found.")
-else()
-   message(STATUS "PostgreSQL wasn't found. it is required to use the Postgres backend.")
+if(NOT WIN32)
+  find_program(MYSQLD_EXECUTABLE NAMES mysqld
+                PATHS /usr/sbin /usr/local/sbin /usr/libexec /usr/local/libexec /opt/mysql/libexec /usr/mysql/bin /opt/mysql/sbin
+                DOC "The mysqld executable path. ONLY needed at runtime"
+              )
+
+  if(MYSQLD_EXECUTABLE)
+    message(STATUS "MySQL Server found: ${MYSQLD_EXECUTABLE}")
+  else()
+    message(STATUS "MySQL Server wasn't found. it is required to use the MySQL backend.")
+  endif()
+
+  find_path(POSTGRES_PATH NAMES pg_ctl
+                HINTS /usr/lib${LIB_SUFFIX}/postgresql/8.4/bin
+                      /usr/lib${LIB_SUFFIX}/postgresql/9.0/bin
+                      /usr/lib${LIB_SUFFIX}/postgresql/9.1/bin
+                DOC "The pg_ctl executable path. ONLY needed at runtime by the PostgreSQL backend"
+          )
+
+  if(POSTGRES_PATH)
+    message(STATUS "PostgreSQL Server found.")
+  else()
+    message(STATUS "PostgreSQL wasn't found. it is required to use the Postgres backend.")
+  endif()
 endif()
 
 include_directories(${Akonadi_SOURCE_DIR}/libs)
diff -Nru -x '*~' akonadi-1.12.1.orig/server/src/storage/dbconfigmysql.cpp akonadi-1.12.1/server/src/storage/dbconfigmysql.cpp
--- akonadi-1.12.1.orig/server/src/storage/dbconfigmysql.cpp	2014-04-07 23:02:16.000000000 +0200
+++ akonadi-1.12.1/server/src/storage/dbconfigmysql.cpp	2015-07-11 18:56:16.160544400 +0200
@@ -66,11 +66,12 @@
 #endif
 
   const bool defaultInternalServer = true;
-#ifdef MYSQLD_EXECUTABLE
+#if defined(MYSQLD_EXECUTABLE) && !defined(Q_OS_WIN)
    if ( QFile::exists( QLatin1String( MYSQLD_EXECUTABLE ) ) ) {
      defaultServerPath = QLatin1String( MYSQLD_EXECUTABLE );
    }
 #endif
+  akError() << "defaultServerPath: " << defaultServerPath;
   const QStringList mysqldSearchPath = QStringList()
       << QLatin1String( "/usr/sbin" )
       << QLatin1String( "/usr/local/sbin" )
@@ -389,10 +390,12 @@
 
 void DbConfigMysql::stopInternalServer()
 {
+  akError() << "stopping Database server: " << mDatabaseProcess;
   if ( !mDatabaseProcess ) {
     return;
   }
 
+  akError() << "command to shutdown: " << mCleanServerShutdownCommand;
   // first, try the nicest approach
   if ( !mCleanServerShutdownCommand.isEmpty() ) {
     QProcess::execute( mCleanServerShutdownCommand );
@@ -404,6 +407,7 @@
   mDatabaseProcess->terminate();
   const bool result = mDatabaseProcess->waitForFinished( 3000 );
   // We've waited nicely for 3 seconds, to no avail, let's be rude.
+  akError() << "result for shutdown: " << result;
   if ( !result ) {
     mDatabaseProcess->kill();
   }
